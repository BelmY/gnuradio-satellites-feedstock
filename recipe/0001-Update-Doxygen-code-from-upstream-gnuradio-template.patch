From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Ryan Volz <ryan.volz@gmail.com>
Date: Sat, 19 Feb 2022 10:24:51 -0500
Subject: [PATCH] Update Doxygen code from upstream gnuradio template.

Signed-off-by: Ryan Volz <ryan.volz@gmail.com>
---
 docs/doxygen/CMakeLists.txt                   |   15 +-
 docs/doxygen/Doxyfile.in                      |   41 +-
 docs/doxygen/Doxyfile.swig_doc.in             | 1878 ------------
 docs/doxygen/doxyxml/__init__.py              |   18 +-
 docs/doxygen/doxyxml/base.py                  |   20 +-
 docs/doxygen/doxyxml/doxyindex.py             |   47 +-
 docs/doxygen/doxyxml/generated/__init__.py    |    1 -
 docs/doxygen/doxyxml/generated/compound.py    |  147 +-
 .../doxyxml/generated/compoundsuper.py        | 2540 ++++++++++++-----
 docs/doxygen/doxyxml/generated/index.py       |    7 +-
 docs/doxygen/doxyxml/generated/indexsuper.py  |  123 +-
 docs/doxygen/doxyxml/text.py                  |   21 +-
 docs/doxygen/other/doxypy.py                  |  446 +++
 docs/doxygen/other/group_defs.dox             |    5 +-
 docs/doxygen/other/main_page.dox              |    4 +-
 docs/doxygen/pydoc_macros.h                   |    2 +-
 docs/doxygen/update_pydoc.py                  |  122 +-
 17 files changed, 2654 insertions(+), 2783 deletions(-)
 delete mode 100644 docs/doxygen/Doxyfile.swig_doc.in
 create mode 100644 docs/doxygen/other/doxypy.py

diff --git a/docs/doxygen/CMakeLists.txt b/docs/doxygen/CMakeLists.txt
index b0dc5b6..bc6126d 100644
--- a/docs/doxygen/CMakeLists.txt
+++ b/docs/doxygen/CMakeLists.txt
@@ -3,20 +3,8 @@
 # This file was generated by gr_modtool, a tool from the GNU Radio framework
 # This file is a part of gr-satellites
 #
-# GNU Radio is free software; you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation; either version 3, or (at your option)
-# any later version.
+# SPDX-License-Identifier: GPL-3.0-or-later
 #
-# GNU Radio is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with GNU Radio; see the file COPYING.  If not, write to
-# the Free Software Foundation, Inc., 51 Franklin Street,
-# Boston, MA 02110-1301, USA.
 
 ########################################################################
 # Create the doxygen configuration file
@@ -29,6 +17,7 @@ file(TO_NATIVE_PATH ${CMAKE_BINARY_DIR} abs_top_builddir)
 set(HAVE_DOT ${DOXYGEN_DOT_FOUND})
 set(enable_html_docs YES)
 set(enable_latex_docs NO)
+set(enable_mathjax NO)
 set(enable_xml_docs YES)
 
 configure_file(
diff --git a/docs/doxygen/Doxyfile.in b/docs/doxygen/Doxyfile.in
index ec7a922..435302b 100644
--- a/docs/doxygen/Doxyfile.in
+++ b/docs/doxygen/Doxyfile.in
@@ -199,13 +199,6 @@ TAB_SIZE               = 8
 
 ALIASES                =
 
-# This tag can be used to specify a number of word-keyword mappings (TCL only).
-# A mapping has the form "name=value". For example adding
-# "class=itcl::class" will allow you to use the command class in the
-# itcl::class meaning.
-
-TCL_SUBST              =
-
 # Set the OPTIMIZE_OUTPUT_FOR_C tag to YES if your project consists of C
 # sources only. Doxygen will then generate output that is more tailored for C.
 # For instance, some of the names that are used will be different. The list
@@ -723,8 +716,6 @@ EXCLUDE_PATTERNS       = */.deps/* \
 
 EXCLUDE_SYMBOLS        = ad9862 \
                          numpy \
-                         *swig* \
-                         *Swig* \
                          *my_top_block* \
                          *my_graph* \
                          *app_top_block* \
@@ -790,7 +781,7 @@ INPUT_FILTER           =
 # info on how filters are used. If FILTER_PATTERNS is empty or if
 # non of the patterns match the file name, INPUT_FILTER is applied.
 
-FILTER_PATTERNS        = *.py="@top_srcdir@"/doc/doxygen/other/doxypy.py
+FILTER_PATTERNS        = *.py=@top_srcdir@/docs/doxygen/other/doxypy.py
 
 # If the FILTER_SOURCE_FILES tag is set to YES, the input filter (if set using
 # INPUT_FILTER) will be used to filter the input files when producing source
@@ -879,12 +870,6 @@ VERBATIM_HEADERS       = YES
 
 ALPHABETICAL_INDEX     = YES
 
-# If the alphabetical index is enabled (see ALPHABETICAL_INDEX) then
-# the COLS_IN_ALPHA_INDEX tag can be used to specify the number of columns
-# in which this list will be split (can be a number in the range [1..20])
-
-COLS_IN_ALPHA_INDEX    = 5
-
 # In case all classes in a project start with a common prefix, all
 # classes will be put under the same header in the alphabetical index.
 # The IGNORE_PREFIX tag can be used to specify one or more prefixes that
@@ -1220,14 +1205,14 @@ FORMULA_TRANSPARENT    = YES
 # output. When enabled you may also need to install MathJax separately and
 # configure the path to it using the MATHJAX_RELPATH option.
 
-USE_MATHJAX            = NO
+USE_MATHJAX            = @enable_mathjax@
 
 # When MathJax is enabled you can set the default output format to be used for
 # the MathJax output. Supported types are HTML-CSS, NativeMML (i.e. MathML) and
 # SVG. The default value is HTML-CSS, which is slower, but has the best
 # compatibility.
 
-MATHJAX_FORMAT         = HTML-CSS
+MATHJAX_FORMAT         = SVG
 
 # When MathJax is enabled you need to specify the location relative to the
 # HTML output directory using the MATHJAX_RELPATH option. The destination
@@ -1239,12 +1224,12 @@ MATHJAX_FORMAT         = HTML-CSS
 # However, it is strongly recommended to install a local
 # copy of MathJax from http://www.mathjax.org before deployment.
 
-MATHJAX_RELPATH        = http://cdn.mathjax.org/mathjax/latest
+MATHJAX_RELPATH        = @MATHJAX2_PATH@
 
 # The MATHJAX_EXTENSIONS tag can be used to specify one or MathJax extension
 # names that should be enabled during MathJax rendering.
 
-MATHJAX_EXTENSIONS     =
+MATHJAX_EXTENSIONS     = TeX/AMSmath TeX/AMSsymbols
 
 # The MATHJAX_CODEFILE tag can be used to specify a file with javascript
 # pieces of code that will be used on startup of the MathJax code.
@@ -1680,11 +1665,6 @@ EXTERNAL_GROUPS        = YES
 
 EXTERNAL_PAGES         = YES
 
-# The PERL_PATH should be the absolute path and name of the perl script
-# interpreter (i.e. the result of `which perl').
-
-PERL_PATH              = /usr/bin/perl
-
 #---------------------------------------------------------------------------
 # Configuration options related to the dot tool
 #---------------------------------------------------------------------------
@@ -1697,15 +1677,6 @@ PERL_PATH              = /usr/bin/perl
 
 CLASS_DIAGRAMS         = YES
 
-# You can define message sequence charts within doxygen comments using the \msc
-# command. Doxygen will then run the mscgen tool (see
-# http://www.mcternan.me.uk/mscgen/) to produce the chart and insert it in the
-# documentation. The MSCGEN_PATH tag allows you to specify the directory where
-# the mscgen tool resides. If left empty the tool is assumed to be found in the
-# default search path.
-
-MSCGEN_PATH            =
-
 # If set to YES, the inheritance and collaboration graphs will hide
 # inheritance and usage relations if the target is undocumented
 # or is not a class.
@@ -1834,7 +1805,7 @@ DIRECTORY_GRAPH        = YES
 # HTML_FILE_EXTENSION to xhtml in order to make the SVG files
 # visible in IE 9+ (other browsers do not have this requirement).
 
-DOT_IMAGE_FORMAT       = png
+DOT_IMAGE_FORMAT       = svg
 
 # If DOT_IMAGE_FORMAT is set to svg, then this option can be set to YES to
 # enable generation of interactive SVG images that allow zooming and panning.
diff --git a/docs/doxygen/Doxyfile.swig_doc.in b/docs/doxygen/Doxyfile.swig_doc.in
deleted file mode 100644
index cbe06d6..0000000
--- a/docs/doxygen/Doxyfile.swig_doc.in
+++ /dev/null
@@ -1,1878 +0,0 @@
-# Doxyfile 1.8.4
-
-# This file describes the settings to be used by the documentation system
-# doxygen (www.doxygen.org) for a project.
-#
-# All text after a double hash (##) is considered a comment and is placed
-# in front of the TAG it is preceding .
-# All text after a hash (#) is considered a comment and will be ignored.
-# The format is:
-#       TAG = value [value, ...]
-# For lists items can also be appended using:
-#       TAG += value [value, ...]
-# Values that contain spaces should be placed between quotes (" ").
-
-#---------------------------------------------------------------------------
-# Project related configuration options
-#---------------------------------------------------------------------------
-
-# This tag specifies the encoding used for all characters in the config file
-# that follow. The default is UTF-8 which is also the encoding used for all
-# text before the first occurrence of this tag. Doxygen uses libiconv (or the
-# iconv built into libc) for the transcoding. See
-# http://www.gnu.org/software/libiconv for the list of possible encodings.
-
-DOXYFILE_ENCODING      = UTF-8
-
-# The PROJECT_NAME tag is a single word (or sequence of words) that should
-# identify the project. Note that if you do not use Doxywizard you need
-# to put quotes around the project name if it contains spaces.
-
-PROJECT_NAME           = @CPACK_PACKAGE_NAME@
-
-# The PROJECT_NUMBER tag can be used to enter a project or revision number.
-# This could be handy for archiving the generated documentation or
-# if some version control system is used.
-
-PROJECT_NUMBER         = @CPACK_PACKAGE_VERSION@
-
-# Using the PROJECT_BRIEF tag one can provide an optional one line description
-# for a project that appears at the top of each page and should give viewer
-# a quick idea about the purpose of the project. Keep the description short.
-
-PROJECT_BRIEF          =
-
-# With the PROJECT_LOGO tag one can specify an logo or icon that is
-# included in the documentation. The maximum height of the logo should not
-# exceed 55 pixels and the maximum width should not exceed 200 pixels.
-# Doxygen will copy the logo to the output directory.
-
-PROJECT_LOGO           =
-
-# The OUTPUT_DIRECTORY tag is used to specify the (relative or absolute)
-# base path where the generated documentation will be put.
-# If a relative path is entered, it will be relative to the location
-# where doxygen was started. If left blank the current directory will be used.
-
-OUTPUT_DIRECTORY       = "@OUTPUT_DIRECTORY@"
-
-# If the CREATE_SUBDIRS tag is set to YES, then doxygen will create
-# 4096 sub-directories (in 2 levels) under the output directory of each output
-# format and will distribute the generated files over these directories.
-# Enabling this option can be useful when feeding doxygen a huge amount of
-# source files, where putting all generated files in the same directory would
-# otherwise cause performance problems for the file system.
-
-CREATE_SUBDIRS         = NO
-
-# The OUTPUT_LANGUAGE tag is used to specify the language in which all
-# documentation generated by doxygen is written. Doxygen will use this
-# information to generate all constant output in the proper language.
-# The default language is English, other supported languages are:
-# Afrikaans, Arabic, Brazilian, Catalan, Chinese, Chinese-Traditional,
-# Croatian, Czech, Danish, Dutch, Esperanto, Farsi, Finnish, French, German,
-# Greek, Hungarian, Italian, Japanese, Japanese-en (Japanese with English
-# messages), Korean, Korean-en, Latvian, Lithuanian, Norwegian, Macedonian,
-# Persian, Polish, Portuguese, Romanian, Russian, Serbian, Serbian-Cyrillic,
-# Slovak, Slovene, Spanish, Swedish, Ukrainian, and Vietnamese.
-
-OUTPUT_LANGUAGE        = English
-
-# If the BRIEF_MEMBER_DESC tag is set to YES (the default) Doxygen will
-# include brief member descriptions after the members that are listed in
-# the file and class documentation (similar to JavaDoc).
-# Set to NO to disable this.
-
-BRIEF_MEMBER_DESC      = YES
-
-# If the REPEAT_BRIEF tag is set to YES (the default) Doxygen will prepend
-# the brief description of a member or function before the detailed description.
-# Note: if both HIDE_UNDOC_MEMBERS and BRIEF_MEMBER_DESC are set to NO, the
-# brief descriptions will be completely suppressed.
-
-REPEAT_BRIEF           = YES
-
-# This tag implements a quasi-intelligent brief description abbreviator
-# that is used to form the text in various listings. Each string
-# in this list, if found as the leading text of the brief description, will be
-# stripped from the text and the result after processing the whole list, is
-# used as the annotated text. Otherwise, the brief description is used as-is.
-# If left blank, the following values are used ("$name" is automatically
-# replaced with the name of the entity): "The $name class" "The $name widget"
-# "The $name file" "is" "provides" "specifies" "contains"
-# "represents" "a" "an" "the"
-
-ABBREVIATE_BRIEF       =
-
-# If the ALWAYS_DETAILED_SEC and REPEAT_BRIEF tags are both set to YES then
-# Doxygen will generate a detailed section even if there is only a brief
-# description.
-
-ALWAYS_DETAILED_SEC    = NO
-
-# If the INLINE_INHERITED_MEMB tag is set to YES, doxygen will show all
-# inherited members of a class in the documentation of that class as if those
-# members were ordinary class members. Constructors, destructors and assignment
-# operators of the base classes will not be shown.
-
-INLINE_INHERITED_MEMB  = NO
-
-# If the FULL_PATH_NAMES tag is set to YES then Doxygen will prepend the full
-# path before files name in the file list and in the header files. If set
-# to NO the shortest path that makes the file name unique will be used.
-
-FULL_PATH_NAMES        = NO
-
-# If the FULL_PATH_NAMES tag is set to YES then the STRIP_FROM_PATH tag
-# can be used to strip a user-defined part of the path. Stripping is
-# only done if one of the specified strings matches the left-hand part of
-# the path. The tag can be used to show relative paths in the file list.
-# If left blank the directory from which doxygen is run is used as the
-# path to strip. Note that you specify absolute paths here, but also
-# relative paths, which will be relative from the directory where doxygen is
-# started.
-
-STRIP_FROM_PATH        =
-
-# The STRIP_FROM_INC_PATH tag can be used to strip a user-defined part of
-# the path mentioned in the documentation of a class, which tells
-# the reader which header file to include in order to use a class.
-# If left blank only the name of the header file containing the class
-# definition is used. Otherwise one should specify the include paths that
-# are normally passed to the compiler using the -I flag.
-
-STRIP_FROM_INC_PATH    =
-
-# If the SHORT_NAMES tag is set to YES, doxygen will generate much shorter
-# (but less readable) file names. This can be useful if your file system
-# doesn't support long names like on DOS, Mac, or CD-ROM.
-
-SHORT_NAMES            = NO
-
-# If the JAVADOC_AUTOBRIEF tag is set to YES then Doxygen
-# will interpret the first line (until the first dot) of a JavaDoc-style
-# comment as the brief description. If set to NO, the JavaDoc
-# comments will behave just like regular Qt-style comments
-# (thus requiring an explicit @brief command for a brief description.)
-
-JAVADOC_AUTOBRIEF      = NO
-
-# If the QT_AUTOBRIEF tag is set to YES then Doxygen will
-# interpret the first line (until the first dot) of a Qt-style
-# comment as the brief description. If set to NO, the comments
-# will behave just like regular Qt-style comments (thus requiring
-# an explicit \brief command for a brief description.)
-
-QT_AUTOBRIEF           = NO
-
-# The MULTILINE_CPP_IS_BRIEF tag can be set to YES to make Doxygen
-# treat a multi-line C++ special comment block (i.e. a block of //! or ///
-# comments) as a brief description. This used to be the default behaviour.
-# The new default is to treat a multi-line C++ comment block as a detailed
-# description. Set this tag to YES if you prefer the old behaviour instead.
-
-MULTILINE_CPP_IS_BRIEF = NO
-
-# If the INHERIT_DOCS tag is set to YES (the default) then an undocumented
-# member inherits the documentation from any documented member that it
-# re-implements.
-
-INHERIT_DOCS           = YES
-
-# If the SEPARATE_MEMBER_PAGES tag is set to YES, then doxygen will produce
-# a new page for each member. If set to NO, the documentation of a member will
-# be part of the file/class/namespace that contains it.
-
-SEPARATE_MEMBER_PAGES  = NO
-
-# The TAB_SIZE tag can be used to set the number of spaces in a tab.
-# Doxygen uses this value to replace tabs by spaces in code fragments.
-
-TAB_SIZE               = 8
-
-# This tag can be used to specify a number of aliases that acts
-# as commands in the documentation. An alias has the form "name=value".
-# For example adding "sideeffect=\par Side Effects:\n" will allow you to
-# put the command \sideeffect (or @sideeffect) in the documentation, which
-# will result in a user-defined paragraph with heading "Side Effects:".
-# You can put \n's in the value part of an alias to insert newlines.
-
-ALIASES                =
-
-# This tag can be used to specify a number of word-keyword mappings (TCL only).
-# A mapping has the form "name=value". For example adding
-# "class=itcl::class" will allow you to use the command class in the
-# itcl::class meaning.
-
-TCL_SUBST              =
-
-# Set the OPTIMIZE_OUTPUT_FOR_C tag to YES if your project consists of C
-# sources only. Doxygen will then generate output that is more tailored for C.
-# For instance, some of the names that are used will be different. The list
-# of all members will be omitted, etc.
-
-OPTIMIZE_OUTPUT_FOR_C  = NO
-
-# Set the OPTIMIZE_OUTPUT_JAVA tag to YES if your project consists of Java
-# sources only. Doxygen will then generate output that is more tailored for
-# Java. For instance, namespaces will be presented as packages, qualified
-# scopes will look different, etc.
-
-OPTIMIZE_OUTPUT_JAVA   = NO
-
-# Set the OPTIMIZE_FOR_FORTRAN tag to YES if your project consists of Fortran
-# sources only. Doxygen will then generate output that is more tailored for
-# Fortran.
-
-OPTIMIZE_FOR_FORTRAN   = NO
-
-# Set the OPTIMIZE_OUTPUT_VHDL tag to YES if your project consists of VHDL
-# sources. Doxygen will then generate output that is tailored for
-# VHDL.
-
-OPTIMIZE_OUTPUT_VHDL   = NO
-
-# Doxygen selects the parser to use depending on the extension of the files it
-# parses. With this tag you can assign which parser to use for a given
-# extension. Doxygen has a built-in mapping, but you can override or extend it
-# using this tag. The format is ext=language, where ext is a file extension,
-# and language is one of the parsers supported by doxygen: IDL, Java,
-# Javascript, CSharp, C, C++, D, PHP, Objective-C, Python, Fortran, VHDL, C,
-# C++. For instance to make doxygen treat .inc files as Fortran files (default
-# is PHP), and .f files as C (default is Fortran), use: inc=Fortran f=C. Note
-# that for custom extensions you also need to set FILE_PATTERNS otherwise the
-# files are not read by doxygen.
-
-EXTENSION_MAPPING      =
-
-# If MARKDOWN_SUPPORT is enabled (the default) then doxygen pre-processes all
-# comments according to the Markdown format, which allows for more readable
-# documentation. See http://daringfireball.net/projects/markdown/ for details.
-# The output of markdown processing is further processed by doxygen, so you
-# can mix doxygen, HTML, and XML commands with Markdown formatting.
-# Disable only in case of backward compatibilities issues.
-
-MARKDOWN_SUPPORT       = YES
-
-# When enabled doxygen tries to link words that correspond to documented
-# classes, or namespaces to their corresponding documentation. Such a link can
-# be prevented in individual cases by by putting a % sign in front of the word
-# or globally by setting AUTOLINK_SUPPORT to NO.
-
-AUTOLINK_SUPPORT       = YES
-
-# If you use STL classes (i.e. std::string, std::vector, etc.) but do not want
-# to include (a tag file for) the STL sources as input, then you should
-# set this tag to YES in order to let doxygen match functions declarations and
-# definitions whose arguments contain STL classes (e.g. func(std::string); v.s.
-# func(std::string) {}). This also makes the inheritance and collaboration
-# diagrams that involve STL classes more complete and accurate.
-
-BUILTIN_STL_SUPPORT    = YES
-
-# If you use Microsoft's C++/CLI language, you should set this option to YES to
-# enable parsing support.
-
-CPP_CLI_SUPPORT        = NO
-
-# Set the SIP_SUPPORT tag to YES if your project consists of sip sources only.
-# Doxygen will parse them like normal C++ but will assume all classes use public
-# instead of private inheritance when no explicit protection keyword is present.
-
-SIP_SUPPORT            = NO
-
-# For Microsoft's IDL there are propget and propput attributes to indicate
-# getter and setter methods for a property. Setting this option to YES (the
-# default) will make doxygen replace the get and set methods by a property in
-# the documentation. This will only work if the methods are indeed getting or
-# setting a simple type. If this is not the case, or you want to show the
-# methods anyway, you should set this option to NO.
-
-IDL_PROPERTY_SUPPORT   = YES
-
-# If member grouping is used in the documentation and the DISTRIBUTE_GROUP_DOC
-# tag is set to YES, then doxygen will reuse the documentation of the first
-# member in the group (if any) for the other members of the group. By default
-# all members of a group must be documented explicitly.
-
-DISTRIBUTE_GROUP_DOC   = NO
-
-# Set the SUBGROUPING tag to YES (the default) to allow class member groups of
-# the same type (for instance a group of public functions) to be put as a
-# subgroup of that type (e.g. under the Public Functions section). Set it to
-# NO to prevent subgrouping. Alternatively, this can be done per class using
-# the \nosubgrouping command.
-
-SUBGROUPING            = YES
-
-# When the INLINE_GROUPED_CLASSES tag is set to YES, classes, structs and
-# unions are shown inside the group in which they are included (e.g. using
-# @ingroup) instead of on a separate page (for HTML and Man pages) or
-# section (for LaTeX and RTF).
-
-INLINE_GROUPED_CLASSES = NO
-
-# When the INLINE_SIMPLE_STRUCTS tag is set to YES, structs, classes, and
-# unions with only public data fields or simple typedef fields will be shown
-# inline in the documentation of the scope in which they are defined (i.e. file,
-# namespace, or group documentation), provided this scope is documented. If set
-# to NO (the default), structs, classes, and unions are shown on a separate
-# page (for HTML and Man pages) or section (for LaTeX and RTF).
-
-INLINE_SIMPLE_STRUCTS  = NO
-
-# When TYPEDEF_HIDES_STRUCT is enabled, a typedef of a struct, union, or enum
-# is documented as struct, union, or enum with the name of the typedef. So
-# typedef struct TypeS {} TypeT, will appear in the documentation as a struct
-# with name TypeT. When disabled the typedef will appear as a member of a file,
-# namespace, or class. And the struct will be named TypeS. This can typically
-# be useful for C code in case the coding convention dictates that all compound
-# types are typedef'ed and only the typedef is referenced, never the tag name.
-
-TYPEDEF_HIDES_STRUCT   = NO
-
-# The size of the symbol lookup cache can be set using LOOKUP_CACHE_SIZE. This
-# cache is used to resolve symbols given their name and scope. Since this can
-# be an expensive process and often the same symbol appear multiple times in
-# the code, doxygen keeps a cache of pre-resolved symbols. If the cache is too
-# small doxygen will become slower. If the cache is too large, memory is wasted.
-# The cache size is given by this formula: 2^(16+LOOKUP_CACHE_SIZE). The valid
-# range is 0..9, the default is 0, corresponding to a cache size of 2^16 = 65536
-# symbols.
-
-LOOKUP_CACHE_SIZE      = 0
-
-#---------------------------------------------------------------------------
-# Build related configuration options
-#---------------------------------------------------------------------------
-
-# If the EXTRACT_ALL tag is set to YES doxygen will assume all entities in
-# documentation are documented, even if no documentation was available.
-# Private class members and static file members will be hidden unless
-# the EXTRACT_PRIVATE respectively EXTRACT_STATIC tags are set to YES
-
-EXTRACT_ALL            = YES
-
-# If the EXTRACT_PRIVATE tag is set to YES all private members of a class
-# will be included in the documentation.
-
-EXTRACT_PRIVATE        = NO
-
-# If the EXTRACT_PACKAGE tag is set to YES all members with package or internal
-# scope will be included in the documentation.
-
-EXTRACT_PACKAGE        = NO
-
-# If the EXTRACT_STATIC tag is set to YES all static members of a file
-# will be included in the documentation.
-
-EXTRACT_STATIC         = NO
-
-# If the EXTRACT_LOCAL_CLASSES tag is set to YES classes (and structs)
-# defined locally in source files will be included in the documentation.
-# If set to NO only classes defined in header files are included.
-
-EXTRACT_LOCAL_CLASSES  = YES
-
-# This flag is only useful for Objective-C code. When set to YES local
-# methods, which are defined in the implementation section but not in
-# the interface are included in the documentation.
-# If set to NO (the default) only methods in the interface are included.
-
-EXTRACT_LOCAL_METHODS  = NO
-
-# If this flag is set to YES, the members of anonymous namespaces will be
-# extracted and appear in the documentation as a namespace called
-# 'anonymous_namespace{file}', where file will be replaced with the base
-# name of the file that contains the anonymous namespace. By default
-# anonymous namespaces are hidden.
-
-EXTRACT_ANON_NSPACES   = NO
-
-# If the HIDE_UNDOC_MEMBERS tag is set to YES, Doxygen will hide all
-# undocumented members of documented classes, files or namespaces.
-# If set to NO (the default) these members will be included in the
-# various overviews, but no documentation section is generated.
-# This option has no effect if EXTRACT_ALL is enabled.
-
-HIDE_UNDOC_MEMBERS     = NO
-
-# If the HIDE_UNDOC_CLASSES tag is set to YES, Doxygen will hide all
-# undocumented classes that are normally visible in the class hierarchy.
-# If set to NO (the default) these classes will be included in the various
-# overviews. This option has no effect if EXTRACT_ALL is enabled.
-
-HIDE_UNDOC_CLASSES     = NO
-
-# If the HIDE_FRIEND_COMPOUNDS tag is set to YES, Doxygen will hide all
-# friend (class|struct|union) declarations.
-# If set to NO (the default) these declarations will be included in the
-# documentation.
-
-HIDE_FRIEND_COMPOUNDS  = NO
-
-# If the HIDE_IN_BODY_DOCS tag is set to YES, Doxygen will hide any
-# documentation blocks found inside the body of a function.
-# If set to NO (the default) these blocks will be appended to the
-# function's detailed documentation block.
-
-HIDE_IN_BODY_DOCS      = NO
-
-# The INTERNAL_DOCS tag determines if documentation
-# that is typed after a \internal command is included. If the tag is set
-# to NO (the default) then the documentation will be excluded.
-# Set it to YES to include the internal documentation.
-
-INTERNAL_DOCS          = NO
-
-# If the CASE_SENSE_NAMES tag is set to NO then Doxygen will only generate
-# file names in lower-case letters. If set to YES upper-case letters are also
-# allowed. This is useful if you have classes or files whose names only differ
-# in case and if your file system supports case sensitive file names. Windows
-# and Mac users are advised to set this option to NO.
-
-CASE_SENSE_NAMES       = YES
-
-# If the HIDE_SCOPE_NAMES tag is set to NO (the default) then Doxygen
-# will show members with their full class and namespace scopes in the
-# documentation. If set to YES the scope will be hidden.
-
-HIDE_SCOPE_NAMES       = NO
-
-# If the SHOW_INCLUDE_FILES tag is set to YES (the default) then Doxygen
-# will put a list of the files that are included by a file in the documentation
-# of that file.
-
-SHOW_INCLUDE_FILES     = YES
-
-# If the FORCE_LOCAL_INCLUDES tag is set to YES then Doxygen
-# will list include files with double quotes in the documentation
-# rather than with sharp brackets.
-
-FORCE_LOCAL_INCLUDES   = NO
-
-# If the INLINE_INFO tag is set to YES (the default) then a tag [inline]
-# is inserted in the documentation for inline members.
-
-INLINE_INFO            = YES
-
-# If the SORT_MEMBER_DOCS tag is set to YES (the default) then doxygen
-# will sort the (detailed) documentation of file and class members
-# alphabetically by member name. If set to NO the members will appear in
-# declaration order.
-
-SORT_MEMBER_DOCS       = YES
-
-# If the SORT_BRIEF_DOCS tag is set to YES then doxygen will sort the
-# brief documentation of file, namespace and class members alphabetically
-# by member name. If set to NO (the default) the members will appear in
-# declaration order.
-
-SORT_BRIEF_DOCS        = NO
-
-# If the SORT_MEMBERS_CTORS_1ST tag is set to YES then doxygen
-# will sort the (brief and detailed) documentation of class members so that
-# constructors and destructors are listed first. If set to NO (the default)
-# the constructors will appear in the respective orders defined by
-# SORT_MEMBER_DOCS and SORT_BRIEF_DOCS.
-# This tag will be ignored for brief docs if SORT_BRIEF_DOCS is set to NO
-# and ignored for detailed docs if SORT_MEMBER_DOCS is set to NO.
-
-SORT_MEMBERS_CTORS_1ST = NO
-
-# If the SORT_GROUP_NAMES tag is set to YES then doxygen will sort the
-# hierarchy of group names into alphabetical order. If set to NO (the default)
-# the group names will appear in their defined order.
-
-SORT_GROUP_NAMES       = NO
-
-# If the SORT_BY_SCOPE_NAME tag is set to YES, the class list will be
-# sorted by fully-qualified names, including namespaces. If set to
-# NO (the default), the class list will be sorted only by class name,
-# not including the namespace part.
-# Note: This option is not very useful if HIDE_SCOPE_NAMES is set to YES.
-# Note: This option applies only to the class list, not to the
-# alphabetical list.
-
-SORT_BY_SCOPE_NAME     = NO
-
-# If the STRICT_PROTO_MATCHING option is enabled and doxygen fails to
-# do proper type resolution of all parameters of a function it will reject a
-# match between the prototype and the implementation of a member function even
-# if there is only one candidate or it is obvious which candidate to choose
-# by doing a simple string match. By disabling STRICT_PROTO_MATCHING doxygen
-# will still accept a match between prototype and implementation in such cases.
-
-STRICT_PROTO_MATCHING  = NO
-
-# The GENERATE_TODOLIST tag can be used to enable (YES) or
-# disable (NO) the todo list. This list is created by putting \todo
-# commands in the documentation.
-
-GENERATE_TODOLIST      = YES
-
-# The GENERATE_TESTLIST tag can be used to enable (YES) or
-# disable (NO) the test list. This list is created by putting \test
-# commands in the documentation.
-
-GENERATE_TESTLIST      = YES
-
-# The GENERATE_BUGLIST tag can be used to enable (YES) or
-# disable (NO) the bug list. This list is created by putting \bug
-# commands in the documentation.
-
-GENERATE_BUGLIST       = YES
-
-# The GENERATE_DEPRECATEDLIST tag can be used to enable (YES) or
-# disable (NO) the deprecated list. This list is created by putting
-# \deprecated commands in the documentation.
-
-GENERATE_DEPRECATEDLIST= YES
-
-# The ENABLED_SECTIONS tag can be used to enable conditional
-# documentation sections, marked by \if section-label ... \endif
-# and \cond section-label ... \endcond blocks.
-
-ENABLED_SECTIONS       =
-
-# The MAX_INITIALIZER_LINES tag determines the maximum number of lines
-# the initial value of a variable or macro consists of for it to appear in
-# the documentation. If the initializer consists of more lines than specified
-# here it will be hidden. Use a value of 0 to hide initializers completely.
-# The appearance of the initializer of individual variables and macros in the
-# documentation can be controlled using \showinitializer or \hideinitializer
-# command in the documentation regardless of this setting.
-
-MAX_INITIALIZER_LINES  = 30
-
-# Set the SHOW_USED_FILES tag to NO to disable the list of files generated
-# at the bottom of the documentation of classes and structs. If set to YES the
-# list will mention the files that were used to generate the documentation.
-
-SHOW_USED_FILES        = YES
-
-# Set the SHOW_FILES tag to NO to disable the generation of the Files page.
-# This will remove the Files entry from the Quick Index and from the
-# Folder Tree View (if specified). The default is YES.
-
-SHOW_FILES             = YES
-
-# Set the SHOW_NAMESPACES tag to NO to disable the generation of the
-# Namespaces page.
-# This will remove the Namespaces entry from the Quick Index
-# and from the Folder Tree View (if specified). The default is YES.
-
-SHOW_NAMESPACES        = YES
-
-# The FILE_VERSION_FILTER tag can be used to specify a program or script that
-# doxygen should invoke to get the current version for each file (typically from
-# the version control system). Doxygen will invoke the program by executing (via
-# popen()) the command <command> <input-file>, where <command> is the value of
-# the FILE_VERSION_FILTER tag, and <input-file> is the name of an input file
-# provided by doxygen. Whatever the program writes to standard output
-# is used as the file version. See the manual for examples.
-
-FILE_VERSION_FILTER    =
-
-# The LAYOUT_FILE tag can be used to specify a layout file which will be parsed
-# by doxygen. The layout file controls the global structure of the generated
-# output files in an output format independent way. To create the layout file
-# that represents doxygen's defaults, run doxygen with the -l option.
-# You can optionally specify a file name after the option, if omitted
-# DoxygenLayout.xml will be used as the name of the layout file.
-
-LAYOUT_FILE            =
-
-# The CITE_BIB_FILES tag can be used to specify one or more bib files
-# containing the references data. This must be a list of .bib files. The
-# .bib extension is automatically appended if omitted. Using this command
-# requires the bibtex tool to be installed. See also
-# http://en.wikipedia.org/wiki/BibTeX for more info. For LaTeX the style
-# of the bibliography can be controlled using LATEX_BIB_STYLE. To use this
-# feature you need bibtex and perl available in the search path. Do not use
-# file names with spaces, bibtex cannot handle them.
-
-CITE_BIB_FILES         =
-
-#---------------------------------------------------------------------------
-# configuration options related to warning and progress messages
-#---------------------------------------------------------------------------
-
-# The QUIET tag can be used to turn on/off the messages that are generated
-# by doxygen. Possible values are YES and NO. If left blank NO is used.
-
-QUIET                  = YES
-
-# The WARNINGS tag can be used to turn on/off the warning messages that are
-# generated by doxygen. Possible values are YES and NO. If left blank
-# NO is used.
-
-WARNINGS               = YES
-
-# If WARN_IF_UNDOCUMENTED is set to YES, then doxygen will generate warnings
-# for undocumented members. If EXTRACT_ALL is set to YES then this flag will
-# automatically be disabled.
-
-WARN_IF_UNDOCUMENTED   = YES
-
-# If WARN_IF_DOC_ERROR is set to YES, doxygen will generate warnings for
-# potential errors in the documentation, such as not documenting some
-# parameters in a documented function, or documenting parameters that
-# don't exist or using markup commands wrongly.
-
-WARN_IF_DOC_ERROR      = YES
-
-# The WARN_NO_PARAMDOC option can be enabled to get warnings for
-# functions that are documented, but have no documentation for their parameters
-# or return value. If set to NO (the default) doxygen will only warn about
-# wrong or incomplete parameter documentation, but not about the absence of
-# documentation.
-
-WARN_NO_PARAMDOC       = NO
-
-# The WARN_FORMAT tag determines the format of the warning messages that
-# doxygen can produce. The string should contain the $file, $line, and $text
-# tags, which will be replaced by the file and line number from which the
-# warning originated and the warning text. Optionally the format may contain
-# $version, which will be replaced by the version of the file (if it could
-# be obtained via FILE_VERSION_FILTER)
-
-WARN_FORMAT            = "$file:$line: $text"
-
-# The WARN_LOGFILE tag can be used to specify a file to which warning
-# and error messages should be written. If left blank the output is written
-# to stderr.
-
-WARN_LOGFILE           =
-
-#---------------------------------------------------------------------------
-# configuration options related to the input files
-#---------------------------------------------------------------------------
-
-# The INPUT tag can be used to specify the files and/or directories that contain
-# documented source files. You may enter file names like "myfile.cpp" or
-# directories like "/usr/src/myproject". Separate the files or directories
-# with spaces.
-
-INPUT                  = @INPUT_PATHS@
-
-# This tag can be used to specify the character encoding of the source files
-# that doxygen parses. Internally doxygen uses the UTF-8 encoding, which is
-# also the default input encoding. Doxygen uses libiconv (or the iconv built
-# into libc) for the transcoding. See http://www.gnu.org/software/libiconv for
-# the list of possible encodings.
-
-INPUT_ENCODING         = UTF-8
-
-# If the value of the INPUT tag contains directories, you can use the
-# FILE_PATTERNS tag to specify one or more wildcard pattern (like *.cpp
-# and *.h) to filter out the source-files in the directories. If left
-# blank the following patterns are tested:
-# *.c *.cc *.cxx *.cpp *.c++ *.d *.java *.ii *.ixx *.ipp *.i++ *.inl *.h *.hh
-# *.hxx *.hpp *.h++ *.idl *.odl *.cs *.php *.php3 *.inc *.m *.mm *.dox *.py
-# *.f90 *.f *.for *.vhd *.vhdl
-
-FILE_PATTERNS          = *.h
-
-# The RECURSIVE tag can be used to turn specify whether or not subdirectories
-# should be searched for input files as well. Possible values are YES and NO.
-# If left blank NO is used.
-
-RECURSIVE              = YES
-
-# The EXCLUDE tag can be used to specify files and/or directories that should be
-# excluded from the INPUT source files. This way you can easily exclude a
-# subdirectory from a directory tree whose root is specified with the INPUT tag.
-# Note that relative paths are relative to the directory from which doxygen is
-# run.
-
-EXCLUDE                =
-
-# The EXCLUDE_SYMLINKS tag can be used to select whether or not files or
-# directories that are symbolic links (a Unix file system feature) are excluded
-# from the input.
-
-EXCLUDE_SYMLINKS       = NO
-
-# If the value of the INPUT tag contains directories, you can use the
-# EXCLUDE_PATTERNS tag to specify one or more wildcard patterns to exclude
-# certain files from those directories. Note that the wildcards are matched
-# against the file with absolute path, so to exclude all test directories
-# for example use the pattern */test/*
-
-EXCLUDE_PATTERNS       =
-
-# The EXCLUDE_SYMBOLS tag can be used to specify one or more symbol names
-# (namespaces, classes, functions, etc.) that should be excluded from the
-# output. The symbol name can be a fully qualified name, a word, or if the
-# wildcard * is used, a substring. Examples: ANamespace, AClass,
-# AClass::ANamespace, ANamespace::*Test
-
-EXCLUDE_SYMBOLS        =
-
-# The EXAMPLE_PATH tag can be used to specify one or more files or
-# directories that contain example code fragments that are included (see
-# the \include command).
-
-EXAMPLE_PATH           =
-
-# If the value of the EXAMPLE_PATH tag contains directories, you can use the
-# EXAMPLE_PATTERNS tag to specify one or more wildcard pattern (like *.cpp
-# and *.h) to filter out the source-files in the directories. If left
-# blank all files are included.
-
-EXAMPLE_PATTERNS       =
-
-# If the EXAMPLE_RECURSIVE tag is set to YES then subdirectories will be
-# searched for input files to be used with the \include or \dontinclude
-# commands irrespective of the value of the RECURSIVE tag.
-# Possible values are YES and NO. If left blank NO is used.
-
-EXAMPLE_RECURSIVE      = NO
-
-# The IMAGE_PATH tag can be used to specify one or more files or
-# directories that contain image that are included in the documentation (see
-# the \image command).
-
-IMAGE_PATH             =
-
-# The INPUT_FILTER tag can be used to specify a program that doxygen should
-# invoke to filter for each input file. Doxygen will invoke the filter program
-# by executing (via popen()) the command <filter> <input-file>, where <filter>
-# is the value of the INPUT_FILTER tag, and <input-file> is the name of an
-# input file. Doxygen will then use the output that the filter program writes
-# to standard output.
-# If FILTER_PATTERNS is specified, this tag will be ignored.
-# Note that the filter must not add or remove lines; it is applied before the
-# code is scanned, but not when the output code is generated. If lines are added
-# or removed, the anchors will not be placed correctly.
-
-INPUT_FILTER           =
-
-# The FILTER_PATTERNS tag can be used to specify filters on a per file pattern
-# basis.
-# Doxygen will compare the file name with each pattern and apply the
-# filter if there is a match.
-# The filters are a list of the form:
-# pattern=filter (like *.cpp=my_cpp_filter). See INPUT_FILTER for further
-# info on how filters are used. If FILTER_PATTERNS is empty or if
-# non of the patterns match the file name, INPUT_FILTER is applied.
-
-FILTER_PATTERNS        =
-
-# If the FILTER_SOURCE_FILES tag is set to YES, the input filter (if set using
-# INPUT_FILTER) will be used to filter the input files when producing source
-# files to browse (i.e. when SOURCE_BROWSER is set to YES).
-
-FILTER_SOURCE_FILES    = NO
-
-# The FILTER_SOURCE_PATTERNS tag can be used to specify source filters per file
-# pattern. A pattern will override the setting for FILTER_PATTERN (if any)
-# and it is also possible to disable source filtering for a specific pattern
-# using *.ext= (so without naming a filter). This option only has effect when
-# FILTER_SOURCE_FILES is enabled.
-
-FILTER_SOURCE_PATTERNS =
-
-# If the USE_MD_FILE_AS_MAINPAGE tag refers to the name of a markdown file that
-# is part of the input, its contents will be placed on the main page
-# (index.html). This can be useful if you have a project on for instance GitHub
-# and want reuse the introduction page also for the doxygen output.
-
-USE_MDFILE_AS_MAINPAGE =
-
-#---------------------------------------------------------------------------
-# configuration options related to source browsing
-#---------------------------------------------------------------------------
-
-# If the SOURCE_BROWSER tag is set to YES then a list of source files will
-# be generated. Documented entities will be cross-referenced with these sources.
-# Note: To get rid of all source code in the generated output, make sure also
-# VERBATIM_HEADERS is set to NO.
-
-SOURCE_BROWSER         = NO
-
-# Setting the INLINE_SOURCES tag to YES will include the body
-# of functions and classes directly in the documentation.
-
-INLINE_SOURCES         = NO
-
-# Setting the STRIP_CODE_COMMENTS tag to YES (the default) will instruct
-# doxygen to hide any special comment blocks from generated source code
-# fragments. Normal C, C++ and Fortran comments will always remain visible.
-
-STRIP_CODE_COMMENTS    = YES
-
-# If the REFERENCED_BY_RELATION tag is set to YES
-# then for each documented function all documented
-# functions referencing it will be listed.
-
-REFERENCED_BY_RELATION = NO
-
-# If the REFERENCES_RELATION tag is set to YES
-# then for each documented function all documented entities
-# called/used by that function will be listed.
-
-REFERENCES_RELATION    = NO
-
-# If the REFERENCES_LINK_SOURCE tag is set to YES (the default)
-# and SOURCE_BROWSER tag is set to YES, then the hyperlinks from
-# functions in REFERENCES_RELATION and REFERENCED_BY_RELATION lists will
-# link to the source code.
-# Otherwise they will link to the documentation.
-
-REFERENCES_LINK_SOURCE = YES
-
-# If the USE_HTAGS tag is set to YES then the references to source code
-# will point to the HTML generated by the htags(1) tool instead of doxygen
-# built-in source browser. The htags tool is part of GNU's global source
-# tagging system (see http://www.gnu.org/software/global/global.html). You
-# will need version 4.8.6 or higher.
-
-USE_HTAGS              = NO
-
-# If the VERBATIM_HEADERS tag is set to YES (the default) then Doxygen
-# will generate a verbatim copy of the header file for each class for
-# which an include is specified. Set to NO to disable this.
-
-VERBATIM_HEADERS       = YES
-
-#---------------------------------------------------------------------------
-# configuration options related to the alphabetical class index
-#---------------------------------------------------------------------------
-
-# If the ALPHABETICAL_INDEX tag is set to YES, an alphabetical index
-# of all compounds will be generated. Enable this if the project
-# contains a lot of classes, structs, unions or interfaces.
-
-ALPHABETICAL_INDEX     = NO
-
-# If the alphabetical index is enabled (see ALPHABETICAL_INDEX) then
-# the COLS_IN_ALPHA_INDEX tag can be used to specify the number of columns
-# in which this list will be split (can be a number in the range [1..20])
-
-COLS_IN_ALPHA_INDEX    = 5
-
-# In case all classes in a project start with a common prefix, all
-# classes will be put under the same header in the alphabetical index.
-# The IGNORE_PREFIX tag can be used to specify one or more prefixes that
-# should be ignored while generating the index headers.
-
-IGNORE_PREFIX          =
-
-#---------------------------------------------------------------------------
-# configuration options related to the HTML output
-#---------------------------------------------------------------------------
-
-# If the GENERATE_HTML tag is set to YES (the default) Doxygen will
-# generate HTML output.
-
-GENERATE_HTML          = NO
-
-# The HTML_OUTPUT tag is used to specify where the HTML docs will be put.
-# If a relative path is entered the value of OUTPUT_DIRECTORY will be
-# put in front of it. If left blank `html' will be used as the default path.
-
-HTML_OUTPUT            = html
-
-# The HTML_FILE_EXTENSION tag can be used to specify the file extension for
-# each generated HTML page (for example: .htm,.php,.asp). If it is left blank
-# doxygen will generate files with .html extension.
-
-HTML_FILE_EXTENSION    = .html
-
-# The HTML_HEADER tag can be used to specify a personal HTML header for
-# each generated HTML page. If it is left blank doxygen will generate a
-# standard header. Note that when using a custom header you are responsible
-#  for the proper inclusion of any scripts and style sheets that doxygen
-# needs, which is dependent on the configuration options used.
-# It is advised to generate a default header using "doxygen -w html
-# header.html footer.html stylesheet.css YourConfigFile" and then modify
-# that header. Note that the header is subject to change so you typically
-# have to redo this when upgrading to a newer version of doxygen or when
-# changing the value of configuration settings such as GENERATE_TREEVIEW!
-
-HTML_HEADER            =
-
-# The HTML_FOOTER tag can be used to specify a personal HTML footer for
-# each generated HTML page. If it is left blank doxygen will generate a
-# standard footer.
-
-HTML_FOOTER            =
-
-# The HTML_STYLESHEET tag can be used to specify a user-defined cascading
-# style sheet that is used by each HTML page. It can be used to
-# fine-tune the look of the HTML output. If left blank doxygen will
-# generate a default style sheet. Note that it is recommended to use
-# HTML_EXTRA_STYLESHEET instead of this one, as it is more robust and this
-# tag will in the future become obsolete.
-
-HTML_STYLESHEET        =
-
-# The HTML_EXTRA_STYLESHEET tag can be used to specify an additional
-# user-defined cascading style sheet that is included after the standard
-# style sheets created by doxygen. Using this option one can overrule
-# certain style aspects. This is preferred over using HTML_STYLESHEET
-# since it does not replace the standard style sheet and is therefore more
-# robust against future updates. Doxygen will copy the style sheet file to
-# the output directory.
-
-HTML_EXTRA_STYLESHEET  =
-
-# The HTML_EXTRA_FILES tag can be used to specify one or more extra images or
-# other source files which should be copied to the HTML output directory. Note
-# that these files will be copied to the base HTML output directory. Use the
-# $relpath^ marker in the HTML_HEADER and/or HTML_FOOTER files to load these
-# files. In the HTML_STYLESHEET file, use the file name only. Also note that
-# the files will be copied as-is; there are no commands or markers available.
-
-HTML_EXTRA_FILES       =
-
-# The HTML_COLORSTYLE_HUE tag controls the color of the HTML output.
-# Doxygen will adjust the colors in the style sheet and background images
-# according to this color. Hue is specified as an angle on a colorwheel,
-# see http://en.wikipedia.org/wiki/Hue for more information.
-# For instance the value 0 represents red, 60 is yellow, 120 is green,
-# 180 is cyan, 240 is blue, 300 purple, and 360 is red again.
-# The allowed range is 0 to 359.
-
-HTML_COLORSTYLE_HUE    = 220
-
-# The HTML_COLORSTYLE_SAT tag controls the purity (or saturation) of
-# the colors in the HTML output. For a value of 0 the output will use
-# grayscales only. A value of 255 will produce the most vivid colors.
-
-HTML_COLORSTYLE_SAT    = 100
-
-# The HTML_COLORSTYLE_GAMMA tag controls the gamma correction applied to
-# the luminance component of the colors in the HTML output. Values below
-# 100 gradually make the output lighter, whereas values above 100 make
-# the output darker. The value divided by 100 is the actual gamma applied,
-# so 80 represents a gamma of 0.8, The value 220 represents a gamma of 2.2,
-# and 100 does not change the gamma.
-
-HTML_COLORSTYLE_GAMMA  = 80
-
-# If the HTML_TIMESTAMP tag is set to YES then the footer of each generated HTML
-# page will contain the date and time when the page was generated. Setting
-# this to NO can help when comparing the output of multiple runs.
-
-HTML_TIMESTAMP         = NO
-
-# If the HTML_DYNAMIC_SECTIONS tag is set to YES then the generated HTML
-# documentation will contain sections that can be hidden and shown after the
-# page has loaded.
-
-HTML_DYNAMIC_SECTIONS  = NO
-
-# With HTML_INDEX_NUM_ENTRIES one can control the preferred number of
-# entries shown in the various tree structured indices initially; the user
-# can expand and collapse entries dynamically later on. Doxygen will expand
-# the tree to such a level that at most the specified number of entries are
-# visible (unless a fully collapsed tree already exceeds this amount).
-# So setting the number of entries 1 will produce a full collapsed tree by
-# default. 0 is a special value representing an infinite number of entries
-# and will result in a full expanded tree by default.
-
-HTML_INDEX_NUM_ENTRIES = 100
-
-# If the GENERATE_DOCSET tag is set to YES, additional index files
-# will be generated that can be used as input for Apple's Xcode 3
-# integrated development environment, introduced with OSX 10.5 (Leopard).
-# To create a documentation set, doxygen will generate a Makefile in the
-# HTML output directory. Running make will produce the docset in that
-# directory and running "make install" will install the docset in
-# ~/Library/Developer/Shared/Documentation/DocSets so that Xcode will find
-# it at startup.
-# See http://developer.apple.com/tools/creatingdocsetswithdoxygen.html
-# for more information.
-
-GENERATE_DOCSET        = NO
-
-# When GENERATE_DOCSET tag is set to YES, this tag determines the name of the
-# feed. A documentation feed provides an umbrella under which multiple
-# documentation sets from a single provider (such as a company or product suite)
-# can be grouped.
-
-DOCSET_FEEDNAME        = "Doxygen generated docs"
-
-# When GENERATE_DOCSET tag is set to YES, this tag specifies a string that
-# should uniquely identify the documentation set bundle. This should be a
-# reverse domain-name style string, e.g. com.mycompany.MyDocSet. Doxygen
-# will append .docset to the name.
-
-DOCSET_BUNDLE_ID       = org.doxygen.Project
-
-# When GENERATE_PUBLISHER_ID tag specifies a string that should uniquely
-# identify the documentation publisher. This should be a reverse domain-name
-# style string, e.g. com.mycompany.MyDocSet.documentation.
-
-DOCSET_PUBLISHER_ID    = org.doxygen.Publisher
-
-# The GENERATE_PUBLISHER_NAME tag identifies the documentation publisher.
-
-DOCSET_PUBLISHER_NAME  = Publisher
-
-# If the GENERATE_HTMLHELP tag is set to YES, additional index files
-# will be generated that can be used as input for tools like the
-# Microsoft HTML help workshop to generate a compiled HTML help file (.chm)
-# of the generated HTML documentation.
-
-GENERATE_HTMLHELP      = NO
-
-# If the GENERATE_HTMLHELP tag is set to YES, the CHM_FILE tag can
-# be used to specify the file name of the resulting .chm file. You
-# can add a path in front of the file if the result should not be
-# written to the html output directory.
-
-CHM_FILE               =
-
-# If the GENERATE_HTMLHELP tag is set to YES, the HHC_LOCATION tag can
-# be used to specify the location (absolute path including file name) of
-# the HTML help compiler (hhc.exe). If non-empty doxygen will try to run
-# the HTML help compiler on the generated index.hhp.
-
-HHC_LOCATION           =
-
-# If the GENERATE_HTMLHELP tag is set to YES, the GENERATE_CHI flag
-# controls if a separate .chi index file is generated (YES) or that
-# it should be included in the master .chm file (NO).
-
-GENERATE_CHI           = NO
-
-# If the GENERATE_HTMLHELP tag is set to YES, the CHM_INDEX_ENCODING
-# is used to encode HtmlHelp index (hhk), content (hhc) and project file
-# content.
-
-CHM_INDEX_ENCODING     =
-
-# If the GENERATE_HTMLHELP tag is set to YES, the BINARY_TOC flag
-# controls whether a binary table of contents is generated (YES) or a
-# normal table of contents (NO) in the .chm file.
-
-BINARY_TOC             = NO
-
-# The TOC_EXPAND flag can be set to YES to add extra items for group members
-# to the contents of the HTML help documentation and to the tree view.
-
-TOC_EXPAND             = NO
-
-# If the GENERATE_QHP tag is set to YES and both QHP_NAMESPACE and
-# QHP_VIRTUAL_FOLDER are set, an additional index file will be generated
-# that can be used as input for Qt's qhelpgenerator to generate a
-# Qt Compressed Help (.qch) of the generated HTML documentation.
-
-GENERATE_QHP           = NO
-
-# If the QHG_LOCATION tag is specified, the QCH_FILE tag can
-# be used to specify the file name of the resulting .qch file.
-# The path specified is relative to the HTML output folder.
-
-QCH_FILE               =
-
-# The QHP_NAMESPACE tag specifies the namespace to use when generating
-# Qt Help Project output. For more information please see
-# http://doc.trolltech.com/qthelpproject.html#namespace
-
-QHP_NAMESPACE          =
-
-# The QHP_VIRTUAL_FOLDER tag specifies the namespace to use when generating
-# Qt Help Project output. For more information please see
-# http://doc.trolltech.com/qthelpproject.html#virtual-folders
-
-QHP_VIRTUAL_FOLDER     = doc
-
-# If QHP_CUST_FILTER_NAME is set, it specifies the name of a custom filter to
-# add. For more information please see
-# http://doc.trolltech.com/qthelpproject.html#custom-filters
-
-QHP_CUST_FILTER_NAME   =
-
-# The QHP_CUST_FILT_ATTRS tag specifies the list of the attributes of the
-# custom filter to add. For more information please see
-# <a href="http://doc.trolltech.com/qthelpproject.html#custom-filters">
-# Qt Help Project / Custom Filters</a>.
-
-QHP_CUST_FILTER_ATTRS  =
-
-# The QHP_SECT_FILTER_ATTRS tag specifies the list of the attributes this
-# project's
-# filter section matches.
-# <a href="http://doc.trolltech.com/qthelpproject.html#filter-attributes">
-# Qt Help Project / Filter Attributes</a>.
-
-QHP_SECT_FILTER_ATTRS  =
-
-# If the GENERATE_QHP tag is set to YES, the QHG_LOCATION tag can
-# be used to specify the location of Qt's qhelpgenerator.
-# If non-empty doxygen will try to run qhelpgenerator on the generated
-# .qhp file.
-
-QHG_LOCATION           =
-
-# If the GENERATE_ECLIPSEHELP tag is set to YES, additional index files
-#  will be generated, which together with the HTML files, form an Eclipse help
-# plugin. To install this plugin and make it available under the help contents
-# menu in Eclipse, the contents of the directory containing the HTML and XML
-# files needs to be copied into the plugins directory of eclipse. The name of
-# the directory within the plugins directory should be the same as
-# the ECLIPSE_DOC_ID value. After copying Eclipse needs to be restarted before
-# the help appears.
-
-GENERATE_ECLIPSEHELP   = NO
-
-# A unique identifier for the eclipse help plugin. When installing the plugin
-# the directory name containing the HTML and XML files should also have
-# this name.
-
-ECLIPSE_DOC_ID         = org.doxygen.Project
-
-# The DISABLE_INDEX tag can be used to turn on/off the condensed index (tabs)
-# at top of each HTML page. The value NO (the default) enables the index and
-# the value YES disables it. Since the tabs have the same information as the
-# navigation tree you can set this option to NO if you already set
-# GENERATE_TREEVIEW to YES.
-
-DISABLE_INDEX          = NO
-
-# The GENERATE_TREEVIEW tag is used to specify whether a tree-like index
-# structure should be generated to display hierarchical information.
-# If the tag value is set to YES, a side panel will be generated
-# containing a tree-like index structure (just like the one that
-# is generated for HTML Help). For this to work a browser that supports
-# JavaScript, DHTML, CSS and frames is required (i.e. any modern browser).
-# Windows users are probably better off using the HTML help feature.
-# Since the tree basically has the same information as the tab index you
-# could consider to set DISABLE_INDEX to NO when enabling this option.
-
-GENERATE_TREEVIEW      = NO
-
-# The ENUM_VALUES_PER_LINE tag can be used to set the number of enum values
-# (range [0,1..20]) that doxygen will group on one line in the generated HTML
-# documentation. Note that a value of 0 will completely suppress the enum
-# values from appearing in the overview section.
-
-ENUM_VALUES_PER_LINE   = 4
-
-# If the treeview is enabled (see GENERATE_TREEVIEW) then this tag can be
-# used to set the initial width (in pixels) of the frame in which the tree
-# is shown.
-
-TREEVIEW_WIDTH         = 250
-
-# When the EXT_LINKS_IN_WINDOW option is set to YES doxygen will open
-# links to external symbols imported via tag files in a separate window.
-
-EXT_LINKS_IN_WINDOW    = NO
-
-# Use this tag to change the font size of Latex formulas included
-# as images in the HTML documentation. The default is 10. Note that
-# when you change the font size after a successful doxygen run you need
-# to manually remove any form_*.png images from the HTML output directory
-# to force them to be regenerated.
-
-FORMULA_FONTSIZE       = 10
-
-# Use the FORMULA_TRANPARENT tag to determine whether or not the images
-# generated for formulas are transparent PNGs. Transparent PNGs are
-# not supported properly for IE 6.0, but are supported on all modern browsers.
-# Note that when changing this option you need to delete any form_*.png files
-# in the HTML output before the changes have effect.
-
-FORMULA_TRANSPARENT    = YES
-
-# Enable the USE_MATHJAX option to render LaTeX formulas using MathJax
-# (see http://www.mathjax.org) which uses client side Javascript for the
-# rendering instead of using prerendered bitmaps. Use this if you do not
-# have LaTeX installed or if you want to formulas look prettier in the HTML
-# output. When enabled you may also need to install MathJax separately and
-# configure the path to it using the MATHJAX_RELPATH option.
-
-USE_MATHJAX            = NO
-
-# When MathJax is enabled you can set the default output format to be used for
-# the MathJax output. Supported types are HTML-CSS, NativeMML (i.e. MathML) and
-# SVG. The default value is HTML-CSS, which is slower, but has the best
-# compatibility.
-
-MATHJAX_FORMAT         = HTML-CSS
-
-# When MathJax is enabled you need to specify the location relative to the
-# HTML output directory using the MATHJAX_RELPATH option. The destination
-# directory should contain the MathJax.js script. For instance, if the mathjax
-# directory is located at the same level as the HTML output directory, then
-# MATHJAX_RELPATH should be ../mathjax. The default value points to
-# the MathJax Content Delivery Network so you can quickly see the result without
-# installing MathJax.
-# However, it is strongly recommended to install a local
-# copy of MathJax from http://www.mathjax.org before deployment.
-
-MATHJAX_RELPATH        = http://cdn.mathjax.org/mathjax/latest
-
-# The MATHJAX_EXTENSIONS tag can be used to specify one or MathJax extension
-# names that should be enabled during MathJax rendering.
-
-MATHJAX_EXTENSIONS     =
-
-# The MATHJAX_CODEFILE tag can be used to specify a file with javascript
-# pieces of code that will be used on startup of the MathJax code.
-
-MATHJAX_CODEFILE       =
-
-# When the SEARCHENGINE tag is enabled doxygen will generate a search box
-# for the HTML output. The underlying search engine uses javascript
-# and DHTML and should work on any modern browser. Note that when using
-# HTML help (GENERATE_HTMLHELP), Qt help (GENERATE_QHP), or docsets
-# (GENERATE_DOCSET) there is already a search function so this one should
-# typically be disabled. For large projects the javascript based search engine
-# can be slow, then enabling SERVER_BASED_SEARCH may provide a better solution.
-
-SEARCHENGINE           = YES
-
-# When the SERVER_BASED_SEARCH tag is enabled the search engine will be
-# implemented using a web server instead of a web client using Javascript.
-# There are two flavours of web server based search depending on the
-# EXTERNAL_SEARCH setting. When disabled, doxygen will generate a PHP script for
-# searching and an index file used by the script. When EXTERNAL_SEARCH is
-# enabled the indexing and searching needs to be provided by external tools.
-# See the manual for details.
-
-SERVER_BASED_SEARCH    = NO
-
-# When EXTERNAL_SEARCH is enabled doxygen will no longer generate the PHP
-# script for searching. Instead the search results are written to an XML file
-# which needs to be processed by an external indexer. Doxygen will invoke an
-# external search engine pointed to by the SEARCHENGINE_URL option to obtain
-# the search results. Doxygen ships with an example indexer (doxyindexer) and
-# search engine (doxysearch.cgi) which are based on the open source search
-# engine library Xapian. See the manual for configuration details.
-
-EXTERNAL_SEARCH        = NO
-
-# The SEARCHENGINE_URL should point to a search engine hosted by a web server
-# which will returned the search results when EXTERNAL_SEARCH is enabled.
-# Doxygen ships with an example search engine (doxysearch) which is based on
-# the open source search engine library Xapian. See the manual for configuration
-# details.
-
-SEARCHENGINE_URL       =
-
-# When SERVER_BASED_SEARCH and EXTERNAL_SEARCH are both enabled the unindexed
-# search data is written to a file for indexing by an external tool. With the
-# SEARCHDATA_FILE tag the name of this file can be specified.
-
-SEARCHDATA_FILE        = searchdata.xml
-
-# When SERVER_BASED_SEARCH AND EXTERNAL_SEARCH are both enabled the
-# EXTERNAL_SEARCH_ID tag can be used as an identifier for the project. This is
-# useful in combination with EXTRA_SEARCH_MAPPINGS to search through multiple
-# projects and redirect the results back to the right project.
-
-EXTERNAL_SEARCH_ID     =
-
-# The EXTRA_SEARCH_MAPPINGS tag can be used to enable searching through doxygen
-# projects other than the one defined by this configuration file, but that are
-# all added to the same external search index. Each project needs to have a
-# unique id set via EXTERNAL_SEARCH_ID. The search mapping then maps the id
-# of to a relative location where the documentation can be found.
-# The format is: EXTRA_SEARCH_MAPPINGS = id1=loc1 id2=loc2 ...
-
-EXTRA_SEARCH_MAPPINGS  =
-
-#---------------------------------------------------------------------------
-# configuration options related to the LaTeX output
-#---------------------------------------------------------------------------
-
-# If the GENERATE_LATEX tag is set to YES (the default) Doxygen will
-# generate Latex output.
-
-GENERATE_LATEX         = NO
-
-# The LATEX_OUTPUT tag is used to specify where the LaTeX docs will be put.
-# If a relative path is entered the value of OUTPUT_DIRECTORY will be
-# put in front of it. If left blank `latex' will be used as the default path.
-
-LATEX_OUTPUT           = latex
-
-# The LATEX_CMD_NAME tag can be used to specify the LaTeX command name to be
-# invoked. If left blank `latex' will be used as the default command name.
-# Note that when enabling USE_PDFLATEX this option is only used for
-# generating bitmaps for formulas in the HTML output, but not in the
-# Makefile that is written to the output directory.
-
-LATEX_CMD_NAME         = latex
-
-# The MAKEINDEX_CMD_NAME tag can be used to specify the command name to
-# generate index for LaTeX. If left blank `makeindex' will be used as the
-# default command name.
-
-MAKEINDEX_CMD_NAME     = makeindex
-
-# If the COMPACT_LATEX tag is set to YES Doxygen generates more compact
-# LaTeX documents. This may be useful for small projects and may help to
-# save some trees in general.
-
-COMPACT_LATEX          = NO
-
-# The PAPER_TYPE tag can be used to set the paper type that is used
-# by the printer. Possible values are: a4, letter, legal and
-# executive. If left blank a4 will be used.
-
-PAPER_TYPE             = a4wide
-
-# The EXTRA_PACKAGES tag can be to specify one or more names of LaTeX
-# packages that should be included in the LaTeX output.
-
-EXTRA_PACKAGES         =
-
-# The LATEX_HEADER tag can be used to specify a personal LaTeX header for
-# the generated latex document. The header should contain everything until
-# the first chapter. If it is left blank doxygen will generate a
-# standard header. Notice: only use this tag if you know what you are doing!
-
-LATEX_HEADER           =
-
-# The LATEX_FOOTER tag can be used to specify a personal LaTeX footer for
-# the generated latex document. The footer should contain everything after
-# the last chapter. If it is left blank doxygen will generate a
-# standard footer. Notice: only use this tag if you know what you are doing!
-
-LATEX_FOOTER           =
-
-# The LATEX_EXTRA_FILES tag can be used to specify one or more extra images
-# or other source files which should be copied to the LaTeX output directory.
-# Note that the files will be copied as-is; there are no commands or markers
-# available.
-
-LATEX_EXTRA_FILES      =
-
-# If the PDF_HYPERLINKS tag is set to YES, the LaTeX that is generated
-# is prepared for conversion to pdf (using ps2pdf). The pdf file will
-# contain links (just like the HTML output) instead of page references
-# This makes the output suitable for online browsing using a pdf viewer.
-
-PDF_HYPERLINKS         = YES
-
-# If the USE_PDFLATEX tag is set to YES, pdflatex will be used instead of
-# plain latex in the generated Makefile. Set this option to YES to get a
-# higher quality PDF documentation.
-
-USE_PDFLATEX           = YES
-
-# If the LATEX_BATCHMODE tag is set to YES, doxygen will add the \\batchmode.
-# command to the generated LaTeX files. This will instruct LaTeX to keep
-# running if errors occur, instead of asking the user for help.
-# This option is also used when generating formulas in HTML.
-
-LATEX_BATCHMODE        = NO
-
-# If LATEX_HIDE_INDICES is set to YES then doxygen will not
-# include the index chapters (such as File Index, Compound Index, etc.)
-# in the output.
-
-LATEX_HIDE_INDICES     = NO
-
-# If LATEX_SOURCE_CODE is set to YES then doxygen will include
-# source code with syntax highlighting in the LaTeX output.
-# Note that which sources are shown also depends on other settings
-# such as SOURCE_BROWSER.
-
-LATEX_SOURCE_CODE      = NO
-
-# The LATEX_BIB_STYLE tag can be used to specify the style to use for the
-# bibliography, e.g. plainnat, or ieeetr. The default style is "plain". See
-# http://en.wikipedia.org/wiki/BibTeX for more info.
-
-LATEX_BIB_STYLE        = plain
-
-#---------------------------------------------------------------------------
-# configuration options related to the RTF output
-#---------------------------------------------------------------------------
-
-# If the GENERATE_RTF tag is set to YES Doxygen will generate RTF output
-# The RTF output is optimized for Word 97 and may not look very pretty with
-# other RTF readers or editors.
-
-GENERATE_RTF           = NO
-
-# The RTF_OUTPUT tag is used to specify where the RTF docs will be put.
-# If a relative path is entered the value of OUTPUT_DIRECTORY will be
-# put in front of it. If left blank `rtf' will be used as the default path.
-
-RTF_OUTPUT             = rtf
-
-# If the COMPACT_RTF tag is set to YES Doxygen generates more compact
-# RTF documents. This may be useful for small projects and may help to
-# save some trees in general.
-
-COMPACT_RTF            = NO
-
-# If the RTF_HYPERLINKS tag is set to YES, the RTF that is generated
-# will contain hyperlink fields. The RTF file will
-# contain links (just like the HTML output) instead of page references.
-# This makes the output suitable for online browsing using WORD or other
-# programs which support those fields.
-# Note: wordpad (write) and others do not support links.
-
-RTF_HYPERLINKS         = NO
-
-# Load style sheet definitions from file. Syntax is similar to doxygen's
-# config file, i.e. a series of assignments. You only have to provide
-# replacements, missing definitions are set to their default value.
-
-RTF_STYLESHEET_FILE    =
-
-# Set optional variables used in the generation of an rtf document.
-# Syntax is similar to doxygen's config file.
-
-RTF_EXTENSIONS_FILE    =
-
-#---------------------------------------------------------------------------
-# configuration options related to the man page output
-#---------------------------------------------------------------------------
-
-# If the GENERATE_MAN tag is set to YES (the default) Doxygen will
-# generate man pages
-
-GENERATE_MAN           = NO
-
-# The MAN_OUTPUT tag is used to specify where the man pages will be put.
-# If a relative path is entered the value of OUTPUT_DIRECTORY will be
-# put in front of it. If left blank `man' will be used as the default path.
-
-MAN_OUTPUT             = man
-
-# The MAN_EXTENSION tag determines the extension that is added to
-# the generated man pages (default is the subroutine's section .3)
-
-MAN_EXTENSION          = .3
-
-# If the MAN_LINKS tag is set to YES and Doxygen generates man output,
-# then it will generate one additional man file for each entity
-# documented in the real man page(s). These additional files
-# only source the real man page, but without them the man command
-# would be unable to find the correct page. The default is NO.
-
-MAN_LINKS              = NO
-
-#---------------------------------------------------------------------------
-# configuration options related to the XML output
-#---------------------------------------------------------------------------
-
-# If the GENERATE_XML tag is set to YES Doxygen will
-# generate an XML file that captures the structure of
-# the code including all documentation.
-
-GENERATE_XML           = YES
-
-# The XML_OUTPUT tag is used to specify where the XML pages will be put.
-# If a relative path is entered the value of OUTPUT_DIRECTORY will be
-# put in front of it. If left blank `xml' will be used as the default path.
-
-XML_OUTPUT             = xml
-
-# If the XML_PROGRAMLISTING tag is set to YES Doxygen will
-# dump the program listings (including syntax highlighting
-# and cross-referencing information) to the XML output. Note that
-# enabling this will significantly increase the size of the XML output.
-
-XML_PROGRAMLISTING     = YES
-
-#---------------------------------------------------------------------------
-# configuration options related to the DOCBOOK output
-#---------------------------------------------------------------------------
-
-# If the GENERATE_DOCBOOK tag is set to YES Doxygen will generate DOCBOOK files
-# that can be used to generate PDF.
-
-GENERATE_DOCBOOK       = NO
-
-# The DOCBOOK_OUTPUT tag is used to specify where the DOCBOOK pages will be put.
-# If a relative path is entered the value of OUTPUT_DIRECTORY will be put in
-# front of it. If left blank docbook will be used as the default path.
-
-DOCBOOK_OUTPUT         = docbook
-
-#---------------------------------------------------------------------------
-# configuration options for the AutoGen Definitions output
-#---------------------------------------------------------------------------
-
-# If the GENERATE_AUTOGEN_DEF tag is set to YES Doxygen will
-# generate an AutoGen Definitions (see autogen.sf.net) file
-# that captures the structure of the code including all
-# documentation. Note that this feature is still experimental
-# and incomplete at the moment.
-
-GENERATE_AUTOGEN_DEF   = NO
-
-#---------------------------------------------------------------------------
-# configuration options related to the Perl module output
-#---------------------------------------------------------------------------
-
-# If the GENERATE_PERLMOD tag is set to YES Doxygen will
-# generate a Perl module file that captures the structure of
-# the code including all documentation. Note that this
-# feature is still experimental and incomplete at the
-# moment.
-
-GENERATE_PERLMOD       = NO
-
-# If the PERLMOD_LATEX tag is set to YES Doxygen will generate
-# the necessary Makefile rules, Perl scripts and LaTeX code to be able
-# to generate PDF and DVI output from the Perl module output.
-
-PERLMOD_LATEX          = NO
-
-# If the PERLMOD_PRETTY tag is set to YES the Perl module output will be
-# nicely formatted so it can be parsed by a human reader.
-# This is useful
-# if you want to understand what is going on.
-# On the other hand, if this
-# tag is set to NO the size of the Perl module output will be much smaller
-# and Perl will parse it just the same.
-
-PERLMOD_PRETTY         = YES
-
-# The names of the make variables in the generated doxyrules.make file
-# are prefixed with the string contained in PERLMOD_MAKEVAR_PREFIX.
-# This is useful so different doxyrules.make files included by the same
-# Makefile don't overwrite each other's variables.
-
-PERLMOD_MAKEVAR_PREFIX =
-
-#---------------------------------------------------------------------------
-# Configuration options related to the preprocessor
-#---------------------------------------------------------------------------
-
-# If the ENABLE_PREPROCESSING tag is set to YES (the default) Doxygen will
-# evaluate all C-preprocessor directives found in the sources and include
-# files.
-
-ENABLE_PREPROCESSING   = YES
-
-# If the MACRO_EXPANSION tag is set to YES Doxygen will expand all macro
-# names in the source code. If set to NO (the default) only conditional
-# compilation will be performed. Macro expansion can be done in a controlled
-# way by setting EXPAND_ONLY_PREDEF to YES.
-
-MACRO_EXPANSION        = YES
-
-# If the EXPAND_ONLY_PREDEF and MACRO_EXPANSION tags are both set to YES
-# then the macro expansion is limited to the macros specified with the
-# PREDEFINED and EXPAND_AS_DEFINED tags.
-
-EXPAND_ONLY_PREDEF     = NO
-
-# If the SEARCH_INCLUDES tag is set to YES (the default) the includes files
-# pointed to by INCLUDE_PATH will be searched when a #include is found.
-
-SEARCH_INCLUDES        = YES
-
-# The INCLUDE_PATH tag can be used to specify one or more directories that
-# contain include files that are not input files but should be processed by
-# the preprocessor.
-
-INCLUDE_PATH           =
-
-# You can use the INCLUDE_FILE_PATTERNS tag to specify one or more wildcard
-# patterns (like *.h and *.hpp) to filter out the header-files in the
-# directories. If left blank, the patterns specified with FILE_PATTERNS will
-# be used.
-
-INCLUDE_FILE_PATTERNS  =
-
-# The PREDEFINED tag can be used to specify one or more macro names that
-# are defined before the preprocessor is started (similar to the -D option of
-# gcc). The argument of the tag is a list of macros of the form: name
-# or name=definition (no spaces). If the definition and the = are
-# omitted =1 is assumed. To prevent a macro definition from being
-# undefined via #undef or recursively expanded use the := operator
-# instead of the = operator.
-
-PREDEFINED             =
-
-# If the MACRO_EXPANSION and EXPAND_ONLY_PREDEF tags are set to YES then
-# this tag can be used to specify a list of macro names that should be expanded.
-# The macro definition that is found in the sources will be used.
-# Use the PREDEFINED tag if you want to use a different macro definition that
-# overrules the definition found in the source code.
-
-EXPAND_AS_DEFINED      =
-
-# If the SKIP_FUNCTION_MACROS tag is set to YES (the default) then
-# doxygen's preprocessor will remove all references to function-like macros
-# that are alone on a line, have an all uppercase name, and do not end with a
-# semicolon, because these will confuse the parser if not removed.
-
-SKIP_FUNCTION_MACROS   = YES
-
-#---------------------------------------------------------------------------
-# Configuration::additions related to external references
-#---------------------------------------------------------------------------
-
-# The TAGFILES option can be used to specify one or more tagfiles. For each
-# tag file the location of the external documentation should be added. The
-# format of a tag file without this location is as follows:
-#
-# TAGFILES = file1 file2 ...
-# Adding location for the tag files is done as follows:
-#
-# TAGFILES = file1=loc1 "file2 = loc2" ...
-# where "loc1" and "loc2" can be relative or absolute paths
-# or URLs. Note that each tag file must have a unique name (where the name does
-# NOT include the path). If a tag file is not located in the directory in which
-# doxygen is run, you must also specify the path to the tagfile here.
-
-TAGFILES               =
-
-# When a file name is specified after GENERATE_TAGFILE, doxygen will create
-# a tag file that is based on the input files it reads.
-
-GENERATE_TAGFILE       =
-
-# If the ALLEXTERNALS tag is set to YES all external classes will be listed
-# in the class index. If set to NO only the inherited external classes
-# will be listed.
-
-ALLEXTERNALS           = NO
-
-# If the EXTERNAL_GROUPS tag is set to YES all external groups will be listed
-# in the modules index. If set to NO, only the current project's groups will
-# be listed.
-
-EXTERNAL_GROUPS        = YES
-
-# If the EXTERNAL_PAGES tag is set to YES all external pages will be listed
-# in the related pages index. If set to NO, only the current project's
-# pages will be listed.
-
-EXTERNAL_PAGES         = YES
-
-# The PERL_PATH should be the absolute path and name of the perl script
-# interpreter (i.e. the result of `which perl').
-
-PERL_PATH              = /usr/bin/perl
-
-#---------------------------------------------------------------------------
-# Configuration options related to the dot tool
-#---------------------------------------------------------------------------
-
-# If the CLASS_DIAGRAMS tag is set to YES (the default) Doxygen will
-# generate a inheritance diagram (in HTML, RTF and LaTeX) for classes with base
-# or super classes. Setting the tag to NO turns the diagrams off. Note that
-# this option also works with HAVE_DOT disabled, but it is recommended to
-# install and use dot, since it yields more powerful graphs.
-
-CLASS_DIAGRAMS         = YES
-
-# You can define message sequence charts within doxygen comments using the \msc
-# command. Doxygen will then run the mscgen tool (see
-# http://www.mcternan.me.uk/mscgen/) to produce the chart and insert it in the
-# documentation. The MSCGEN_PATH tag allows you to specify the directory where
-# the mscgen tool resides. If left empty the tool is assumed to be found in the
-# default search path.
-
-MSCGEN_PATH            =
-
-# If set to YES, the inheritance and collaboration graphs will hide
-# inheritance and usage relations if the target is undocumented
-# or is not a class.
-
-HIDE_UNDOC_RELATIONS   = YES
-
-# If you set the HAVE_DOT tag to YES then doxygen will assume the dot tool is
-# available from the path. This tool is part of Graphviz, a graph visualization
-# toolkit from AT&T and Lucent Bell Labs. The other options in this section
-# have no effect if this option is set to NO (the default)
-
-HAVE_DOT               = NO
-
-# The DOT_NUM_THREADS specifies the number of dot invocations doxygen is
-# allowed to run in parallel. When set to 0 (the default) doxygen will
-# base this on the number of processors available in the system. You can set it
-# explicitly to a value larger than 0 to get control over the balance
-# between CPU load and processing speed.
-
-DOT_NUM_THREADS        = 0
-
-# By default doxygen will use the Helvetica font for all dot files that
-# doxygen generates. When you want a differently looking font you can specify
-# the font name using DOT_FONTNAME. You need to make sure dot is able to find
-# the font, which can be done by putting it in a standard location or by setting
-# the DOTFONTPATH environment variable or by setting DOT_FONTPATH to the
-# directory containing the font.
-
-DOT_FONTNAME           = Helvetica
-
-# The DOT_FONTSIZE tag can be used to set the size of the font of dot graphs.
-# The default size is 10pt.
-
-DOT_FONTSIZE           = 10
-
-# By default doxygen will tell dot to use the Helvetica font.
-# If you specify a different font using DOT_FONTNAME you can use DOT_FONTPATH to
-# set the path where dot can find it.
-
-DOT_FONTPATH           =
-
-# If the CLASS_GRAPH and HAVE_DOT tags are set to YES then doxygen
-# will generate a graph for each documented class showing the direct and
-# indirect inheritance relations. Setting this tag to YES will force the
-# CLASS_DIAGRAMS tag to NO.
-
-CLASS_GRAPH            = YES
-
-# If the COLLABORATION_GRAPH and HAVE_DOT tags are set to YES then doxygen
-# will generate a graph for each documented class showing the direct and
-# indirect implementation dependencies (inheritance, containment, and
-# class references variables) of the class with other documented classes.
-
-COLLABORATION_GRAPH    = YES
-
-# If the GROUP_GRAPHS and HAVE_DOT tags are set to YES then doxygen
-# will generate a graph for groups, showing the direct groups dependencies
-
-GROUP_GRAPHS           = YES
-
-# If the UML_LOOK tag is set to YES doxygen will generate inheritance and
-# collaboration diagrams in a style similar to the OMG's Unified Modeling
-# Language.
-
-UML_LOOK               = NO
-
-# If the UML_LOOK tag is enabled, the fields and methods are shown inside
-# the class node. If there are many fields or methods and many nodes the
-# graph may become too big to be useful. The UML_LIMIT_NUM_FIELDS
-# threshold limits the number of items for each type to make the size more
-# manageable. Set this to 0 for no limit. Note that the threshold may be
-# exceeded by 50% before the limit is enforced.
-
-UML_LIMIT_NUM_FIELDS   = 10
-
-# If set to YES, the inheritance and collaboration graphs will show the
-# relations between templates and their instances.
-
-TEMPLATE_RELATIONS     = NO
-
-# If the ENABLE_PREPROCESSING, SEARCH_INCLUDES, INCLUDE_GRAPH, and HAVE_DOT
-# tags are set to YES then doxygen will generate a graph for each documented
-# file showing the direct and indirect include dependencies of the file with
-# other documented files.
-
-INCLUDE_GRAPH          = YES
-
-# If the ENABLE_PREPROCESSING, SEARCH_INCLUDES, INCLUDED_BY_GRAPH, and
-# HAVE_DOT tags are set to YES then doxygen will generate a graph for each
-# documented header file showing the documented files that directly or
-# indirectly include this file.
-
-INCLUDED_BY_GRAPH      = YES
-
-# If the CALL_GRAPH and HAVE_DOT options are set to YES then
-# doxygen will generate a call dependency graph for every global function
-# or class method. Note that enabling this option will significantly increase
-# the time of a run. So in most cases it will be better to enable call graphs
-# for selected functions only using the \callgraph command.
-
-CALL_GRAPH             = NO
-
-# If the CALLER_GRAPH and HAVE_DOT tags are set to YES then
-# doxygen will generate a caller dependency graph for every global function
-# or class method. Note that enabling this option will significantly increase
-# the time of a run. So in most cases it will be better to enable caller
-# graphs for selected functions only using the \callergraph command.
-
-CALLER_GRAPH           = NO
-
-# If the GRAPHICAL_HIERARCHY and HAVE_DOT tags are set to YES then doxygen
-# will generate a graphical hierarchy of all classes instead of a textual one.
-
-GRAPHICAL_HIERARCHY    = YES
-
-# If the DIRECTORY_GRAPH and HAVE_DOT tags are set to YES
-# then doxygen will show the dependencies a directory has on other directories
-# in a graphical way. The dependency relations are determined by the #include
-# relations between the files in the directories.
-
-DIRECTORY_GRAPH        = YES
-
-# The DOT_IMAGE_FORMAT tag can be used to set the image format of the images
-# generated by dot. Possible values are svg, png, jpg, or gif.
-# If left blank png will be used. If you choose svg you need to set
-# HTML_FILE_EXTENSION to xhtml in order to make the SVG files
-# visible in IE 9+ (other browsers do not have this requirement).
-
-DOT_IMAGE_FORMAT       = png
-
-# If DOT_IMAGE_FORMAT is set to svg, then this option can be set to YES to
-# enable generation of interactive SVG images that allow zooming and panning.
-# Note that this requires a modern browser other than Internet Explorer.
-# Tested and working are Firefox, Chrome, Safari, and Opera. For IE 9+ you
-# need to set HTML_FILE_EXTENSION to xhtml in order to make the SVG files
-# visible. Older versions of IE do not have SVG support.
-
-INTERACTIVE_SVG        = NO
-
-# The tag DOT_PATH can be used to specify the path where the dot tool can be
-# found. If left blank, it is assumed the dot tool can be found in the path.
-
-DOT_PATH               =
-
-# The DOTFILE_DIRS tag can be used to specify one or more directories that
-# contain dot files that are included in the documentation (see the
-# \dotfile command).
-
-DOTFILE_DIRS           =
-
-# The MSCFILE_DIRS tag can be used to specify one or more directories that
-# contain msc files that are included in the documentation (see the
-# \mscfile command).
-
-MSCFILE_DIRS           =
-
-# The DOT_GRAPH_MAX_NODES tag can be used to set the maximum number of
-# nodes that will be shown in the graph. If the number of nodes in a graph
-# becomes larger than this value, doxygen will truncate the graph, which is
-# visualized by representing a node as a red box. Note that doxygen if the
-# number of direct children of the root node in a graph is already larger than
-# DOT_GRAPH_MAX_NODES then the graph will not be shown at all. Also note
-# that the size of a graph can be further restricted by MAX_DOT_GRAPH_DEPTH.
-
-DOT_GRAPH_MAX_NODES    = 50
-
-# The MAX_DOT_GRAPH_DEPTH tag can be used to set the maximum depth of the
-# graphs generated by dot. A depth value of 3 means that only nodes reachable
-# from the root by following a path via at most 3 edges will be shown. Nodes
-# that lay further from the root node will be omitted. Note that setting this
-# option to 1 or 2 may greatly reduce the computation time needed for large
-# code bases. Also note that the size of a graph can be further restricted by
-# DOT_GRAPH_MAX_NODES. Using a depth of 0 means no depth restriction.
-
-MAX_DOT_GRAPH_DEPTH    = 0
-
-# Set the DOT_TRANSPARENT tag to YES to generate images with a transparent
-# background. This is disabled by default, because dot on Windows does not
-# seem to support this out of the box. Warning: Depending on the platform used,
-# enabling this option may lead to badly anti-aliased labels on the edges of
-# a graph (i.e. they become hard to read).
-
-DOT_TRANSPARENT        = NO
-
-# Set the DOT_MULTI_TARGETS tag to YES allow dot to generate multiple output
-# files in one run (i.e. multiple -o and -T options on the command line). This
-# makes dot run faster, but since only newer versions of dot (>1.8.10)
-# support this, this feature is disabled by default.
-
-DOT_MULTI_TARGETS      = YES
-
-# If the GENERATE_LEGEND tag is set to YES (the default) Doxygen will
-# generate a legend page explaining the meaning of the various boxes and
-# arrows in the dot generated graphs.
-
-GENERATE_LEGEND        = YES
-
-# If the DOT_CLEANUP tag is set to YES (the default) Doxygen will
-# remove the intermediate dot files that are used to generate
-# the various graphs.
-
-DOT_CLEANUP            = YES
diff --git a/docs/doxygen/doxyxml/__init__.py b/docs/doxygen/doxyxml/__init__.py
index 26c8bf8..f9a9ce4 100644
--- a/docs/doxygen/doxyxml/__init__.py
+++ b/docs/doxygen/doxyxml/__init__.py
@@ -4,20 +4,8 @@
 # This file was generated by gr_modtool, a tool from the GNU Radio framework
 # This file is a part of gr-satellites
 #
-# GNU Radio is free software; you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation; either version 3, or (at your option)
-# any later version.
+# SPDX-License-Identifier: GPL-3.0-or-later
 #
-# GNU Radio is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with GNU Radio; see the file COPYING.  If not, write to
-# the Free Software Foundation, Inc., 51 Franklin Street,
-# Boston, MA 02110-1301, USA.
 #
 """
 Python interface to contents of doxygen xml documentation.
@@ -64,10 +52,10 @@ This line is uninformative and is only to test line breaks in the comments.
 u'Outputs the vital aadvark statistics.'
 
 """
-from __future__ import unicode_literals
 
 from .doxyindex import DoxyIndex, DoxyFunction, DoxyParam, DoxyClass, DoxyFile, DoxyNamespace, DoxyGroup, DoxyFriend, DoxyOther
 
+
 def _test():
     import os
     this_dir = os.path.dirname(globals()['__file__'])
@@ -79,6 +67,6 @@ def _test():
     import doctest
     return doctest.testmod()
 
+
 if __name__ == "__main__":
     _test()
-
diff --git a/docs/doxygen/doxyxml/base.py b/docs/doxygen/doxyxml/base.py
index 56e7b16..350e98d 100644
--- a/docs/doxygen/doxyxml/base.py
+++ b/docs/doxygen/doxyxml/base.py
@@ -4,20 +4,8 @@
 # This file was generated by gr_modtool, a tool from the GNU Radio framework
 # This file is a part of gr-satellites
 #
-# GNU Radio is free software; you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation; either version 3, or (at your option)
-# any later version.
+# SPDX-License-Identifier: GPL-3.0-or-later
 #
-# GNU Radio is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with GNU Radio; see the file COPYING.  If not, write to
-# the Free Software Foundation, Inc., 51 Franklin Street,
-# Boston, MA 02110-1301, USA.
 #
 """
 A base class is created.
@@ -25,8 +13,6 @@ A base class is created.
 Classes based upon this are used to make more user-friendly interfaces
 to the doxygen xml docs than the generated classes provide.
 """
-from __future__ import print_function
-from __future__ import unicode_literals
 
 import os
 import pdb
@@ -97,8 +83,8 @@ class Base(object):
         for cls in self.mem_classes:
             if cls.can_parse(mem):
                 return cls
-        raise Exception(("Did not find a class for object '%s'." \
-                                 % (mem.get_name())))
+        raise Exception(("Did not find a class for object '%s'."
+                         % (mem.get_name())))
 
     def convert_mem(self, mem):
         try:
diff --git a/docs/doxygen/doxyxml/doxyindex.py b/docs/doxygen/doxyxml/doxyindex.py
index 2cf7cf0..959c7be 100644
--- a/docs/doxygen/doxyxml/doxyindex.py
+++ b/docs/doxygen/doxyxml/doxyindex.py
@@ -4,27 +4,13 @@
 # This file was generated by gr_modtool, a tool from the GNU Radio framework
 # This file is a part of gr-satellites
 #
-# GNU Radio is free software; you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation; either version 3, or (at your option)
-# any later version.
+# SPDX-License-Identifier: GPL-3.0-or-later
 #
-# GNU Radio is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with GNU Radio; see the file COPYING.  If not, write to
-# the Free Software Foundation, Inc., 51 Franklin Street,
-# Boston, MA 02110-1301, USA.
 #
 """
 Classes providing more user-friendly interfaces to the doxygen xml
 docs than the generated classes provide.
 """
-from __future__ import absolute_import
-from __future__ import unicode_literals
 
 import os
 
@@ -32,6 +18,7 @@ from .generated import index
 from .base import Base
 from .text import description
 
+
 class DoxyIndex(Base):
     """
     Parses a doxygen xml directory.
@@ -60,17 +47,8 @@ class DoxyIndex(Base):
                 self._members.append(converted)
 
 
-def generate_swig_doc_i(self):
-    """
-    %feature("docstring") gr_make_align_on_samplenumbers_ss::align_state "
-    Wraps the C++: gr_align_on_samplenumbers_ss::align_state";
-    """
-    pass
-
-
 class DoxyCompMem(Base):
 
-
     kind = None
 
     def __init__(self, *args, **kwargs):
@@ -106,9 +84,11 @@ class DoxyCompMem(Base):
 class DoxyCompound(DoxyCompMem):
     pass
 
+
 class DoxyMember(DoxyCompMem):
     pass
 
+
 class DoxyFunction(DoxyMember):
 
     __module__ = "gnuradio.utils.doxyxml"
@@ -129,9 +109,11 @@ class DoxyFunction(DoxyMember):
                 self._data['params'].append(DoxyParam(prm))
 
     brief_description = property(lambda self: self.data()['brief_description'])
-    detailed_description = property(lambda self: self.data()['detailed_description'])
+    detailed_description = property(
+        lambda self: self.data()['detailed_description'])
     params = property(lambda self: self.data()['params'])
 
+
 Base.mem_classes.append(DoxyFunction)
 
 
@@ -156,9 +138,11 @@ class DoxyParam(DoxyMember):
         return '\n\n'.join(descriptions)
 
     brief_description = property(lambda self: self.data()['brief_description'])
-    detailed_description = property(lambda self: self.data()['detailed_description'])
+    detailed_description = property(
+        lambda self: self.data()['detailed_description'])
     name = property(lambda self: self.data()['declname'])
 
+
 class DoxyParameterItem(DoxyMember):
     """A different representation of a parameter in Doxygen."""
 
@@ -200,9 +184,11 @@ class DoxyClass(DoxyCompound):
         self.process_memberdefs()
 
     brief_description = property(lambda self: self.data()['brief_description'])
-    detailed_description = property(lambda self: self.data()['detailed_description'])
+    detailed_description = property(
+        lambda self: self.data()['detailed_description'])
     params = property(lambda self: self.data()['params'])
 
+
 Base.mem_classes.append(DoxyClass)
 
 
@@ -223,7 +209,9 @@ class DoxyFile(DoxyCompound):
         self.process_memberdefs()
 
     brief_description = property(lambda self: self.data()['brief_description'])
-    detailed_description = property(lambda self: self.data()['detailed_description'])
+    detailed_description = property(
+        lambda self: self.data()['detailed_description'])
+
 
 Base.mem_classes.append(DoxyFile)
 
@@ -244,6 +232,7 @@ class DoxyNamespace(DoxyCompound):
             return
         self.process_memberdefs()
 
+
 Base.mem_classes.append(DoxyNamespace)
 
 
@@ -287,6 +276,7 @@ class DoxyFriend(DoxyMember):
 
     kind = 'friend'
 
+
 Base.mem_classes.append(DoxyFriend)
 
 
@@ -301,4 +291,5 @@ class DoxyOther(Base):
     def can_parse(cls, obj):
         return obj.kind in cls.kinds
 
+
 Base.mem_classes.append(DoxyOther)
diff --git a/docs/doxygen/doxyxml/generated/__init__.py b/docs/doxygen/doxyxml/generated/__init__.py
index 23095c1..3982397 100644
--- a/docs/doxygen/doxyxml/generated/__init__.py
+++ b/docs/doxygen/doxyxml/generated/__init__.py
@@ -5,4 +5,3 @@ These do the real work of parsing the doxygen xml files but the
 resultant classes are not very friendly to navigate so the rest of the
 doxyxml module processes them further.
 """
-from __future__ import unicode_literals
diff --git a/docs/doxygen/doxyxml/generated/compound.py b/docs/doxygen/doxyxml/generated/compound.py
index acfa0dd..321328b 100644
--- a/docs/doxygen/doxyxml/generated/compound.py
+++ b/docs/doxygen/doxyxml/generated/compound.py
@@ -3,8 +3,6 @@
 """
 Generated Mon Feb  9 19:08:05 2009 by generateDS.py.
 """
-from __future__ import absolute_import
-from __future__ import unicode_literals
 
 
 from xml.dom import minidom
@@ -24,13 +22,15 @@ class DoxygenTypeSub(supermod.DoxygenType):
 
         return self.compounddef.find(details)
 
+
 supermod.DoxygenType.subclass = DoxygenTypeSub
 # end class DoxygenTypeSub
 
 
 class compounddefTypeSub(supermod.compounddefType):
     def __init__(self, kind=None, prot=None, id=None, compoundname='', title='', basecompoundref=None, derivedcompoundref=None, includes=None, includedby=None, incdepgraph=None, invincdepgraph=None, innerdir=None, innerfile=None, innerclass=None, innernamespace=None, innerpage=None, innergroup=None, templateparamlist=None, sectiondef=None, briefdescription=None, detaileddescription=None, inheritancegraph=None, collaborationgraph=None, programlisting=None, location=None, listofallmembers=None):
-        supermod.compounddefType.__init__(self, kind, prot, id, compoundname, title, basecompoundref, derivedcompoundref, includes, includedby, incdepgraph, invincdepgraph, innerdir, innerfile, innerclass, innernamespace, innerpage, innergroup, templateparamlist, sectiondef, briefdescription, detaileddescription, inheritancegraph, collaborationgraph, programlisting, location, listofallmembers)
+        supermod.compounddefType.__init__(self, kind, prot, id, compoundname, title, basecompoundref, derivedcompoundref, includes, includedby, incdepgraph, invincdepgraph, innerdir, innerfile, innerclass,
+                                          innernamespace, innerpage, innergroup, templateparamlist, sectiondef, briefdescription, detaileddescription, inheritancegraph, collaborationgraph, programlisting, location, listofallmembers)
 
     def find(self, details):
 
@@ -50,13 +50,18 @@ supermod.compounddefType.subclass = compounddefTypeSub
 class listofallmembersTypeSub(supermod.listofallmembersType):
     def __init__(self, member=None):
         supermod.listofallmembersType.__init__(self, member)
+
+
 supermod.listofallmembersType.subclass = listofallmembersTypeSub
 # end class listofallmembersTypeSub
 
 
 class memberRefTypeSub(supermod.memberRefType):
     def __init__(self, virt=None, prot=None, refid=None, ambiguityscope=None, scope='', name=''):
-        supermod.memberRefType.__init__(self, virt, prot, refid, ambiguityscope, scope, name)
+        supermod.memberRefType.__init__(
+            self, virt, prot, refid, ambiguityscope, scope, name)
+
+
 supermod.memberRefType.subclass = memberRefTypeSub
 # end class memberRefTypeSub
 
@@ -64,6 +69,8 @@ supermod.memberRefType.subclass = memberRefTypeSub
 class compoundRefTypeSub(supermod.compoundRefType):
     def __init__(self, virt=None, prot=None, refid=None, valueOf_='', mixedclass_=None, content_=None):
         supermod.compoundRefType.__init__(self, mixedclass_, content_)
+
+
 supermod.compoundRefType.subclass = compoundRefTypeSub
 # end class compoundRefTypeSub
 
@@ -71,6 +78,8 @@ supermod.compoundRefType.subclass = compoundRefTypeSub
 class reimplementTypeSub(supermod.reimplementType):
     def __init__(self, refid=None, valueOf_='', mixedclass_=None, content_=None):
         supermod.reimplementType.__init__(self, mixedclass_, content_)
+
+
 supermod.reimplementType.subclass = reimplementTypeSub
 # end class reimplementTypeSub
 
@@ -78,6 +87,8 @@ supermod.reimplementType.subclass = reimplementTypeSub
 class incTypeSub(supermod.incType):
     def __init__(self, local=None, refid=None, valueOf_='', mixedclass_=None, content_=None):
         supermod.incType.__init__(self, mixedclass_, content_)
+
+
 supermod.incType.subclass = incTypeSub
 # end class incTypeSub
 
@@ -85,23 +96,26 @@ supermod.incType.subclass = incTypeSub
 class refTypeSub(supermod.refType):
     def __init__(self, prot=None, refid=None, valueOf_='', mixedclass_=None, content_=None):
         supermod.refType.__init__(self, mixedclass_, content_)
+
+
 supermod.refType.subclass = refTypeSub
 # end class refTypeSub
 
 
-
 class refTextTypeSub(supermod.refTextType):
     def __init__(self, refid=None, kindref=None, external=None, valueOf_='', mixedclass_=None, content_=None):
         supermod.refTextType.__init__(self, mixedclass_, content_)
 
+
 supermod.refTextType.subclass = refTextTypeSub
 # end class refTextTypeSub
 
-class sectiondefTypeSub(supermod.sectiondefType):
 
+class sectiondefTypeSub(supermod.sectiondefType):
 
     def __init__(self, kind=None, header='', description=None, memberdef=None):
-        supermod.sectiondefType.__init__(self, kind, header, description, memberdef)
+        supermod.sectiondefType.__init__(
+            self, kind, header, description, memberdef)
 
     def find(self, details):
 
@@ -118,7 +132,10 @@ supermod.sectiondefType.subclass = sectiondefTypeSub
 
 class memberdefTypeSub(supermod.memberdefType):
     def __init__(self, initonly=None, kind=None, volatile=None, const=None, raise_=None, virt=None, readable=None, prot=None, explicit=None, new=None, final=None, writable=None, add=None, static=None, remove=None, sealed=None, mutable=None, gettable=None, inline=None, settable=None, id=None, templateparamlist=None, type_=None, definition='', argsstring='', name='', read='', write='', bitfield='', reimplements=None, reimplementedby=None, param=None, enumvalue=None, initializer=None, exceptions=None, briefdescription=None, detaileddescription=None, inbodydescription=None, location=None, references=None, referencedby=None):
-        supermod.memberdefType.__init__(self, initonly, kind, volatile, const, raise_, virt, readable, prot, explicit, new, final, writable, add, static, remove, sealed, mutable, gettable, inline, settable, id, templateparamlist, type_, definition, argsstring, name, read, write, bitfield, reimplements, reimplementedby, param, enumvalue, initializer, exceptions, briefdescription, detaileddescription, inbodydescription, location, references, referencedby)
+        supermod.memberdefType.__init__(self, initonly, kind, volatile, const, raise_, virt, readable, prot, explicit, new, final, writable, add, static, remove, sealed, mutable, gettable, inline, settable, id, templateparamlist, type_,
+                                        definition, argsstring, name, read, write, bitfield, reimplements, reimplementedby, param, enumvalue, initializer, exceptions, briefdescription, detaileddescription, inbodydescription, location, references, referencedby)
+
+
 supermod.memberdefType.subclass = memberdefTypeSub
 # end class memberdefTypeSub
 
@@ -126,6 +143,8 @@ supermod.memberdefType.subclass = memberdefTypeSub
 class descriptionTypeSub(supermod.descriptionType):
     def __init__(self, title='', para=None, sect1=None, internal=None, mixedclass_=None, content_=None):
         supermod.descriptionType.__init__(self, mixedclass_, content_)
+
+
 supermod.descriptionType.subclass = descriptionTypeSub
 # end class descriptionTypeSub
 
@@ -133,6 +152,8 @@ supermod.descriptionType.subclass = descriptionTypeSub
 class enumvalueTypeSub(supermod.enumvalueType):
     def __init__(self, prot=None, id=None, name='', initializer=None, briefdescription=None, detaileddescription=None, mixedclass_=None, content_=None):
         supermod.enumvalueType.__init__(self, mixedclass_, content_)
+
+
 supermod.enumvalueType.subclass = enumvalueTypeSub
 # end class enumvalueTypeSub
 
@@ -140,13 +161,18 @@ supermod.enumvalueType.subclass = enumvalueTypeSub
 class templateparamlistTypeSub(supermod.templateparamlistType):
     def __init__(self, param=None):
         supermod.templateparamlistType.__init__(self, param)
+
+
 supermod.templateparamlistType.subclass = templateparamlistTypeSub
 # end class templateparamlistTypeSub
 
 
 class paramTypeSub(supermod.paramType):
     def __init__(self, type_=None, declname='', defname='', array='', defval=None, briefdescription=None):
-        supermod.paramType.__init__(self, type_, declname, defname, array, defval, briefdescription)
+        supermod.paramType.__init__(
+            self, type_, declname, defname, array, defval, briefdescription)
+
+
 supermod.paramType.subclass = paramTypeSub
 # end class paramTypeSub
 
@@ -154,6 +180,8 @@ supermod.paramType.subclass = paramTypeSub
 class linkedTextTypeSub(supermod.linkedTextType):
     def __init__(self, ref=None, mixedclass_=None, content_=None):
         supermod.linkedTextType.__init__(self, mixedclass_, content_)
+
+
 supermod.linkedTextType.subclass = linkedTextTypeSub
 # end class linkedTextTypeSub
 
@@ -161,6 +189,8 @@ supermod.linkedTextType.subclass = linkedTextTypeSub
 class graphTypeSub(supermod.graphType):
     def __init__(self, node=None):
         supermod.graphType.__init__(self, node)
+
+
 supermod.graphType.subclass = graphTypeSub
 # end class graphTypeSub
 
@@ -168,6 +198,8 @@ supermod.graphType.subclass = graphTypeSub
 class nodeTypeSub(supermod.nodeType):
     def __init__(self, id=None, label='', link=None, childnode=None):
         supermod.nodeType.__init__(self, id, label, link, childnode)
+
+
 supermod.nodeType.subclass = nodeTypeSub
 # end class nodeTypeSub
 
@@ -175,6 +207,8 @@ supermod.nodeType.subclass = nodeTypeSub
 class childnodeTypeSub(supermod.childnodeType):
     def __init__(self, relation=None, refid=None, edgelabel=None):
         supermod.childnodeType.__init__(self, relation, refid, edgelabel)
+
+
 supermod.childnodeType.subclass = childnodeTypeSub
 # end class childnodeTypeSub
 
@@ -182,6 +216,8 @@ supermod.childnodeType.subclass = childnodeTypeSub
 class linkTypeSub(supermod.linkType):
     def __init__(self, refid=None, external=None, valueOf_=''):
         supermod.linkType.__init__(self, refid, external)
+
+
 supermod.linkType.subclass = linkTypeSub
 # end class linkTypeSub
 
@@ -189,13 +225,18 @@ supermod.linkType.subclass = linkTypeSub
 class listingTypeSub(supermod.listingType):
     def __init__(self, codeline=None):
         supermod.listingType.__init__(self, codeline)
+
+
 supermod.listingType.subclass = listingTypeSub
 # end class listingTypeSub
 
 
 class codelineTypeSub(supermod.codelineType):
     def __init__(self, external=None, lineno=None, refkind=None, refid=None, highlight=None):
-        supermod.codelineType.__init__(self, external, lineno, refkind, refid, highlight)
+        supermod.codelineType.__init__(
+            self, external, lineno, refkind, refid, highlight)
+
+
 supermod.codelineType.subclass = codelineTypeSub
 # end class codelineTypeSub
 
@@ -203,6 +244,8 @@ supermod.codelineType.subclass = codelineTypeSub
 class highlightTypeSub(supermod.highlightType):
     def __init__(self, class_=None, sp=None, ref=None, mixedclass_=None, content_=None):
         supermod.highlightType.__init__(self, mixedclass_, content_)
+
+
 supermod.highlightType.subclass = highlightTypeSub
 # end class highlightTypeSub
 
@@ -210,13 +253,18 @@ supermod.highlightType.subclass = highlightTypeSub
 class referenceTypeSub(supermod.referenceType):
     def __init__(self, endline=None, startline=None, refid=None, compoundref=None, valueOf_='', mixedclass_=None, content_=None):
         supermod.referenceType.__init__(self, mixedclass_, content_)
+
+
 supermod.referenceType.subclass = referenceTypeSub
 # end class referenceTypeSub
 
 
 class locationTypeSub(supermod.locationType):
     def __init__(self, bodystart=None, line=None, bodyend=None, bodyfile=None, file=None, valueOf_=''):
-        supermod.locationType.__init__(self, bodystart, line, bodyend, bodyfile, file)
+        supermod.locationType.__init__(
+            self, bodystart, line, bodyend, bodyfile, file)
+
+
 supermod.locationType.subclass = locationTypeSub
 # end class locationTypeSub
 
@@ -224,6 +272,8 @@ supermod.locationType.subclass = locationTypeSub
 class docSect1TypeSub(supermod.docSect1Type):
     def __init__(self, id=None, title='', para=None, sect2=None, internal=None, mixedclass_=None, content_=None):
         supermod.docSect1Type.__init__(self, mixedclass_, content_)
+
+
 supermod.docSect1Type.subclass = docSect1TypeSub
 # end class docSect1TypeSub
 
@@ -231,6 +281,8 @@ supermod.docSect1Type.subclass = docSect1TypeSub
 class docSect2TypeSub(supermod.docSect2Type):
     def __init__(self, id=None, title='', para=None, sect3=None, internal=None, mixedclass_=None, content_=None):
         supermod.docSect2Type.__init__(self, mixedclass_, content_)
+
+
 supermod.docSect2Type.subclass = docSect2TypeSub
 # end class docSect2TypeSub
 
@@ -238,6 +290,8 @@ supermod.docSect2Type.subclass = docSect2TypeSub
 class docSect3TypeSub(supermod.docSect3Type):
     def __init__(self, id=None, title='', para=None, sect4=None, internal=None, mixedclass_=None, content_=None):
         supermod.docSect3Type.__init__(self, mixedclass_, content_)
+
+
 supermod.docSect3Type.subclass = docSect3TypeSub
 # end class docSect3TypeSub
 
@@ -245,6 +299,8 @@ supermod.docSect3Type.subclass = docSect3TypeSub
 class docSect4TypeSub(supermod.docSect4Type):
     def __init__(self, id=None, title='', para=None, internal=None, mixedclass_=None, content_=None):
         supermod.docSect4Type.__init__(self, mixedclass_, content_)
+
+
 supermod.docSect4Type.subclass = docSect4TypeSub
 # end class docSect4TypeSub
 
@@ -252,6 +308,8 @@ supermod.docSect4Type.subclass = docSect4TypeSub
 class docInternalTypeSub(supermod.docInternalType):
     def __init__(self, para=None, sect1=None, mixedclass_=None, content_=None):
         supermod.docInternalType.__init__(self, mixedclass_, content_)
+
+
 supermod.docInternalType.subclass = docInternalTypeSub
 # end class docInternalTypeSub
 
@@ -259,6 +317,8 @@ supermod.docInternalType.subclass = docInternalTypeSub
 class docInternalS1TypeSub(supermod.docInternalS1Type):
     def __init__(self, para=None, sect2=None, mixedclass_=None, content_=None):
         supermod.docInternalS1Type.__init__(self, mixedclass_, content_)
+
+
 supermod.docInternalS1Type.subclass = docInternalS1TypeSub
 # end class docInternalS1TypeSub
 
@@ -266,6 +326,8 @@ supermod.docInternalS1Type.subclass = docInternalS1TypeSub
 class docInternalS2TypeSub(supermod.docInternalS2Type):
     def __init__(self, para=None, sect3=None, mixedclass_=None, content_=None):
         supermod.docInternalS2Type.__init__(self, mixedclass_, content_)
+
+
 supermod.docInternalS2Type.subclass = docInternalS2TypeSub
 # end class docInternalS2TypeSub
 
@@ -273,6 +335,8 @@ supermod.docInternalS2Type.subclass = docInternalS2TypeSub
 class docInternalS3TypeSub(supermod.docInternalS3Type):
     def __init__(self, para=None, sect3=None, mixedclass_=None, content_=None):
         supermod.docInternalS3Type.__init__(self, mixedclass_, content_)
+
+
 supermod.docInternalS3Type.subclass = docInternalS3TypeSub
 # end class docInternalS3TypeSub
 
@@ -280,6 +344,8 @@ supermod.docInternalS3Type.subclass = docInternalS3TypeSub
 class docInternalS4TypeSub(supermod.docInternalS4Type):
     def __init__(self, para=None, mixedclass_=None, content_=None):
         supermod.docInternalS4Type.__init__(self, mixedclass_, content_)
+
+
 supermod.docInternalS4Type.subclass = docInternalS4TypeSub
 # end class docInternalS4TypeSub
 
@@ -287,6 +353,8 @@ supermod.docInternalS4Type.subclass = docInternalS4TypeSub
 class docURLLinkSub(supermod.docURLLink):
     def __init__(self, url=None, valueOf_='', mixedclass_=None, content_=None):
         supermod.docURLLink.__init__(self, mixedclass_, content_)
+
+
 supermod.docURLLink.subclass = docURLLinkSub
 # end class docURLLinkSub
 
@@ -294,6 +362,8 @@ supermod.docURLLink.subclass = docURLLinkSub
 class docAnchorTypeSub(supermod.docAnchorType):
     def __init__(self, id=None, valueOf_='', mixedclass_=None, content_=None):
         supermod.docAnchorType.__init__(self, mixedclass_, content_)
+
+
 supermod.docAnchorType.subclass = docAnchorTypeSub
 # end class docAnchorTypeSub
 
@@ -301,6 +371,8 @@ supermod.docAnchorType.subclass = docAnchorTypeSub
 class docFormulaTypeSub(supermod.docFormulaType):
     def __init__(self, id=None, valueOf_='', mixedclass_=None, content_=None):
         supermod.docFormulaType.__init__(self, mixedclass_, content_)
+
+
 supermod.docFormulaType.subclass = docFormulaTypeSub
 # end class docFormulaTypeSub
 
@@ -308,6 +380,8 @@ supermod.docFormulaType.subclass = docFormulaTypeSub
 class docIndexEntryTypeSub(supermod.docIndexEntryType):
     def __init__(self, primaryie='', secondaryie=''):
         supermod.docIndexEntryType.__init__(self, primaryie, secondaryie)
+
+
 supermod.docIndexEntryType.subclass = docIndexEntryTypeSub
 # end class docIndexEntryTypeSub
 
@@ -315,6 +389,8 @@ supermod.docIndexEntryType.subclass = docIndexEntryTypeSub
 class docListTypeSub(supermod.docListType):
     def __init__(self, listitem=None):
         supermod.docListType.__init__(self, listitem)
+
+
 supermod.docListType.subclass = docListTypeSub
 # end class docListTypeSub
 
@@ -322,6 +398,8 @@ supermod.docListType.subclass = docListTypeSub
 class docListItemTypeSub(supermod.docListItemType):
     def __init__(self, para=None):
         supermod.docListItemType.__init__(self, para)
+
+
 supermod.docListItemType.subclass = docListItemTypeSub
 # end class docListItemTypeSub
 
@@ -329,6 +407,8 @@ supermod.docListItemType.subclass = docListItemTypeSub
 class docSimpleSectTypeSub(supermod.docSimpleSectType):
     def __init__(self, kind=None, title=None, para=None):
         supermod.docSimpleSectType.__init__(self, kind, title, para)
+
+
 supermod.docSimpleSectType.subclass = docSimpleSectTypeSub
 # end class docSimpleSectTypeSub
 
@@ -336,6 +416,8 @@ supermod.docSimpleSectType.subclass = docSimpleSectTypeSub
 class docVarListEntryTypeSub(supermod.docVarListEntryType):
     def __init__(self, term=None):
         supermod.docVarListEntryType.__init__(self, term)
+
+
 supermod.docVarListEntryType.subclass = docVarListEntryTypeSub
 # end class docVarListEntryTypeSub
 
@@ -343,6 +425,8 @@ supermod.docVarListEntryType.subclass = docVarListEntryTypeSub
 class docRefTextTypeSub(supermod.docRefTextType):
     def __init__(self, refid=None, kindref=None, external=None, valueOf_='', mixedclass_=None, content_=None):
         supermod.docRefTextType.__init__(self, mixedclass_, content_)
+
+
 supermod.docRefTextType.subclass = docRefTextTypeSub
 # end class docRefTextTypeSub
 
@@ -350,6 +434,8 @@ supermod.docRefTextType.subclass = docRefTextTypeSub
 class docTableTypeSub(supermod.docTableType):
     def __init__(self, rows=None, cols=None, row=None, caption=None):
         supermod.docTableType.__init__(self, rows, cols, row, caption)
+
+
 supermod.docTableType.subclass = docTableTypeSub
 # end class docTableTypeSub
 
@@ -357,6 +443,8 @@ supermod.docTableType.subclass = docTableTypeSub
 class docRowTypeSub(supermod.docRowType):
     def __init__(self, entry=None):
         supermod.docRowType.__init__(self, entry)
+
+
 supermod.docRowType.subclass = docRowTypeSub
 # end class docRowTypeSub
 
@@ -364,6 +452,8 @@ supermod.docRowType.subclass = docRowTypeSub
 class docEntryTypeSub(supermod.docEntryType):
     def __init__(self, thead=None, para=None):
         supermod.docEntryType.__init__(self, thead, para)
+
+
 supermod.docEntryType.subclass = docEntryTypeSub
 # end class docEntryTypeSub
 
@@ -371,6 +461,8 @@ supermod.docEntryType.subclass = docEntryTypeSub
 class docHeadingTypeSub(supermod.docHeadingType):
     def __init__(self, level=None, valueOf_='', mixedclass_=None, content_=None):
         supermod.docHeadingType.__init__(self, mixedclass_, content_)
+
+
 supermod.docHeadingType.subclass = docHeadingTypeSub
 # end class docHeadingTypeSub
 
@@ -378,6 +470,8 @@ supermod.docHeadingType.subclass = docHeadingTypeSub
 class docImageTypeSub(supermod.docImageType):
     def __init__(self, width=None, type_=None, name=None, height=None, valueOf_='', mixedclass_=None, content_=None):
         supermod.docImageType.__init__(self, mixedclass_, content_)
+
+
 supermod.docImageType.subclass = docImageTypeSub
 # end class docImageTypeSub
 
@@ -385,6 +479,8 @@ supermod.docImageType.subclass = docImageTypeSub
 class docDotFileTypeSub(supermod.docDotFileType):
     def __init__(self, name=None, valueOf_='', mixedclass_=None, content_=None):
         supermod.docDotFileType.__init__(self, mixedclass_, content_)
+
+
 supermod.docDotFileType.subclass = docDotFileTypeSub
 # end class docDotFileTypeSub
 
@@ -392,6 +488,8 @@ supermod.docDotFileType.subclass = docDotFileTypeSub
 class docTocItemTypeSub(supermod.docTocItemType):
     def __init__(self, id=None, valueOf_='', mixedclass_=None, content_=None):
         supermod.docTocItemType.__init__(self, mixedclass_, content_)
+
+
 supermod.docTocItemType.subclass = docTocItemTypeSub
 # end class docTocItemTypeSub
 
@@ -399,6 +497,8 @@ supermod.docTocItemType.subclass = docTocItemTypeSub
 class docTocListTypeSub(supermod.docTocListType):
     def __init__(self, tocitem=None):
         supermod.docTocListType.__init__(self, tocitem)
+
+
 supermod.docTocListType.subclass = docTocListTypeSub
 # end class docTocListTypeSub
 
@@ -406,6 +506,8 @@ supermod.docTocListType.subclass = docTocListTypeSub
 class docLanguageTypeSub(supermod.docLanguageType):
     def __init__(self, langid=None, para=None):
         supermod.docLanguageType.__init__(self, langid, para)
+
+
 supermod.docLanguageType.subclass = docLanguageTypeSub
 # end class docLanguageTypeSub
 
@@ -413,13 +515,18 @@ supermod.docLanguageType.subclass = docLanguageTypeSub
 class docParamListTypeSub(supermod.docParamListType):
     def __init__(self, kind=None, parameteritem=None):
         supermod.docParamListType.__init__(self, kind, parameteritem)
+
+
 supermod.docParamListType.subclass = docParamListTypeSub
 # end class docParamListTypeSub
 
 
 class docParamListItemSub(supermod.docParamListItem):
     def __init__(self, parameternamelist=None, parameterdescription=None):
-        supermod.docParamListItem.__init__(self, parameternamelist, parameterdescription)
+        supermod.docParamListItem.__init__(
+            self, parameternamelist, parameterdescription)
+
+
 supermod.docParamListItem.subclass = docParamListItemSub
 # end class docParamListItemSub
 
@@ -427,6 +534,8 @@ supermod.docParamListItem.subclass = docParamListItemSub
 class docParamNameListSub(supermod.docParamNameList):
     def __init__(self, parametername=None):
         supermod.docParamNameList.__init__(self, parametername)
+
+
 supermod.docParamNameList.subclass = docParamNameListSub
 # end class docParamNameListSub
 
@@ -434,6 +543,8 @@ supermod.docParamNameList.subclass = docParamNameListSub
 class docParamNameSub(supermod.docParamName):
     def __init__(self, direction=None, ref=None, mixedclass_=None, content_=None):
         supermod.docParamName.__init__(self, mixedclass_, content_)
+
+
 supermod.docParamName.subclass = docParamNameSub
 # end class docParamNameSub
 
@@ -441,6 +552,8 @@ supermod.docParamName.subclass = docParamNameSub
 class docXRefSectTypeSub(supermod.docXRefSectType):
     def __init__(self, id=None, xreftitle=None, xrefdescription=None):
         supermod.docXRefSectType.__init__(self, id, xreftitle, xrefdescription)
+
+
 supermod.docXRefSectType.subclass = docXRefSectTypeSub
 # end class docXRefSectTypeSub
 
@@ -448,6 +561,8 @@ supermod.docXRefSectType.subclass = docXRefSectTypeSub
 class docCopyTypeSub(supermod.docCopyType):
     def __init__(self, link=None, para=None, sect1=None, internal=None):
         supermod.docCopyType.__init__(self, link, para, sect1, internal)
+
+
 supermod.docCopyType.subclass = docCopyTypeSub
 # end class docCopyTypeSub
 
@@ -455,9 +570,12 @@ supermod.docCopyType.subclass = docCopyTypeSub
 class docCharTypeSub(supermod.docCharType):
     def __init__(self, char=None, valueOf_=''):
         supermod.docCharType.__init__(self, char)
+
+
 supermod.docCharType.subclass = docCharTypeSub
 # end class docCharTypeSub
 
+
 class docParaTypeSub(supermod.docParaType):
     def __init__(self, char=None, valueOf_=''):
         supermod.docParaType.__init__(self, char)
@@ -471,7 +589,7 @@ class docParaTypeSub(supermod.docParaType):
 
         if child_.nodeType == Node.TEXT_NODE:
             obj_ = self.mixedclass_(MixedContainer.CategoryText,
-                MixedContainer.TypeNone, '', child_.nodeValue)
+                                    MixedContainer.TypeNone, '', child_.nodeValue)
             self.content.append(obj_)
         elif child_.nodeType == Node.ELEMENT_NODE and \
                 nodeName_ == "ref":
@@ -494,12 +612,9 @@ supermod.docParaType.subclass = docParaTypeSub
 # end class docParaTypeSub
 
 
-
 def parse(inFilename):
     doc = minidom.parse(inFilename)
     rootNode = doc.documentElement
     rootObj = supermod.DoxygenType.factory()
     rootObj.build(rootNode)
     return rootObj
-
-
diff --git a/docs/doxygen/doxyxml/generated/compoundsuper.py b/docs/doxygen/doxyxml/generated/compoundsuper.py
index 6e984e1..40f548a 100644
--- a/docs/doxygen/doxyxml/generated/compoundsuper.py
+++ b/docs/doxygen/doxyxml/generated/compoundsuper.py
@@ -4,17 +4,12 @@
 # Generated Thu Jun 11 18:44:25 2009 by generateDS.py.
 #
 
-from __future__ import print_function
-from __future__ import unicode_literals
 
 import sys
 
 from xml.dom import minidom
 from xml.dom import Node
 
-import six
-
-
 #
 # User methods
 #
@@ -29,12 +24,16 @@ except ImportError as exp:
     class GeneratedsSuper(object):
         def format_string(self, input_data, input_name=''):
             return input_data
+
         def format_integer(self, input_data, input_name=''):
             return '%d' % input_data
+
         def format_float(self, input_data, input_name=''):
             return '%f' % input_data
+
         def format_double(self, input_data, input_name=''):
             return '%e' % input_data
+
         def format_boolean(self, input_data, input_name=''):
             return '%s' % input_data
 
@@ -46,9 +45,9 @@ except ImportError as exp:
 
 ## from IPython.Shell import IPShellEmbed
 ## args = ''
-## ipshell = IPShellEmbed(args,
+# ipshell = IPShellEmbed(args,
 ##     banner = 'Dropping into IPython',
-##     exit_msg = 'Leaving Interpreter, back to program.')
+# exit_msg = 'Leaving Interpreter, back to program.')
 
 # Then use the following line where and when you want to drop into the
 # IPython shell:
@@ -64,20 +63,23 @@ ExternalEncoding = 'ascii'
 # Support/utility functions.
 #
 
+
 def showIndent(outfile, level):
     for idx in range(level):
         outfile.write('    ')
 
+
 def quote_xml(inStr):
-    s1 = (isinstance(inStr, six.string_types) and inStr or
+    s1 = (isinstance(inStr, str) and inStr or
           '%s' % inStr)
     s1 = s1.replace('&', '&amp;')
     s1 = s1.replace('<', '&lt;')
     s1 = s1.replace('>', '&gt;')
     return s1
 
+
 def quote_attrib(inStr):
-    s1 = (isinstance(inStr, six.string_types) and inStr or
+    s1 = (isinstance(inStr, str) and inStr or
           '%s' % inStr)
     s1 = s1.replace('&', '&amp;')
     s1 = s1.replace('<', '&lt;')
@@ -91,6 +93,7 @@ def quote_attrib(inStr):
         s1 = '"%s"' % s1
     return s1
 
+
 def quote_python(inStr):
     s1 = inStr
     if s1.find("'") == -1:
@@ -122,26 +125,33 @@ class MixedContainer(object):
     TypeDecimal = 5
     TypeDouble = 6
     TypeBoolean = 7
+
     def __init__(self, category, content_type, name, value):
         self.category = category
         self.content_type = content_type
         self.name = name
         self.value = value
+
     def getCategory(self):
         return self.category
+
     def getContenttype(self, content_type):
         return self.content_type
+
     def getValue(self):
         return self.value
+
     def getName(self):
         return self.name
+
     def export(self, outfile, level, name, namespace):
         if self.category == MixedContainer.CategoryText:
             outfile.write(self.value)
         elif self.category == MixedContainer.CategorySimple:
             self.exportSimple(outfile, level, name)
         else:    # category == MixedContainer.CategoryComplex
-            self.value.export(outfile, level, namespace,name)
+            self.value.export(outfile, level, namespace, name)
+
     def exportSimple(self, outfile, level, name):
         if self.content_type == MixedContainer.TypeString:
             outfile.write('<%s>%s</%s>' % (self.name, self.value, self.name))
@@ -153,19 +163,20 @@ class MixedContainer(object):
             outfile.write('<%s>%f</%s>' % (self.name, self.value, self.name))
         elif self.content_type == MixedContainer.TypeDouble:
             outfile.write('<%s>%g</%s>' % (self.name, self.value, self.name))
+
     def exportLiteral(self, outfile, level, name):
         if self.category == MixedContainer.CategoryText:
             showIndent(outfile, level)
-            outfile.write('MixedContainer(%d, %d, "%s", "%s"),\n' % \
-                (self.category, self.content_type, self.name, self.value))
+            outfile.write('MixedContainer(%d, %d, "%s", "%s"),\n' %
+                          (self.category, self.content_type, self.name, self.value))
         elif self.category == MixedContainer.CategorySimple:
             showIndent(outfile, level)
-            outfile.write('MixedContainer(%d, %d, "%s", "%s"),\n' % \
-                (self.category, self.content_type, self.name, self.value))
+            outfile.write('MixedContainer(%d, %d, "%s", "%s"),\n' %
+                          (self.category, self.content_type, self.name, self.value))
         else:    # category == MixedContainer.CategoryComplex
             showIndent(outfile, level)
-            outfile.write('MixedContainer(%d, %d, "%s",\n' % \
-                (self.category, self.content_type, self.name,))
+            outfile.write('MixedContainer(%d, %d, "%s",\n' %
+                          (self.category, self.content_type, self.name,))
             self.value.exportLiteral(outfile, level + 1)
             showIndent(outfile, level)
             outfile.write(')\n')
@@ -176,6 +187,7 @@ class _MemberSpec(object):
         self.name = name
         self.data_type = data_type
         self.container = container
+
     def set_name(self, name): self.name = name
     def get_name(self): return self.name
     def set_data_type(self, data_type): self.data_type = data_type
@@ -191,9 +203,11 @@ class _MemberSpec(object):
 class DoxygenType(GeneratedsSuper):
     subclass = None
     superclass = None
+
     def __init__(self, version=None, compounddef=None):
         self.version = version
         self.compounddef = compounddef
+
     def factory(*args_, **kwargs_):
         if DoxygenType.subclass:
             return DoxygenType.subclass(*args_, **kwargs_)
@@ -204,6 +218,7 @@ class DoxygenType(GeneratedsSuper):
     def set_compounddef(self, compounddef): self.compounddef = compounddef
     def get_version(self): return self.version
     def set_version(self, version): self.version = version
+
     def export(self, outfile, level, namespace_='', name_='DoxygenType', namespacedef_=''):
         showIndent(outfile, level)
         outfile.write('<%s%s %s' % (namespace_, name_, namespacedef_, ))
@@ -215,27 +230,34 @@ class DoxygenType(GeneratedsSuper):
             outfile.write('</%s%s>\n' % (namespace_, name_))
         else:
             outfile.write(' />\n')
+
     def exportAttributes(self, outfile, level, namespace_='', name_='DoxygenType'):
         outfile.write(' version=%s' % (quote_attrib(self.version), ))
+
     def exportChildren(self, outfile, level, namespace_='', name_='DoxygenType'):
         if self.compounddef:
-            self.compounddef.export(outfile, level, namespace_, name_='compounddef')
+            self.compounddef.export(
+                outfile, level, namespace_, name_='compounddef')
+
     def hasContent_(self):
         if (
             self.compounddef is not None
-            ):
+        ):
             return True
         else:
             return False
+
     def exportLiteral(self, outfile, level, name_='DoxygenType'):
         level += 1
         self.exportLiteralAttributes(outfile, level, name_)
         if self.hasContent_():
             self.exportLiteralChildren(outfile, level, name_)
+
     def exportLiteralAttributes(self, outfile, level, name_):
         if self.version is not None:
             showIndent(outfile, level)
             outfile.write('version = "%s",\n' % (self.version,))
+
     def exportLiteralChildren(self, outfile, level, name_):
         if self.compounddef:
             showIndent(outfile, level)
@@ -243,18 +265,21 @@ class DoxygenType(GeneratedsSuper):
             self.compounddef.exportLiteral(outfile, level, name_='compounddef')
             showIndent(outfile, level)
             outfile.write('),\n')
+
     def build(self, node_):
         attrs = node_.attributes
         self.buildAttributes(attrs)
         for child_ in node_.childNodes:
             nodeName_ = child_.nodeName.split(':')[-1]
             self.buildChildren(child_, nodeName_)
+
     def buildAttributes(self, attrs):
         if attrs.get('version'):
             self.version = attrs.get('version').value
+
     def buildChildren(self, child_, nodeName_):
         if child_.nodeType == Node.ELEMENT_NODE and \
-            nodeName_ == 'compounddef':
+                nodeName_ == 'compounddef':
             obj_ = compounddefType.factory()
             obj_.build(child_)
             self.set_compounddef(obj_)
@@ -264,6 +289,7 @@ class DoxygenType(GeneratedsSuper):
 class compounddefType(GeneratedsSuper):
     subclass = None
     superclass = None
+
     def __init__(self, kind=None, prot=None, id=None, compoundname=None, title=None, basecompoundref=None, derivedcompoundref=None, includes=None, includedby=None, incdepgraph=None, invincdepgraph=None, innerdir=None, innerfile=None, innerclass=None, innernamespace=None, innerpage=None, innergroup=None, templateparamlist=None, sectiondef=None, briefdescription=None, detaileddescription=None, inheritancegraph=None, collaborationgraph=None, programlisting=None, location=None, listofallmembers=None):
         self.kind = kind
         self.prot = prot
@@ -324,6 +350,7 @@ class compounddefType(GeneratedsSuper):
         self.programlisting = programlisting
         self.location = location
         self.listofallmembers = listofallmembers
+
     def factory(*args_, **kwargs_):
         if compounddefType.subclass:
             return compounddefType.subclass(*args_, **kwargs_)
@@ -335,13 +362,23 @@ class compounddefType(GeneratedsSuper):
     def get_title(self): return self.title
     def set_title(self, title): self.title = title
     def get_basecompoundref(self): return self.basecompoundref
-    def set_basecompoundref(self, basecompoundref): self.basecompoundref = basecompoundref
+    def set_basecompoundref(
+        self, basecompoundref): self.basecompoundref = basecompoundref
+
     def add_basecompoundref(self, value): self.basecompoundref.append(value)
-    def insert_basecompoundref(self, index, value): self.basecompoundref[index] = value
+    def insert_basecompoundref(
+        self, index, value): self.basecompoundref[index] = value
+
     def get_derivedcompoundref(self): return self.derivedcompoundref
-    def set_derivedcompoundref(self, derivedcompoundref): self.derivedcompoundref = derivedcompoundref
-    def add_derivedcompoundref(self, value): self.derivedcompoundref.append(value)
-    def insert_derivedcompoundref(self, index, value): self.derivedcompoundref[index] = value
+
+    def set_derivedcompoundref(
+        self, derivedcompoundref): self.derivedcompoundref = derivedcompoundref
+
+    def add_derivedcompoundref(
+        self, value): self.derivedcompoundref.append(value)
+    def insert_derivedcompoundref(
+        self, index, value): self.derivedcompoundref[index] = value
+
     def get_includes(self): return self.includes
     def set_includes(self, includes): self.includes = includes
     def add_includes(self, value): self.includes.append(value)
@@ -353,7 +390,9 @@ class compounddefType(GeneratedsSuper):
     def get_incdepgraph(self): return self.incdepgraph
     def set_incdepgraph(self, incdepgraph): self.incdepgraph = incdepgraph
     def get_invincdepgraph(self): return self.invincdepgraph
-    def set_invincdepgraph(self, invincdepgraph): self.invincdepgraph = invincdepgraph
+    def set_invincdepgraph(
+        self, invincdepgraph): self.invincdepgraph = invincdepgraph
+
     def get_innerdir(self): return self.innerdir
     def set_innerdir(self, innerdir): self.innerdir = innerdir
     def add_innerdir(self, value): self.innerdir.append(value)
@@ -367,9 +406,13 @@ class compounddefType(GeneratedsSuper):
     def add_innerclass(self, value): self.innerclass.append(value)
     def insert_innerclass(self, index, value): self.innerclass[index] = value
     def get_innernamespace(self): return self.innernamespace
-    def set_innernamespace(self, innernamespace): self.innernamespace = innernamespace
+    def set_innernamespace(
+        self, innernamespace): self.innernamespace = innernamespace
+
     def add_innernamespace(self, value): self.innernamespace.append(value)
-    def insert_innernamespace(self, index, value): self.innernamespace[index] = value
+    def insert_innernamespace(
+        self, index, value): self.innernamespace[index] = value
+
     def get_innerpage(self): return self.innerpage
     def set_innerpage(self, innerpage): self.innerpage = innerpage
     def add_innerpage(self, value): self.innerpage.append(value)
@@ -379,35 +422,51 @@ class compounddefType(GeneratedsSuper):
     def add_innergroup(self, value): self.innergroup.append(value)
     def insert_innergroup(self, index, value): self.innergroup[index] = value
     def get_templateparamlist(self): return self.templateparamlist
-    def set_templateparamlist(self, templateparamlist): self.templateparamlist = templateparamlist
+    def set_templateparamlist(
+        self, templateparamlist): self.templateparamlist = templateparamlist
+
     def get_sectiondef(self): return self.sectiondef
     def set_sectiondef(self, sectiondef): self.sectiondef = sectiondef
     def add_sectiondef(self, value): self.sectiondef.append(value)
     def insert_sectiondef(self, index, value): self.sectiondef[index] = value
     def get_briefdescription(self): return self.briefdescription
-    def set_briefdescription(self, briefdescription): self.briefdescription = briefdescription
+    def set_briefdescription(
+        self, briefdescription): self.briefdescription = briefdescription
+
     def get_detaileddescription(self): return self.detaileddescription
-    def set_detaileddescription(self, detaileddescription): self.detaileddescription = detaileddescription
+    def set_detaileddescription(
+        self, detaileddescription): self.detaileddescription = detaileddescription
+
     def get_inheritancegraph(self): return self.inheritancegraph
-    def set_inheritancegraph(self, inheritancegraph): self.inheritancegraph = inheritancegraph
+    def set_inheritancegraph(
+        self, inheritancegraph): self.inheritancegraph = inheritancegraph
+
     def get_collaborationgraph(self): return self.collaborationgraph
-    def set_collaborationgraph(self, collaborationgraph): self.collaborationgraph = collaborationgraph
+    def set_collaborationgraph(
+        self, collaborationgraph): self.collaborationgraph = collaborationgraph
+
     def get_programlisting(self): return self.programlisting
-    def set_programlisting(self, programlisting): self.programlisting = programlisting
+    def set_programlisting(
+        self, programlisting): self.programlisting = programlisting
+
     def get_location(self): return self.location
     def set_location(self, location): self.location = location
     def get_listofallmembers(self): return self.listofallmembers
-    def set_listofallmembers(self, listofallmembers): self.listofallmembers = listofallmembers
+    def set_listofallmembers(
+        self, listofallmembers): self.listofallmembers = listofallmembers
+
     def get_kind(self): return self.kind
     def set_kind(self, kind): self.kind = kind
     def get_prot(self): return self.prot
     def set_prot(self, prot): self.prot = prot
     def get_id(self): return self.id
     def set_id(self, id): self.id = id
+
     def export(self, outfile, level, namespace_='', name_='compounddefType', namespacedef_=''):
         showIndent(outfile, level)
         outfile.write('<%s%s %s' % (namespace_, name_, namespacedef_, ))
-        self.exportAttributes(outfile, level, namespace_, name_='compounddefType')
+        self.exportAttributes(outfile, level, namespace_,
+                              name_='compounddefType')
         if self.hasContent_():
             outfile.write('>\n')
             self.exportChildren(outfile, level + 1, namespace_, name_)
@@ -415,32 +474,41 @@ class compounddefType(GeneratedsSuper):
             outfile.write('</%s%s>\n' % (namespace_, name_))
         else:
             outfile.write(' />\n')
+
     def exportAttributes(self, outfile, level, namespace_='', name_='compounddefType'):
         if self.kind is not None:
             outfile.write(' kind=%s' % (quote_attrib(self.kind), ))
         if self.prot is not None:
             outfile.write(' prot=%s' % (quote_attrib(self.prot), ))
         if self.id is not None:
-            outfile.write(' id=%s' % (self.format_string(quote_attrib(self.id).encode(ExternalEncoding), input_name='id'), ))
+            outfile.write(' id=%s' % (self.format_string(quote_attrib(
+                self.id).encode(ExternalEncoding), input_name='id'), ))
+
     def exportChildren(self, outfile, level, namespace_='', name_='compounddefType'):
         if self.compoundname is not None:
             showIndent(outfile, level)
-            outfile.write('<%scompoundname>%s</%scompoundname>\n' % (namespace_, self.format_string(quote_xml(self.compoundname).encode(ExternalEncoding), input_name='compoundname'), namespace_))
+            outfile.write('<%scompoundname>%s</%scompoundname>\n' % (namespace_, self.format_string(
+                quote_xml(self.compoundname).encode(ExternalEncoding), input_name='compoundname'), namespace_))
         if self.title is not None:
             showIndent(outfile, level)
-            outfile.write('<%stitle>%s</%stitle>\n' % (namespace_, self.format_string(quote_xml(self.title).encode(ExternalEncoding), input_name='title'), namespace_))
+            outfile.write('<%stitle>%s</%stitle>\n' % (namespace_, self.format_string(
+                quote_xml(self.title).encode(ExternalEncoding), input_name='title'), namespace_))
         for basecompoundref_ in self.basecompoundref:
-            basecompoundref_.export(outfile, level, namespace_, name_='basecompoundref')
+            basecompoundref_.export(
+                outfile, level, namespace_, name_='basecompoundref')
         for derivedcompoundref_ in self.derivedcompoundref:
-            derivedcompoundref_.export(outfile, level, namespace_, name_='derivedcompoundref')
+            derivedcompoundref_.export(
+                outfile, level, namespace_, name_='derivedcompoundref')
         for includes_ in self.includes:
             includes_.export(outfile, level, namespace_, name_='includes')
         for includedby_ in self.includedby:
             includedby_.export(outfile, level, namespace_, name_='includedby')
         if self.incdepgraph:
-            self.incdepgraph.export(outfile, level, namespace_, name_='incdepgraph')
+            self.incdepgraph.export(
+                outfile, level, namespace_, name_='incdepgraph')
         if self.invincdepgraph:
-            self.invincdepgraph.export(outfile, level, namespace_, name_='invincdepgraph')
+            self.invincdepgraph.export(
+                outfile, level, namespace_, name_='invincdepgraph')
         for innerdir_ in self.innerdir:
             innerdir_.export(outfile, level, namespace_, name_='innerdir')
         for innerfile_ in self.innerfile:
@@ -448,29 +516,38 @@ class compounddefType(GeneratedsSuper):
         for innerclass_ in self.innerclass:
             innerclass_.export(outfile, level, namespace_, name_='innerclass')
         for innernamespace_ in self.innernamespace:
-            innernamespace_.export(outfile, level, namespace_, name_='innernamespace')
+            innernamespace_.export(
+                outfile, level, namespace_, name_='innernamespace')
         for innerpage_ in self.innerpage:
             innerpage_.export(outfile, level, namespace_, name_='innerpage')
         for innergroup_ in self.innergroup:
             innergroup_.export(outfile, level, namespace_, name_='innergroup')
         if self.templateparamlist:
-            self.templateparamlist.export(outfile, level, namespace_, name_='templateparamlist')
+            self.templateparamlist.export(
+                outfile, level, namespace_, name_='templateparamlist')
         for sectiondef_ in self.sectiondef:
             sectiondef_.export(outfile, level, namespace_, name_='sectiondef')
         if self.briefdescription:
-            self.briefdescription.export(outfile, level, namespace_, name_='briefdescription')
+            self.briefdescription.export(
+                outfile, level, namespace_, name_='briefdescription')
         if self.detaileddescription:
-            self.detaileddescription.export(outfile, level, namespace_, name_='detaileddescription')
+            self.detaileddescription.export(
+                outfile, level, namespace_, name_='detaileddescription')
         if self.inheritancegraph:
-            self.inheritancegraph.export(outfile, level, namespace_, name_='inheritancegraph')
+            self.inheritancegraph.export(
+                outfile, level, namespace_, name_='inheritancegraph')
         if self.collaborationgraph:
-            self.collaborationgraph.export(outfile, level, namespace_, name_='collaborationgraph')
+            self.collaborationgraph.export(
+                outfile, level, namespace_, name_='collaborationgraph')
         if self.programlisting:
-            self.programlisting.export(outfile, level, namespace_, name_='programlisting')
+            self.programlisting.export(
+                outfile, level, namespace_, name_='programlisting')
         if self.location:
             self.location.export(outfile, level, namespace_, name_='location')
         if self.listofallmembers:
-            self.listofallmembers.export(outfile, level, namespace_, name_='listofallmembers')
+            self.listofallmembers.export(
+                outfile, level, namespace_, name_='listofallmembers')
+
     def hasContent_(self):
         if (
             self.compoundname is not None or
@@ -496,15 +573,17 @@ class compounddefType(GeneratedsSuper):
             self.programlisting is not None or
             self.location is not None or
             self.listofallmembers is not None
-            ):
+        ):
             return True
         else:
             return False
+
     def exportLiteral(self, outfile, level, name_='compounddefType'):
         level += 1
         self.exportLiteralAttributes(outfile, level, name_)
         if self.hasContent_():
             self.exportLiteralChildren(outfile, level, name_)
+
     def exportLiteralAttributes(self, outfile, level, name_):
         if self.kind is not None:
             showIndent(outfile, level)
@@ -515,9 +594,11 @@ class compounddefType(GeneratedsSuper):
         if self.id is not None:
             showIndent(outfile, level)
             outfile.write('id = %s,\n' % (self.id,))
+
     def exportLiteralChildren(self, outfile, level, name_):
         showIndent(outfile, level)
-        outfile.write('compoundname=%s,\n' % quote_python(self.compoundname).encode(ExternalEncoding))
+        outfile.write('compoundname=%s,\n' % quote_python(
+            self.compoundname).encode(ExternalEncoding))
         if self.title:
             showIndent(outfile, level)
             outfile.write('title=model_.xsd_string(\n')
@@ -530,7 +611,8 @@ class compounddefType(GeneratedsSuper):
         for basecompoundref in self.basecompoundref:
             showIndent(outfile, level)
             outfile.write('model_.basecompoundref(\n')
-            basecompoundref.exportLiteral(outfile, level, name_='basecompoundref')
+            basecompoundref.exportLiteral(
+                outfile, level, name_='basecompoundref')
             showIndent(outfile, level)
             outfile.write('),\n')
         level -= 1
@@ -542,7 +624,8 @@ class compounddefType(GeneratedsSuper):
         for derivedcompoundref in self.derivedcompoundref:
             showIndent(outfile, level)
             outfile.write('model_.derivedcompoundref(\n')
-            derivedcompoundref.exportLiteral(outfile, level, name_='derivedcompoundref')
+            derivedcompoundref.exportLiteral(
+                outfile, level, name_='derivedcompoundref')
             showIndent(outfile, level)
             outfile.write('),\n')
         level -= 1
@@ -581,7 +664,8 @@ class compounddefType(GeneratedsSuper):
         if self.invincdepgraph:
             showIndent(outfile, level)
             outfile.write('invincdepgraph=model_.graphType(\n')
-            self.invincdepgraph.exportLiteral(outfile, level, name_='invincdepgraph')
+            self.invincdepgraph.exportLiteral(
+                outfile, level, name_='invincdepgraph')
             showIndent(outfile, level)
             outfile.write('),\n')
         showIndent(outfile, level)
@@ -626,7 +710,8 @@ class compounddefType(GeneratedsSuper):
         for innernamespace in self.innernamespace:
             showIndent(outfile, level)
             outfile.write('model_.innernamespace(\n')
-            innernamespace.exportLiteral(outfile, level, name_='innernamespace')
+            innernamespace.exportLiteral(
+                outfile, level, name_='innernamespace')
             showIndent(outfile, level)
             outfile.write('),\n')
         level -= 1
@@ -659,7 +744,8 @@ class compounddefType(GeneratedsSuper):
         if self.templateparamlist:
             showIndent(outfile, level)
             outfile.write('templateparamlist=model_.templateparamlistType(\n')
-            self.templateparamlist.exportLiteral(outfile, level, name_='templateparamlist')
+            self.templateparamlist.exportLiteral(
+                outfile, level, name_='templateparamlist')
             showIndent(outfile, level)
             outfile.write('),\n')
         showIndent(outfile, level)
@@ -677,31 +763,36 @@ class compounddefType(GeneratedsSuper):
         if self.briefdescription:
             showIndent(outfile, level)
             outfile.write('briefdescription=model_.descriptionType(\n')
-            self.briefdescription.exportLiteral(outfile, level, name_='briefdescription')
+            self.briefdescription.exportLiteral(
+                outfile, level, name_='briefdescription')
             showIndent(outfile, level)
             outfile.write('),\n')
         if self.detaileddescription:
             showIndent(outfile, level)
             outfile.write('detaileddescription=model_.descriptionType(\n')
-            self.detaileddescription.exportLiteral(outfile, level, name_='detaileddescription')
+            self.detaileddescription.exportLiteral(
+                outfile, level, name_='detaileddescription')
             showIndent(outfile, level)
             outfile.write('),\n')
         if self.inheritancegraph:
             showIndent(outfile, level)
             outfile.write('inheritancegraph=model_.graphType(\n')
-            self.inheritancegraph.exportLiteral(outfile, level, name_='inheritancegraph')
+            self.inheritancegraph.exportLiteral(
+                outfile, level, name_='inheritancegraph')
             showIndent(outfile, level)
             outfile.write('),\n')
         if self.collaborationgraph:
             showIndent(outfile, level)
             outfile.write('collaborationgraph=model_.graphType(\n')
-            self.collaborationgraph.exportLiteral(outfile, level, name_='collaborationgraph')
+            self.collaborationgraph.exportLiteral(
+                outfile, level, name_='collaborationgraph')
             showIndent(outfile, level)
             outfile.write('),\n')
         if self.programlisting:
             showIndent(outfile, level)
             outfile.write('programlisting=model_.listingType(\n')
-            self.programlisting.exportLiteral(outfile, level, name_='programlisting')
+            self.programlisting.exportLiteral(
+                outfile, level, name_='programlisting')
             showIndent(outfile, level)
             outfile.write('),\n')
         if self.location:
@@ -713,15 +804,18 @@ class compounddefType(GeneratedsSuper):
         if self.listofallmembers:
             showIndent(outfile, level)
             outfile.write('listofallmembers=model_.listofallmembersType(\n')
-            self.listofallmembers.exportLiteral(outfile, level, name_='listofallmembers')
+            self.listofallmembers.exportLiteral(
+                outfile, level, name_='listofallmembers')
             showIndent(outfile, level)
             outfile.write('),\n')
+
     def build(self, node_):
         attrs = node_.attributes
         self.buildAttributes(attrs)
         for child_ in node_.childNodes:
             nodeName_ = child_.nodeName.split(':')[-1]
             self.buildChildren(child_, nodeName_)
+
     def buildAttributes(self, attrs):
         if attrs.get('kind'):
             self.kind = attrs.get('kind').value
@@ -729,120 +823,121 @@ class compounddefType(GeneratedsSuper):
             self.prot = attrs.get('prot').value
         if attrs.get('id'):
             self.id = attrs.get('id').value
+
     def buildChildren(self, child_, nodeName_):
         if child_.nodeType == Node.ELEMENT_NODE and \
-            nodeName_ == 'compoundname':
+                nodeName_ == 'compoundname':
             compoundname_ = ''
             for text__content_ in child_.childNodes:
                 compoundname_ += text__content_.nodeValue
             self.compoundname = compoundname_
         elif child_.nodeType == Node.ELEMENT_NODE and \
-            nodeName_ == 'title':
+                nodeName_ == 'title':
             obj_ = docTitleType.factory()
             obj_.build(child_)
             self.set_title(obj_)
         elif child_.nodeType == Node.ELEMENT_NODE and \
-            nodeName_ == 'basecompoundref':
+                nodeName_ == 'basecompoundref':
             obj_ = compoundRefType.factory()
             obj_.build(child_)
             self.basecompoundref.append(obj_)
         elif child_.nodeType == Node.ELEMENT_NODE and \
-            nodeName_ == 'derivedcompoundref':
+                nodeName_ == 'derivedcompoundref':
             obj_ = compoundRefType.factory()
             obj_.build(child_)
             self.derivedcompoundref.append(obj_)
         elif child_.nodeType == Node.ELEMENT_NODE and \
-            nodeName_ == 'includes':
+                nodeName_ == 'includes':
             obj_ = incType.factory()
             obj_.build(child_)
             self.includes.append(obj_)
         elif child_.nodeType == Node.ELEMENT_NODE and \
-            nodeName_ == 'includedby':
+                nodeName_ == 'includedby':
             obj_ = incType.factory()
             obj_.build(child_)
             self.includedby.append(obj_)
         elif child_.nodeType == Node.ELEMENT_NODE and \
-            nodeName_ == 'incdepgraph':
+                nodeName_ == 'incdepgraph':
             obj_ = graphType.factory()
             obj_.build(child_)
             self.set_incdepgraph(obj_)
         elif child_.nodeType == Node.ELEMENT_NODE and \
-            nodeName_ == 'invincdepgraph':
+                nodeName_ == 'invincdepgraph':
             obj_ = graphType.factory()
             obj_.build(child_)
             self.set_invincdepgraph(obj_)
         elif child_.nodeType == Node.ELEMENT_NODE and \
-            nodeName_ == 'innerdir':
+                nodeName_ == 'innerdir':
             obj_ = refType.factory()
             obj_.build(child_)
             self.innerdir.append(obj_)
         elif child_.nodeType == Node.ELEMENT_NODE and \
-            nodeName_ == 'innerfile':
+                nodeName_ == 'innerfile':
             obj_ = refType.factory()
             obj_.build(child_)
             self.innerfile.append(obj_)
         elif child_.nodeType == Node.ELEMENT_NODE and \
-            nodeName_ == 'innerclass':
+                nodeName_ == 'innerclass':
             obj_ = refType.factory()
             obj_.build(child_)
             self.innerclass.append(obj_)
         elif child_.nodeType == Node.ELEMENT_NODE and \
-            nodeName_ == 'innernamespace':
+                nodeName_ == 'innernamespace':
             obj_ = refType.factory()
             obj_.build(child_)
             self.innernamespace.append(obj_)
         elif child_.nodeType == Node.ELEMENT_NODE and \
-            nodeName_ == 'innerpage':
+                nodeName_ == 'innerpage':
             obj_ = refType.factory()
             obj_.build(child_)
             self.innerpage.append(obj_)
         elif child_.nodeType == Node.ELEMENT_NODE and \
-            nodeName_ == 'innergroup':
+                nodeName_ == 'innergroup':
             obj_ = refType.factory()
             obj_.build(child_)
             self.innergroup.append(obj_)
         elif child_.nodeType == Node.ELEMENT_NODE and \
-            nodeName_ == 'templateparamlist':
+                nodeName_ == 'templateparamlist':
             obj_ = templateparamlistType.factory()
             obj_.build(child_)
             self.set_templateparamlist(obj_)
         elif child_.nodeType == Node.ELEMENT_NODE and \
-            nodeName_ == 'sectiondef':
+                nodeName_ == 'sectiondef':
             obj_ = sectiondefType.factory()
             obj_.build(child_)
             self.sectiondef.append(obj_)
         elif child_.nodeType == Node.ELEMENT_NODE and \
-            nodeName_ == 'briefdescription':
+                nodeName_ == 'briefdescription':
             obj_ = descriptionType.factory()
             obj_.build(child_)
             self.set_briefdescription(obj_)
         elif child_.nodeType == Node.ELEMENT_NODE and \
-            nodeName_ == 'detaileddescription':
+                nodeName_ == 'detaileddescription':
             obj_ = descriptionType.factory()
             obj_.build(child_)
             self.set_detaileddescription(obj_)
         elif child_.nodeType == Node.ELEMENT_NODE and \
-            nodeName_ == 'inheritancegraph':
+                nodeName_ == 'inheritancegraph':
             obj_ = graphType.factory()
             obj_.build(child_)
             self.set_inheritancegraph(obj_)
         elif child_.nodeType == Node.ELEMENT_NODE and \
-            nodeName_ == 'collaborationgraph':
+                nodeName_ == 'collaborationgraph':
             obj_ = graphType.factory()
             obj_.build(child_)
             self.set_collaborationgraph(obj_)
         elif child_.nodeType == Node.ELEMENT_NODE and \
-            nodeName_ == 'programlisting':
+                nodeName_ == 'programlisting':
             obj_ = listingType.factory()
             obj_.build(child_)
             self.set_programlisting(obj_)
         elif child_.nodeType == Node.ELEMENT_NODE and \
-            nodeName_ == 'location':
+                nodeName_ == 'location':
             obj_ = locationType.factory()
             obj_.build(child_)
             self.set_location(obj_)
         elif child_.nodeType == Node.ELEMENT_NODE and \
-            nodeName_ == 'listofallmembers':
+                nodeName_ == 'listofallmembers':
             obj_ = listofallmembersType.factory()
             obj_.build(child_)
             self.set_listofallmembers(obj_)
@@ -852,11 +947,13 @@ class compounddefType(GeneratedsSuper):
 class listofallmembersType(GeneratedsSuper):
     subclass = None
     superclass = None
+
     def __init__(self, member=None):
         if member is None:
             self.member = []
         else:
             self.member = member
+
     def factory(*args_, **kwargs_):
         if listofallmembersType.subclass:
             return listofallmembersType.subclass(*args_, **kwargs_)
@@ -867,10 +964,12 @@ class listofallmembersType(GeneratedsSuper):
     def set_member(self, member): self.member = member
     def add_member(self, value): self.member.append(value)
     def insert_member(self, index, value): self.member[index] = value
+
     def export(self, outfile, level, namespace_='', name_='listofallmembersType', namespacedef_=''):
         showIndent(outfile, level)
         outfile.write('<%s%s %s' % (namespace_, name_, namespacedef_, ))
-        self.exportAttributes(outfile, level, namespace_, name_='listofallmembersType')
+        self.exportAttributes(outfile, level, namespace_,
+                              name_='listofallmembersType')
         if self.hasContent_():
             outfile.write('>\n')
             self.exportChildren(outfile, level + 1, namespace_, name_)
@@ -878,25 +977,31 @@ class listofallmembersType(GeneratedsSuper):
             outfile.write('</%s%s>\n' % (namespace_, name_))
         else:
             outfile.write(' />\n')
+
     def exportAttributes(self, outfile, level, namespace_='', name_='listofallmembersType'):
         pass
+
     def exportChildren(self, outfile, level, namespace_='', name_='listofallmembersType'):
         for member_ in self.member:
             member_.export(outfile, level, namespace_, name_='member')
+
     def hasContent_(self):
         if (
             self.member is not None
-            ):
+        ):
             return True
         else:
             return False
+
     def exportLiteral(self, outfile, level, name_='listofallmembersType'):
         level += 1
         self.exportLiteralAttributes(outfile, level, name_)
         if self.hasContent_():
             self.exportLiteralChildren(outfile, level, name_)
+
     def exportLiteralAttributes(self, outfile, level, name_):
         pass
+
     def exportLiteralChildren(self, outfile, level, name_):
         showIndent(outfile, level)
         outfile.write('member=[\n')
@@ -910,17 +1015,20 @@ class listofallmembersType(GeneratedsSuper):
         level -= 1
         showIndent(outfile, level)
         outfile.write('],\n')
+
     def build(self, node_):
         attrs = node_.attributes
         self.buildAttributes(attrs)
         for child_ in node_.childNodes:
             nodeName_ = child_.nodeName.split(':')[-1]
             self.buildChildren(child_, nodeName_)
+
     def buildAttributes(self, attrs):
         pass
+
     def buildChildren(self, child_, nodeName_):
         if child_.nodeType == Node.ELEMENT_NODE and \
-            nodeName_ == 'member':
+                nodeName_ == 'member':
             obj_ = memberRefType.factory()
             obj_.build(child_)
             self.member.append(obj_)
@@ -930,6 +1038,7 @@ class listofallmembersType(GeneratedsSuper):
 class memberRefType(GeneratedsSuper):
     subclass = None
     superclass = None
+
     def __init__(self, virt=None, prot=None, refid=None, ambiguityscope=None, scope=None, name=None):
         self.virt = virt
         self.prot = prot
@@ -937,6 +1046,7 @@ class memberRefType(GeneratedsSuper):
         self.ambiguityscope = ambiguityscope
         self.scope = scope
         self.name = name
+
     def factory(*args_, **kwargs_):
         if memberRefType.subclass:
             return memberRefType.subclass(*args_, **kwargs_)
@@ -954,11 +1064,15 @@ class memberRefType(GeneratedsSuper):
     def get_refid(self): return self.refid
     def set_refid(self, refid): self.refid = refid
     def get_ambiguityscope(self): return self.ambiguityscope
-    def set_ambiguityscope(self, ambiguityscope): self.ambiguityscope = ambiguityscope
+
+    def set_ambiguityscope(
+        self, ambiguityscope): self.ambiguityscope = ambiguityscope
+
     def export(self, outfile, level, namespace_='', name_='memberRefType', namespacedef_=''):
         showIndent(outfile, level)
         outfile.write('<%s%s %s' % (namespace_, name_, namespacedef_, ))
-        self.exportAttributes(outfile, level, namespace_, name_='memberRefType')
+        self.exportAttributes(outfile, level, namespace_,
+                              name_='memberRefType')
         if self.hasContent_():
             outfile.write('>\n')
             self.exportChildren(outfile, level + 1, namespace_, name_)
@@ -966,35 +1080,44 @@ class memberRefType(GeneratedsSuper):
             outfile.write('</%s%s>\n' % (namespace_, name_))
         else:
             outfile.write(' />\n')
+
     def exportAttributes(self, outfile, level, namespace_='', name_='memberRefType'):
         if self.virt is not None:
             outfile.write(' virt=%s' % (quote_attrib(self.virt), ))
         if self.prot is not None:
             outfile.write(' prot=%s' % (quote_attrib(self.prot), ))
         if self.refid is not None:
-            outfile.write(' refid=%s' % (self.format_string(quote_attrib(self.refid).encode(ExternalEncoding), input_name='refid'), ))
+            outfile.write(' refid=%s' % (self.format_string(quote_attrib(
+                self.refid).encode(ExternalEncoding), input_name='refid'), ))
         if self.ambiguityscope is not None:
-            outfile.write(' ambiguityscope=%s' % (self.format_string(quote_attrib(self.ambiguityscope).encode(ExternalEncoding), input_name='ambiguityscope'), ))
+            outfile.write(' ambiguityscope=%s' % (self.format_string(quote_attrib(
+                self.ambiguityscope).encode(ExternalEncoding), input_name='ambiguityscope'), ))
+
     def exportChildren(self, outfile, level, namespace_='', name_='memberRefType'):
         if self.scope is not None:
             showIndent(outfile, level)
-            outfile.write('<%sscope>%s</%sscope>\n' % (namespace_, self.format_string(quote_xml(self.scope).encode(ExternalEncoding), input_name='scope'), namespace_))
+            outfile.write('<%sscope>%s</%sscope>\n' % (namespace_, self.format_string(
+                quote_xml(self.scope).encode(ExternalEncoding), input_name='scope'), namespace_))
         if self.name is not None:
             showIndent(outfile, level)
-            outfile.write('<%sname>%s</%sname>\n' % (namespace_, self.format_string(quote_xml(self.name).encode(ExternalEncoding), input_name='name'), namespace_))
+            outfile.write('<%sname>%s</%sname>\n' % (namespace_, self.format_string(
+                quote_xml(self.name).encode(ExternalEncoding), input_name='name'), namespace_))
+
     def hasContent_(self):
         if (
             self.scope is not None or
             self.name is not None
-            ):
+        ):
             return True
         else:
             return False
+
     def exportLiteral(self, outfile, level, name_='memberRefType'):
         level += 1
         self.exportLiteralAttributes(outfile, level, name_)
         if self.hasContent_():
             self.exportLiteralChildren(outfile, level, name_)
+
     def exportLiteralAttributes(self, outfile, level, name_):
         if self.virt is not None:
             showIndent(outfile, level)
@@ -1008,17 +1131,22 @@ class memberRefType(GeneratedsSuper):
         if self.ambiguityscope is not None:
             showIndent(outfile, level)
             outfile.write('ambiguityscope = %s,\n' % (self.ambiguityscope,))
+
     def exportLiteralChildren(self, outfile, level, name_):
         showIndent(outfile, level)
-        outfile.write('scope=%s,\n' % quote_python(self.scope).encode(ExternalEncoding))
+        outfile.write('scope=%s,\n' % quote_python(
+            self.scope).encode(ExternalEncoding))
         showIndent(outfile, level)
-        outfile.write('name=%s,\n' % quote_python(self.name).encode(ExternalEncoding))
+        outfile.write('name=%s,\n' % quote_python(
+            self.name).encode(ExternalEncoding))
+
     def build(self, node_):
         attrs = node_.attributes
         self.buildAttributes(attrs)
         for child_ in node_.childNodes:
             nodeName_ = child_.nodeName.split(':')[-1]
             self.buildChildren(child_, nodeName_)
+
     def buildAttributes(self, attrs):
         if attrs.get('virt'):
             self.virt = attrs.get('virt').value
@@ -1028,15 +1156,16 @@ class memberRefType(GeneratedsSuper):
             self.refid = attrs.get('refid').value
         if attrs.get('ambiguityscope'):
             self.ambiguityscope = attrs.get('ambiguityscope').value
+
     def buildChildren(self, child_, nodeName_):
         if child_.nodeType == Node.ELEMENT_NODE and \
-            nodeName_ == 'scope':
+                nodeName_ == 'scope':
             scope_ = ''
             for text__content_ in child_.childNodes:
                 scope_ += text__content_.nodeValue
             self.scope = scope_
         elif child_.nodeType == Node.ELEMENT_NODE and \
-            nodeName_ == 'name':
+                nodeName_ == 'name':
             name_ = ''
             for text__content_ in child_.childNodes:
                 name_ += text__content_.nodeValue
@@ -1047,8 +1176,10 @@ class memberRefType(GeneratedsSuper):
 class scope(GeneratedsSuper):
     subclass = None
     superclass = None
+
     def __init__(self, valueOf_=''):
         self.valueOf_ = valueOf_
+
     def factory(*args_, **kwargs_):
         if scope.subclass:
             return scope.subclass(*args_, **kwargs_)
@@ -1057,6 +1188,7 @@ class scope(GeneratedsSuper):
     factory = staticmethod(factory)
     def getValueOf_(self): return self.valueOf_
     def setValueOf_(self, valueOf_): self.valueOf_ = valueOf_
+
     def export(self, outfile, level, namespace_='', name_='scope', namespacedef_=''):
         showIndent(outfile, level)
         outfile.write('<%s%s %s' % (namespace_, name_, namespacedef_, ))
@@ -1068,33 +1200,40 @@ class scope(GeneratedsSuper):
             outfile.write('</%s%s>\n' % (namespace_, name_))
         else:
             outfile.write(' />\n')
+
     def exportAttributes(self, outfile, level, namespace_='', name_='scope'):
         pass
+
     def exportChildren(self, outfile, level, namespace_='', name_='scope'):
-        if self.valueOf_.find('![CDATA')>-1:
-            value=quote_xml('%s' % self.valueOf_)
-            value=value.replace('![CDATA','<![CDATA')
-            value=value.replace(']]',']]>')
+        if self.valueOf_.find('![CDATA') > -1:
+            value = quote_xml('%s' % self.valueOf_)
+            value = value.replace('![CDATA', '<![CDATA')
+            value = value.replace(']]', ']]>')
             outfile.write(value)
         else:
             outfile.write(quote_xml('%s' % self.valueOf_))
+
     def hasContent_(self):
         if (
             self.valueOf_ is not None
-            ):
+        ):
             return True
         else:
             return False
+
     def exportLiteral(self, outfile, level, name_='scope'):
         level += 1
         self.exportLiteralAttributes(outfile, level, name_)
         if self.hasContent_():
             self.exportLiteralChildren(outfile, level, name_)
+
     def exportLiteralAttributes(self, outfile, level, name_):
         pass
+
     def exportLiteralChildren(self, outfile, level, name_):
         showIndent(outfile, level)
         outfile.write('valueOf_ = "%s",\n' % (self.valueOf_,))
+
     def build(self, node_):
         attrs = node_.attributes
         self.buildAttributes(attrs)
@@ -1102,21 +1241,25 @@ class scope(GeneratedsSuper):
         for child_ in node_.childNodes:
             nodeName_ = child_.nodeName.split(':')[-1]
             self.buildChildren(child_, nodeName_)
+
     def buildAttributes(self, attrs):
         pass
+
     def buildChildren(self, child_, nodeName_):
         if child_.nodeType == Node.TEXT_NODE:
             self.valueOf_ += child_.nodeValue
         elif child_.nodeType == Node.CDATA_SECTION_NODE:
-            self.valueOf_ += '![CDATA['+child_.nodeValue+']]'
+            self.valueOf_ += '![CDATA[' + child_.nodeValue + ']]'
 # end class scope
 
 
 class name(GeneratedsSuper):
     subclass = None
     superclass = None
+
     def __init__(self, valueOf_=''):
         self.valueOf_ = valueOf_
+
     def factory(*args_, **kwargs_):
         if name.subclass:
             return name.subclass(*args_, **kwargs_)
@@ -1125,6 +1268,7 @@ class name(GeneratedsSuper):
     factory = staticmethod(factory)
     def getValueOf_(self): return self.valueOf_
     def setValueOf_(self, valueOf_): self.valueOf_ = valueOf_
+
     def export(self, outfile, level, namespace_='', name_='name', namespacedef_=''):
         showIndent(outfile, level)
         outfile.write('<%s%s %s' % (namespace_, name_, namespacedef_, ))
@@ -1136,33 +1280,40 @@ class name(GeneratedsSuper):
             outfile.write('</%s%s>\n' % (namespace_, name_))
         else:
             outfile.write(' />\n')
+
     def exportAttributes(self, outfile, level, namespace_='', name_='name'):
         pass
+
     def exportChildren(self, outfile, level, namespace_='', name_='name'):
-        if self.valueOf_.find('![CDATA')>-1:
-            value=quote_xml('%s' % self.valueOf_)
-            value=value.replace('![CDATA','<![CDATA')
-            value=value.replace(']]',']]>')
+        if self.valueOf_.find('![CDATA') > -1:
+            value = quote_xml('%s' % self.valueOf_)
+            value = value.replace('![CDATA', '<![CDATA')
+            value = value.replace(']]', ']]>')
             outfile.write(value)
         else:
             outfile.write(quote_xml('%s' % self.valueOf_))
+
     def hasContent_(self):
         if (
             self.valueOf_ is not None
-            ):
+        ):
             return True
         else:
             return False
+
     def exportLiteral(self, outfile, level, name_='name'):
         level += 1
         self.exportLiteralAttributes(outfile, level, name_)
         if self.hasContent_():
             self.exportLiteralChildren(outfile, level, name_)
+
     def exportLiteralAttributes(self, outfile, level, name_):
         pass
+
     def exportLiteralChildren(self, outfile, level, name_):
         showIndent(outfile, level)
         outfile.write('valueOf_ = "%s",\n' % (self.valueOf_,))
+
     def build(self, node_):
         attrs = node_.attributes
         self.buildAttributes(attrs)
@@ -1170,19 +1321,22 @@ class name(GeneratedsSuper):
         for child_ in node_.childNodes:
             nodeName_ = child_.nodeName.split(':')[-1]
             self.buildChildren(child_, nodeName_)
+
     def buildAttributes(self, attrs):
         pass
+
     def buildChildren(self, child_, nodeName_):
         if child_.nodeType == Node.TEXT_NODE:
             self.valueOf_ += child_.nodeValue
         elif child_.nodeType == Node.CDATA_SECTION_NODE:
-            self.valueOf_ += '![CDATA['+child_.nodeValue+']]'
+            self.valueOf_ += '![CDATA[' + child_.nodeValue + ']]'
 # end class name
 
 
 class compoundRefType(GeneratedsSuper):
     subclass = None
     superclass = None
+
     def __init__(self, virt=None, prot=None, refid=None, valueOf_='', mixedclass_=None, content_=None):
         self.virt = virt
         self.prot = prot
@@ -1195,6 +1349,7 @@ class compoundRefType(GeneratedsSuper):
             self.content_ = []
         else:
             self.content_ = content_
+
     def factory(*args_, **kwargs_):
         if compoundRefType.subclass:
             return compoundRefType.subclass(*args_, **kwargs_)
@@ -1209,40 +1364,48 @@ class compoundRefType(GeneratedsSuper):
     def set_refid(self, refid): self.refid = refid
     def getValueOf_(self): return self.valueOf_
     def setValueOf_(self, valueOf_): self.valueOf_ = valueOf_
+
     def export(self, outfile, level, namespace_='', name_='compoundRefType', namespacedef_=''):
         showIndent(outfile, level)
         outfile.write('<%s%s %s' % (namespace_, name_, namespacedef_, ))
-        self.exportAttributes(outfile, level, namespace_, name_='compoundRefType')
+        self.exportAttributes(outfile, level, namespace_,
+                              name_='compoundRefType')
         outfile.write('>')
         self.exportChildren(outfile, level + 1, namespace_, name_)
         outfile.write('</%s%s>\n' % (namespace_, name_))
+
     def exportAttributes(self, outfile, level, namespace_='', name_='compoundRefType'):
         if self.virt is not None:
             outfile.write(' virt=%s' % (quote_attrib(self.virt), ))
         if self.prot is not None:
             outfile.write(' prot=%s' % (quote_attrib(self.prot), ))
         if self.refid is not None:
-            outfile.write(' refid=%s' % (self.format_string(quote_attrib(self.refid).encode(ExternalEncoding), input_name='refid'), ))
+            outfile.write(' refid=%s' % (self.format_string(quote_attrib(
+                self.refid).encode(ExternalEncoding), input_name='refid'), ))
+
     def exportChildren(self, outfile, level, namespace_='', name_='compoundRefType'):
-        if self.valueOf_.find('![CDATA')>-1:
-            value=quote_xml('%s' % self.valueOf_)
-            value=value.replace('![CDATA','<![CDATA')
-            value=value.replace(']]',']]>')
+        if self.valueOf_.find('![CDATA') > -1:
+            value = quote_xml('%s' % self.valueOf_)
+            value = value.replace('![CDATA', '<![CDATA')
+            value = value.replace(']]', ']]>')
             outfile.write(value)
         else:
             outfile.write(quote_xml('%s' % self.valueOf_))
+
     def hasContent_(self):
         if (
             self.valueOf_ is not None
-            ):
+        ):
             return True
         else:
             return False
+
     def exportLiteral(self, outfile, level, name_='compoundRefType'):
         level += 1
         self.exportLiteralAttributes(outfile, level, name_)
         if self.hasContent_():
             self.exportLiteralChildren(outfile, level, name_)
+
     def exportLiteralAttributes(self, outfile, level, name_):
         if self.virt is not None:
             showIndent(outfile, level)
@@ -1253,9 +1416,11 @@ class compoundRefType(GeneratedsSuper):
         if self.refid is not None:
             showIndent(outfile, level)
             outfile.write('refid = %s,\n' % (self.refid,))
+
     def exportLiteralChildren(self, outfile, level, name_):
         showIndent(outfile, level)
         outfile.write('valueOf_ = "%s",\n' % (self.valueOf_,))
+
     def build(self, node_):
         attrs = node_.attributes
         self.buildAttributes(attrs)
@@ -1263,6 +1428,7 @@ class compoundRefType(GeneratedsSuper):
         for child_ in node_.childNodes:
             nodeName_ = child_.nodeName.split(':')[-1]
             self.buildChildren(child_, nodeName_)
+
     def buildAttributes(self, attrs):
         if attrs.get('virt'):
             self.virt = attrs.get('virt').value
@@ -1270,21 +1436,23 @@ class compoundRefType(GeneratedsSuper):
             self.prot = attrs.get('prot').value
         if attrs.get('refid'):
             self.refid = attrs.get('refid').value
+
     def buildChildren(self, child_, nodeName_):
         if child_.nodeType == Node.TEXT_NODE:
             obj_ = self.mixedclass_(MixedContainer.CategoryText,
-                MixedContainer.TypeNone, '', child_.nodeValue)
+                                    MixedContainer.TypeNone, '', child_.nodeValue)
             self.content_.append(obj_)
         if child_.nodeType == Node.TEXT_NODE:
             self.valueOf_ += child_.nodeValue
         elif child_.nodeType == Node.CDATA_SECTION_NODE:
-            self.valueOf_ += '![CDATA['+child_.nodeValue+']]'
+            self.valueOf_ += '![CDATA[' + child_.nodeValue + ']]'
 # end class compoundRefType
 
 
 class reimplementType(GeneratedsSuper):
     subclass = None
     superclass = None
+
     def __init__(self, refid=None, valueOf_='', mixedclass_=None, content_=None):
         self.refid = refid
         if mixedclass_ is None:
@@ -1295,6 +1463,7 @@ class reimplementType(GeneratedsSuper):
             self.content_ = []
         else:
             self.content_ = content_
+
     def factory(*args_, **kwargs_):
         if reimplementType.subclass:
             return reimplementType.subclass(*args_, **kwargs_)
@@ -1305,43 +1474,53 @@ class reimplementType(GeneratedsSuper):
     def set_refid(self, refid): self.refid = refid
     def getValueOf_(self): return self.valueOf_
     def setValueOf_(self, valueOf_): self.valueOf_ = valueOf_
+
     def export(self, outfile, level, namespace_='', name_='reimplementType', namespacedef_=''):
         showIndent(outfile, level)
         outfile.write('<%s%s %s' % (namespace_, name_, namespacedef_, ))
-        self.exportAttributes(outfile, level, namespace_, name_='reimplementType')
+        self.exportAttributes(outfile, level, namespace_,
+                              name_='reimplementType')
         outfile.write('>')
         self.exportChildren(outfile, level + 1, namespace_, name_)
         outfile.write('</%s%s>\n' % (namespace_, name_))
+
     def exportAttributes(self, outfile, level, namespace_='', name_='reimplementType'):
         if self.refid is not None:
-            outfile.write(' refid=%s' % (self.format_string(quote_attrib(self.refid).encode(ExternalEncoding), input_name='refid'), ))
+            outfile.write(' refid=%s' % (self.format_string(quote_attrib(
+                self.refid).encode(ExternalEncoding), input_name='refid'), ))
+
     def exportChildren(self, outfile, level, namespace_='', name_='reimplementType'):
-        if self.valueOf_.find('![CDATA')>-1:
-            value=quote_xml('%s' % self.valueOf_)
-            value=value.replace('![CDATA','<![CDATA')
-            value=value.replace(']]',']]>')
+        if self.valueOf_.find('![CDATA') > -1:
+            value = quote_xml('%s' % self.valueOf_)
+            value = value.replace('![CDATA', '<![CDATA')
+            value = value.replace(']]', ']]>')
             outfile.write(value)
         else:
             outfile.write(quote_xml('%s' % self.valueOf_))
+
     def hasContent_(self):
         if (
             self.valueOf_ is not None
-            ):
+        ):
             return True
         else:
             return False
+
     def exportLiteral(self, outfile, level, name_='reimplementType'):
         level += 1
         self.exportLiteralAttributes(outfile, level, name_)
         if self.hasContent_():
             self.exportLiteralChildren(outfile, level, name_)
+
     def exportLiteralAttributes(self, outfile, level, name_):
         if self.refid is not None:
             showIndent(outfile, level)
             outfile.write('refid = %s,\n' % (self.refid,))
+
     def exportLiteralChildren(self, outfile, level, name_):
         showIndent(outfile, level)
         outfile.write('valueOf_ = "%s",\n' % (self.valueOf_,))
+
     def build(self, node_):
         attrs = node_.attributes
         self.buildAttributes(attrs)
@@ -1349,24 +1528,27 @@ class reimplementType(GeneratedsSuper):
         for child_ in node_.childNodes:
             nodeName_ = child_.nodeName.split(':')[-1]
             self.buildChildren(child_, nodeName_)
+
     def buildAttributes(self, attrs):
         if attrs.get('refid'):
             self.refid = attrs.get('refid').value
+
     def buildChildren(self, child_, nodeName_):
         if child_.nodeType == Node.TEXT_NODE:
             obj_ = self.mixedclass_(MixedContainer.CategoryText,
-                MixedContainer.TypeNone, '', child_.nodeValue)
+                                    MixedContainer.TypeNone, '', child_.nodeValue)
             self.content_.append(obj_)
         if child_.nodeType == Node.TEXT_NODE:
             self.valueOf_ += child_.nodeValue
         elif child_.nodeType == Node.CDATA_SECTION_NODE:
-            self.valueOf_ += '![CDATA['+child_.nodeValue+']]'
+            self.valueOf_ += '![CDATA[' + child_.nodeValue + ']]'
 # end class reimplementType
 
 
 class incType(GeneratedsSuper):
     subclass = None
     superclass = None
+
     def __init__(self, local=None, refid=None, valueOf_='', mixedclass_=None, content_=None):
         self.local = local
         self.refid = refid
@@ -1378,6 +1560,7 @@ class incType(GeneratedsSuper):
             self.content_ = []
         else:
             self.content_ = content_
+
     def factory(*args_, **kwargs_):
         if incType.subclass:
             return incType.subclass(*args_, **kwargs_)
@@ -1390,6 +1573,7 @@ class incType(GeneratedsSuper):
     def set_refid(self, refid): self.refid = refid
     def getValueOf_(self): return self.valueOf_
     def setValueOf_(self, valueOf_): self.valueOf_ = valueOf_
+
     def export(self, outfile, level, namespace_='', name_='incType', namespacedef_=''):
         showIndent(outfile, level)
         outfile.write('<%s%s %s' % (namespace_, name_, namespacedef_, ))
@@ -1397,31 +1581,37 @@ class incType(GeneratedsSuper):
         outfile.write('>')
         self.exportChildren(outfile, level + 1, namespace_, name_)
         outfile.write('</%s%s>\n' % (namespace_, name_))
+
     def exportAttributes(self, outfile, level, namespace_='', name_='incType'):
         if self.local is not None:
             outfile.write(' local=%s' % (quote_attrib(self.local), ))
         if self.refid is not None:
-            outfile.write(' refid=%s' % (self.format_string(quote_attrib(self.refid).encode(ExternalEncoding), input_name='refid'), ))
+            outfile.write(' refid=%s' % (self.format_string(quote_attrib(
+                self.refid).encode(ExternalEncoding), input_name='refid'), ))
+
     def exportChildren(self, outfile, level, namespace_='', name_='incType'):
-        if self.valueOf_.find('![CDATA')>-1:
-            value=quote_xml('%s' % self.valueOf_)
-            value=value.replace('![CDATA','<![CDATA')
-            value=value.replace(']]',']]>')
+        if self.valueOf_.find('![CDATA') > -1:
+            value = quote_xml('%s' % self.valueOf_)
+            value = value.replace('![CDATA', '<![CDATA')
+            value = value.replace(']]', ']]>')
             outfile.write(value)
         else:
             outfile.write(quote_xml('%s' % self.valueOf_))
+
     def hasContent_(self):
         if (
             self.valueOf_ is not None
-            ):
+        ):
             return True
         else:
             return False
+
     def exportLiteral(self, outfile, level, name_='incType'):
         level += 1
         self.exportLiteralAttributes(outfile, level, name_)
         if self.hasContent_():
             self.exportLiteralChildren(outfile, level, name_)
+
     def exportLiteralAttributes(self, outfile, level, name_):
         if self.local is not None:
             showIndent(outfile, level)
@@ -1429,9 +1619,11 @@ class incType(GeneratedsSuper):
         if self.refid is not None:
             showIndent(outfile, level)
             outfile.write('refid = %s,\n' % (self.refid,))
+
     def exportLiteralChildren(self, outfile, level, name_):
         showIndent(outfile, level)
         outfile.write('valueOf_ = "%s",\n' % (self.valueOf_,))
+
     def build(self, node_):
         attrs = node_.attributes
         self.buildAttributes(attrs)
@@ -1439,26 +1631,29 @@ class incType(GeneratedsSuper):
         for child_ in node_.childNodes:
             nodeName_ = child_.nodeName.split(':')[-1]
             self.buildChildren(child_, nodeName_)
+
     def buildAttributes(self, attrs):
         if attrs.get('local'):
             self.local = attrs.get('local').value
         if attrs.get('refid'):
             self.refid = attrs.get('refid').value
+
     def buildChildren(self, child_, nodeName_):
         if child_.nodeType == Node.TEXT_NODE:
             obj_ = self.mixedclass_(MixedContainer.CategoryText,
-                MixedContainer.TypeNone, '', child_.nodeValue)
+                                    MixedContainer.TypeNone, '', child_.nodeValue)
             self.content_.append(obj_)
         if child_.nodeType == Node.TEXT_NODE:
             self.valueOf_ += child_.nodeValue
         elif child_.nodeType == Node.CDATA_SECTION_NODE:
-            self.valueOf_ += '![CDATA['+child_.nodeValue+']]'
+            self.valueOf_ += '![CDATA[' + child_.nodeValue + ']]'
 # end class incType
 
 
 class refType(GeneratedsSuper):
     subclass = None
     superclass = None
+
     def __init__(self, prot=None, refid=None, valueOf_='', mixedclass_=None, content_=None):
         self.prot = prot
         self.refid = refid
@@ -1470,6 +1665,7 @@ class refType(GeneratedsSuper):
             self.content_ = []
         else:
             self.content_ = content_
+
     def factory(*args_, **kwargs_):
         if refType.subclass:
             return refType.subclass(*args_, **kwargs_)
@@ -1482,6 +1678,7 @@ class refType(GeneratedsSuper):
     def set_refid(self, refid): self.refid = refid
     def getValueOf_(self): return self.valueOf_
     def setValueOf_(self, valueOf_): self.valueOf_ = valueOf_
+
     def export(self, outfile, level, namespace_='', name_='refType', namespacedef_=''):
         showIndent(outfile, level)
         outfile.write('<%s%s %s' % (namespace_, name_, namespacedef_, ))
@@ -1489,31 +1686,37 @@ class refType(GeneratedsSuper):
         outfile.write('>')
         self.exportChildren(outfile, level + 1, namespace_, name_)
         outfile.write('</%s%s>\n' % (namespace_, name_))
+
     def exportAttributes(self, outfile, level, namespace_='', name_='refType'):
         if self.prot is not None:
             outfile.write(' prot=%s' % (quote_attrib(self.prot), ))
         if self.refid is not None:
-            outfile.write(' refid=%s' % (self.format_string(quote_attrib(self.refid).encode(ExternalEncoding), input_name='refid'), ))
+            outfile.write(' refid=%s' % (self.format_string(quote_attrib(
+                self.refid).encode(ExternalEncoding), input_name='refid'), ))
+
     def exportChildren(self, outfile, level, namespace_='', name_='refType'):
-        if self.valueOf_.find('![CDATA')>-1:
-            value=quote_xml('%s' % self.valueOf_)
-            value=value.replace('![CDATA','<![CDATA')
-            value=value.replace(']]',']]>')
+        if self.valueOf_.find('![CDATA') > -1:
+            value = quote_xml('%s' % self.valueOf_)
+            value = value.replace('![CDATA', '<![CDATA')
+            value = value.replace(']]', ']]>')
             outfile.write(value)
         else:
             outfile.write(quote_xml('%s' % self.valueOf_))
+
     def hasContent_(self):
         if (
             self.valueOf_ is not None
-            ):
+        ):
             return True
         else:
             return False
+
     def exportLiteral(self, outfile, level, name_='refType'):
         level += 1
         self.exportLiteralAttributes(outfile, level, name_)
         if self.hasContent_():
             self.exportLiteralChildren(outfile, level, name_)
+
     def exportLiteralAttributes(self, outfile, level, name_):
         if self.prot is not None:
             showIndent(outfile, level)
@@ -1521,9 +1724,11 @@ class refType(GeneratedsSuper):
         if self.refid is not None:
             showIndent(outfile, level)
             outfile.write('refid = %s,\n' % (self.refid,))
+
     def exportLiteralChildren(self, outfile, level, name_):
         showIndent(outfile, level)
         outfile.write('valueOf_ = "%s",\n' % (self.valueOf_,))
+
     def build(self, node_):
         attrs = node_.attributes
         self.buildAttributes(attrs)
@@ -1531,26 +1736,29 @@ class refType(GeneratedsSuper):
         for child_ in node_.childNodes:
             nodeName_ = child_.nodeName.split(':')[-1]
             self.buildChildren(child_, nodeName_)
+
     def buildAttributes(self, attrs):
         if attrs.get('prot'):
             self.prot = attrs.get('prot').value
         if attrs.get('refid'):
             self.refid = attrs.get('refid').value
+
     def buildChildren(self, child_, nodeName_):
         if child_.nodeType == Node.TEXT_NODE:
             obj_ = self.mixedclass_(MixedContainer.CategoryText,
-                MixedContainer.TypeNone, '', child_.nodeValue)
+                                    MixedContainer.TypeNone, '', child_.nodeValue)
             self.content_.append(obj_)
         if child_.nodeType == Node.TEXT_NODE:
             self.valueOf_ += child_.nodeValue
         elif child_.nodeType == Node.CDATA_SECTION_NODE:
-            self.valueOf_ += '![CDATA['+child_.nodeValue+']]'
+            self.valueOf_ += '![CDATA[' + child_.nodeValue + ']]'
 # end class refType
 
 
 class refTextType(GeneratedsSuper):
     subclass = None
     superclass = None
+
     def __init__(self, refid=None, kindref=None, external=None, valueOf_='', mixedclass_=None, content_=None):
         self.refid = refid
         self.kindref = kindref
@@ -1563,6 +1771,7 @@ class refTextType(GeneratedsSuper):
             self.content_ = []
         else:
             self.content_ = content_
+
     def factory(*args_, **kwargs_):
         if refTextType.subclass:
             return refTextType.subclass(*args_, **kwargs_)
@@ -1577,6 +1786,7 @@ class refTextType(GeneratedsSuper):
     def set_external(self, external): self.external = external
     def getValueOf_(self): return self.valueOf_
     def setValueOf_(self, valueOf_): self.valueOf_ = valueOf_
+
     def export(self, outfile, level, namespace_='', name_='refTextType', namespacedef_=''):
         showIndent(outfile, level)
         outfile.write('<%s%s %s' % (namespace_, name_, namespacedef_, ))
@@ -1584,33 +1794,40 @@ class refTextType(GeneratedsSuper):
         outfile.write('>')
         self.exportChildren(outfile, level + 1, namespace_, name_)
         outfile.write('</%s%s>\n' % (namespace_, name_))
+
     def exportAttributes(self, outfile, level, namespace_='', name_='refTextType'):
         if self.refid is not None:
-            outfile.write(' refid=%s' % (self.format_string(quote_attrib(self.refid).encode(ExternalEncoding), input_name='refid'), ))
+            outfile.write(' refid=%s' % (self.format_string(quote_attrib(
+                self.refid).encode(ExternalEncoding), input_name='refid'), ))
         if self.kindref is not None:
             outfile.write(' kindref=%s' % (quote_attrib(self.kindref), ))
         if self.external is not None:
-            outfile.write(' external=%s' % (self.format_string(quote_attrib(self.external).encode(ExternalEncoding), input_name='external'), ))
+            outfile.write(' external=%s' % (self.format_string(quote_attrib(
+                self.external).encode(ExternalEncoding), input_name='external'), ))
+
     def exportChildren(self, outfile, level, namespace_='', name_='refTextType'):
-        if self.valueOf_.find('![CDATA')>-1:
-            value=quote_xml('%s' % self.valueOf_)
-            value=value.replace('![CDATA','<![CDATA')
-            value=value.replace(']]',']]>')
+        if self.valueOf_.find('![CDATA') > -1:
+            value = quote_xml('%s' % self.valueOf_)
+            value = value.replace('![CDATA', '<![CDATA')
+            value = value.replace(']]', ']]>')
             outfile.write(value)
         else:
             outfile.write(quote_xml('%s' % self.valueOf_))
+
     def hasContent_(self):
         if (
             self.valueOf_ is not None
-            ):
+        ):
             return True
         else:
             return False
+
     def exportLiteral(self, outfile, level, name_='refTextType'):
         level += 1
         self.exportLiteralAttributes(outfile, level, name_)
         if self.hasContent_():
             self.exportLiteralChildren(outfile, level, name_)
+
     def exportLiteralAttributes(self, outfile, level, name_):
         if self.refid is not None:
             showIndent(outfile, level)
@@ -1621,9 +1838,11 @@ class refTextType(GeneratedsSuper):
         if self.external is not None:
             showIndent(outfile, level)
             outfile.write('external = %s,\n' % (self.external,))
+
     def exportLiteralChildren(self, outfile, level, name_):
         showIndent(outfile, level)
         outfile.write('valueOf_ = "%s",\n' % (self.valueOf_,))
+
     def build(self, node_):
         attrs = node_.attributes
         self.buildAttributes(attrs)
@@ -1631,6 +1850,7 @@ class refTextType(GeneratedsSuper):
         for child_ in node_.childNodes:
             nodeName_ = child_.nodeName.split(':')[-1]
             self.buildChildren(child_, nodeName_)
+
     def buildAttributes(self, attrs):
         if attrs.get('refid'):
             self.refid = attrs.get('refid').value
@@ -1638,21 +1858,23 @@ class refTextType(GeneratedsSuper):
             self.kindref = attrs.get('kindref').value
         if attrs.get('external'):
             self.external = attrs.get('external').value
+
     def buildChildren(self, child_, nodeName_):
         if child_.nodeType == Node.TEXT_NODE:
             obj_ = self.mixedclass_(MixedContainer.CategoryText,
-                MixedContainer.TypeNone, '', child_.nodeValue)
+                                    MixedContainer.TypeNone, '', child_.nodeValue)
             self.content_.append(obj_)
         if child_.nodeType == Node.TEXT_NODE:
             self.valueOf_ += child_.nodeValue
         elif child_.nodeType == Node.CDATA_SECTION_NODE:
-            self.valueOf_ += '![CDATA['+child_.nodeValue+']]'
+            self.valueOf_ += '![CDATA[' + child_.nodeValue + ']]'
 # end class refTextType
 
 
 class sectiondefType(GeneratedsSuper):
     subclass = None
     superclass = None
+
     def __init__(self, kind=None, header=None, description=None, memberdef=None):
         self.kind = kind
         self.header = header
@@ -1661,6 +1883,7 @@ class sectiondefType(GeneratedsSuper):
             self.memberdef = []
         else:
             self.memberdef = memberdef
+
     def factory(*args_, **kwargs_):
         if sectiondefType.subclass:
             return sectiondefType.subclass(*args_, **kwargs_)
@@ -1677,10 +1900,12 @@ class sectiondefType(GeneratedsSuper):
     def insert_memberdef(self, index, value): self.memberdef[index] = value
     def get_kind(self): return self.kind
     def set_kind(self, kind): self.kind = kind
+
     def export(self, outfile, level, namespace_='', name_='sectiondefType', namespacedef_=''):
         showIndent(outfile, level)
         outfile.write('<%s%s %s' % (namespace_, name_, namespacedef_, ))
-        self.exportAttributes(outfile, level, namespace_, name_='sectiondefType')
+        self.exportAttributes(outfile, level, namespace_,
+                              name_='sectiondefType')
         if self.hasContent_():
             outfile.write('>\n')
             self.exportChildren(outfile, level + 1, namespace_, name_)
@@ -1688,38 +1913,47 @@ class sectiondefType(GeneratedsSuper):
             outfile.write('</%s%s>\n' % (namespace_, name_))
         else:
             outfile.write(' />\n')
+
     def exportAttributes(self, outfile, level, namespace_='', name_='sectiondefType'):
         if self.kind is not None:
             outfile.write(' kind=%s' % (quote_attrib(self.kind), ))
+
     def exportChildren(self, outfile, level, namespace_='', name_='sectiondefType'):
         if self.header is not None:
             showIndent(outfile, level)
-            outfile.write('<%sheader>%s</%sheader>\n' % (namespace_, self.format_string(quote_xml(self.header).encode(ExternalEncoding), input_name='header'), namespace_))
+            outfile.write('<%sheader>%s</%sheader>\n' % (namespace_, self.format_string(
+                quote_xml(self.header).encode(ExternalEncoding), input_name='header'), namespace_))
         if self.description:
-            self.description.export(outfile, level, namespace_, name_='description')
+            self.description.export(
+                outfile, level, namespace_, name_='description')
         for memberdef_ in self.memberdef:
             memberdef_.export(outfile, level, namespace_, name_='memberdef')
+
     def hasContent_(self):
         if (
             self.header is not None or
             self.description is not None or
             self.memberdef is not None
-            ):
+        ):
             return True
         else:
             return False
+
     def exportLiteral(self, outfile, level, name_='sectiondefType'):
         level += 1
         self.exportLiteralAttributes(outfile, level, name_)
         if self.hasContent_():
             self.exportLiteralChildren(outfile, level, name_)
+
     def exportLiteralAttributes(self, outfile, level, name_):
         if self.kind is not None:
             showIndent(outfile, level)
             outfile.write('kind = "%s",\n' % (self.kind,))
+
     def exportLiteralChildren(self, outfile, level, name_):
         showIndent(outfile, level)
-        outfile.write('header=%s,\n' % quote_python(self.header).encode(ExternalEncoding))
+        outfile.write('header=%s,\n' % quote_python(
+            self.header).encode(ExternalEncoding))
         if self.description:
             showIndent(outfile, level)
             outfile.write('description=model_.descriptionType(\n')
@@ -1738,29 +1972,32 @@ class sectiondefType(GeneratedsSuper):
         level -= 1
         showIndent(outfile, level)
         outfile.write('],\n')
+
     def build(self, node_):
         attrs = node_.attributes
         self.buildAttributes(attrs)
         for child_ in node_.childNodes:
             nodeName_ = child_.nodeName.split(':')[-1]
             self.buildChildren(child_, nodeName_)
+
     def buildAttributes(self, attrs):
         if attrs.get('kind'):
             self.kind = attrs.get('kind').value
+
     def buildChildren(self, child_, nodeName_):
         if child_.nodeType == Node.ELEMENT_NODE and \
-            nodeName_ == 'header':
+                nodeName_ == 'header':
             header_ = ''
             for text__content_ in child_.childNodes:
                 header_ += text__content_.nodeValue
             self.header = header_
         elif child_.nodeType == Node.ELEMENT_NODE and \
-            nodeName_ == 'description':
+                nodeName_ == 'description':
             obj_ = descriptionType.factory()
             obj_.build(child_)
             self.set_description(obj_)
         elif child_.nodeType == Node.ELEMENT_NODE and \
-            nodeName_ == 'memberdef':
+                nodeName_ == 'memberdef':
             obj_ = memberdefType.factory()
             obj_.build(child_)
             self.memberdef.append(obj_)
@@ -1770,6 +2007,7 @@ class sectiondefType(GeneratedsSuper):
 class memberdefType(GeneratedsSuper):
     subclass = None
     superclass = None
+
     def __init__(self, initonly=None, kind=None, volatile=None, const=None, raisexx=None, virt=None, readable=None, prot=None, explicit=None, new=None, final=None, writable=None, add=None, static=None, remove=None, sealed=None, mutable=None, gettable=None, inline=None, settable=None, id=None, templateparamlist=None, type_=None, definition=None, argsstring=None, name=None, read=None, write=None, bitfield=None, reimplements=None, reimplementedby=None, param=None, enumvalue=None, initializer=None, exceptions=None, briefdescription=None, detaileddescription=None, inbodydescription=None, location=None, references=None, referencedby=None):
         self.initonly = initonly
         self.kind = kind
@@ -1830,6 +2068,7 @@ class memberdefType(GeneratedsSuper):
             self.referencedby = []
         else:
             self.referencedby = referencedby
+
     def factory(*args_, **kwargs_):
         if memberdefType.subclass:
             return memberdefType.subclass(*args_, **kwargs_)
@@ -1837,7 +2076,9 @@ class memberdefType(GeneratedsSuper):
             return memberdefType(*args_, **kwargs_)
     factory = staticmethod(factory)
     def get_templateparamlist(self): return self.templateparamlist
-    def set_templateparamlist(self, templateparamlist): self.templateparamlist = templateparamlist
+    def set_templateparamlist(
+        self, templateparamlist): self.templateparamlist = templateparamlist
+
     def get_type(self): return self.type_
     def set_type(self, type_): self.type_ = type_
     def get_definition(self): return self.definition
@@ -1855,11 +2096,17 @@ class memberdefType(GeneratedsSuper):
     def get_reimplements(self): return self.reimplements
     def set_reimplements(self, reimplements): self.reimplements = reimplements
     def add_reimplements(self, value): self.reimplements.append(value)
-    def insert_reimplements(self, index, value): self.reimplements[index] = value
+    def insert_reimplements(
+        self, index, value): self.reimplements[index] = value
+
     def get_reimplementedby(self): return self.reimplementedby
-    def set_reimplementedby(self, reimplementedby): self.reimplementedby = reimplementedby
+    def set_reimplementedby(
+        self, reimplementedby): self.reimplementedby = reimplementedby
+
     def add_reimplementedby(self, value): self.reimplementedby.append(value)
-    def insert_reimplementedby(self, index, value): self.reimplementedby[index] = value
+    def insert_reimplementedby(
+        self, index, value): self.reimplementedby[index] = value
+
     def get_param(self): return self.param
     def set_param(self, param): self.param = param
     def add_param(self, value): self.param.append(value)
@@ -1873,11 +2120,17 @@ class memberdefType(GeneratedsSuper):
     def get_exceptions(self): return self.exceptions
     def set_exceptions(self, exceptions): self.exceptions = exceptions
     def get_briefdescription(self): return self.briefdescription
-    def set_briefdescription(self, briefdescription): self.briefdescription = briefdescription
+    def set_briefdescription(
+        self, briefdescription): self.briefdescription = briefdescription
+
     def get_detaileddescription(self): return self.detaileddescription
-    def set_detaileddescription(self, detaileddescription): self.detaileddescription = detaileddescription
+    def set_detaileddescription(
+        self, detaileddescription): self.detaileddescription = detaileddescription
+
     def get_inbodydescription(self): return self.inbodydescription
-    def set_inbodydescription(self, inbodydescription): self.inbodydescription = inbodydescription
+    def set_inbodydescription(
+        self, inbodydescription): self.inbodydescription = inbodydescription
+
     def get_location(self): return self.location
     def set_location(self, location): self.location = location
     def get_references(self): return self.references
@@ -1887,7 +2140,9 @@ class memberdefType(GeneratedsSuper):
     def get_referencedby(self): return self.referencedby
     def set_referencedby(self, referencedby): self.referencedby = referencedby
     def add_referencedby(self, value): self.referencedby.append(value)
-    def insert_referencedby(self, index, value): self.referencedby[index] = value
+    def insert_referencedby(
+        self, index, value): self.referencedby[index] = value
+
     def get_initonly(self): return self.initonly
     def set_initonly(self, initonly): self.initonly = initonly
     def get_kind(self): return self.kind
@@ -1930,10 +2185,12 @@ class memberdefType(GeneratedsSuper):
     def set_settable(self, settable): self.settable = settable
     def get_id(self): return self.id
     def set_id(self, id): self.id = id
+
     def export(self, outfile, level, namespace_='', name_='memberdefType', namespacedef_=''):
         showIndent(outfile, level)
         outfile.write('<%s%s %s' % (namespace_, name_, namespacedef_, ))
-        self.exportAttributes(outfile, level, namespace_, name_='memberdefType')
+        self.exportAttributes(outfile, level, namespace_,
+                              name_='memberdefType')
         if self.hasContent_():
             outfile.write('>\n')
             self.exportChildren(outfile, level + 1, namespace_, name_)
@@ -1941,6 +2198,7 @@ class memberdefType(GeneratedsSuper):
             outfile.write('</%s%s>\n' % (namespace_, name_))
         else:
             outfile.write(' />\n')
+
     def exportAttributes(self, outfile, level, namespace_='', name_='memberdefType'):
         if self.initonly is not None:
             outfile.write(' initonly=%s' % (quote_attrib(self.initonly), ))
@@ -1983,54 +2241,73 @@ class memberdefType(GeneratedsSuper):
         if self.settable is not None:
             outfile.write(' settable=%s' % (quote_attrib(self.settable), ))
         if self.id is not None:
-            outfile.write(' id=%s' % (self.format_string(quote_attrib(self.id).encode(ExternalEncoding), input_name='id'), ))
+            outfile.write(' id=%s' % (self.format_string(quote_attrib(
+                self.id).encode(ExternalEncoding), input_name='id'), ))
+
     def exportChildren(self, outfile, level, namespace_='', name_='memberdefType'):
         if self.templateparamlist:
-            self.templateparamlist.export(outfile, level, namespace_, name_='templateparamlist')
+            self.templateparamlist.export(
+                outfile, level, namespace_, name_='templateparamlist')
         if self.type_:
             self.type_.export(outfile, level, namespace_, name_='type')
         if self.definition is not None:
             showIndent(outfile, level)
-            outfile.write('<%sdefinition>%s</%sdefinition>\n' % (namespace_, self.format_string(quote_xml(self.definition).encode(ExternalEncoding), input_name='definition'), namespace_))
+            outfile.write('<%sdefinition>%s</%sdefinition>\n' % (namespace_, self.format_string(
+                quote_xml(self.definition).encode(ExternalEncoding), input_name='definition'), namespace_))
         if self.argsstring is not None:
             showIndent(outfile, level)
-            outfile.write('<%sargsstring>%s</%sargsstring>\n' % (namespace_, self.format_string(quote_xml(self.argsstring).encode(ExternalEncoding), input_name='argsstring'), namespace_))
+            outfile.write('<%sargsstring>%s</%sargsstring>\n' % (namespace_, self.format_string(
+                quote_xml(self.argsstring).encode(ExternalEncoding), input_name='argsstring'), namespace_))
         if self.name is not None:
             showIndent(outfile, level)
-            outfile.write('<%sname>%s</%sname>\n' % (namespace_, self.format_string(quote_xml(self.name).encode(ExternalEncoding), input_name='name'), namespace_))
+            outfile.write('<%sname>%s</%sname>\n' % (namespace_, self.format_string(
+                quote_xml(self.name).encode(ExternalEncoding), input_name='name'), namespace_))
         if self.read is not None:
             showIndent(outfile, level)
-            outfile.write('<%sread>%s</%sread>\n' % (namespace_, self.format_string(quote_xml(self.read).encode(ExternalEncoding), input_name='read'), namespace_))
+            outfile.write('<%sread>%s</%sread>\n' % (namespace_, self.format_string(
+                quote_xml(self.read).encode(ExternalEncoding), input_name='read'), namespace_))
         if self.write is not None:
             showIndent(outfile, level)
-            outfile.write('<%swrite>%s</%swrite>\n' % (namespace_, self.format_string(quote_xml(self.write).encode(ExternalEncoding), input_name='write'), namespace_))
+            outfile.write('<%swrite>%s</%swrite>\n' % (namespace_, self.format_string(
+                quote_xml(self.write).encode(ExternalEncoding), input_name='write'), namespace_))
         if self.bitfield is not None:
             showIndent(outfile, level)
-            outfile.write('<%sbitfield>%s</%sbitfield>\n' % (namespace_, self.format_string(quote_xml(self.bitfield).encode(ExternalEncoding), input_name='bitfield'), namespace_))
+            outfile.write('<%sbitfield>%s</%sbitfield>\n' % (namespace_, self.format_string(
+                quote_xml(self.bitfield).encode(ExternalEncoding), input_name='bitfield'), namespace_))
         for reimplements_ in self.reimplements:
-            reimplements_.export(outfile, level, namespace_, name_='reimplements')
+            reimplements_.export(
+                outfile, level, namespace_, name_='reimplements')
         for reimplementedby_ in self.reimplementedby:
-            reimplementedby_.export(outfile, level, namespace_, name_='reimplementedby')
+            reimplementedby_.export(
+                outfile, level, namespace_, name_='reimplementedby')
         for param_ in self.param:
             param_.export(outfile, level, namespace_, name_='param')
         for enumvalue_ in self.enumvalue:
             enumvalue_.export(outfile, level, namespace_, name_='enumvalue')
         if self.initializer:
-            self.initializer.export(outfile, level, namespace_, name_='initializer')
+            self.initializer.export(
+                outfile, level, namespace_, name_='initializer')
         if self.exceptions:
-            self.exceptions.export(outfile, level, namespace_, name_='exceptions')
+            self.exceptions.export(
+                outfile, level, namespace_, name_='exceptions')
         if self.briefdescription:
-            self.briefdescription.export(outfile, level, namespace_, name_='briefdescription')
+            self.briefdescription.export(
+                outfile, level, namespace_, name_='briefdescription')
         if self.detaileddescription:
-            self.detaileddescription.export(outfile, level, namespace_, name_='detaileddescription')
+            self.detaileddescription.export(
+                outfile, level, namespace_, name_='detaileddescription')
         if self.inbodydescription:
-            self.inbodydescription.export(outfile, level, namespace_, name_='inbodydescription')
+            self.inbodydescription.export(
+                outfile, level, namespace_, name_='inbodydescription')
         if self.location:
-            self.location.export(outfile, level, namespace_, name_='location', )
+            self.location.export(
+                outfile, level, namespace_, name_='location', )
         for references_ in self.references:
             references_.export(outfile, level, namespace_, name_='references')
         for referencedby_ in self.referencedby:
-            referencedby_.export(outfile, level, namespace_, name_='referencedby')
+            referencedby_.export(
+                outfile, level, namespace_, name_='referencedby')
+
     def hasContent_(self):
         if (
             self.templateparamlist is not None or
@@ -2053,15 +2330,17 @@ class memberdefType(GeneratedsSuper):
             self.location is not None or
             self.references is not None or
             self.referencedby is not None
-            ):
+        ):
             return True
         else:
             return False
+
     def exportLiteral(self, outfile, level, name_='memberdefType'):
         level += 1
         self.exportLiteralAttributes(outfile, level, name_)
         if self.hasContent_():
             self.exportLiteralChildren(outfile, level, name_)
+
     def exportLiteralAttributes(self, outfile, level, name_):
         if self.initonly is not None:
             showIndent(outfile, level)
@@ -2126,11 +2405,13 @@ class memberdefType(GeneratedsSuper):
         if self.id is not None:
             showIndent(outfile, level)
             outfile.write('id = %s,\n' % (self.id,))
+
     def exportLiteralChildren(self, outfile, level, name_):
         if self.templateparamlist:
             showIndent(outfile, level)
             outfile.write('templateparamlist=model_.templateparamlistType(\n')
-            self.templateparamlist.exportLiteral(outfile, level, name_='templateparamlist')
+            self.templateparamlist.exportLiteral(
+                outfile, level, name_='templateparamlist')
             showIndent(outfile, level)
             outfile.write('),\n')
         if self.type_:
@@ -2140,17 +2421,23 @@ class memberdefType(GeneratedsSuper):
             showIndent(outfile, level)
             outfile.write('),\n')
         showIndent(outfile, level)
-        outfile.write('definition=%s,\n' % quote_python(self.definition).encode(ExternalEncoding))
+        outfile.write('definition=%s,\n' % quote_python(
+            self.definition).encode(ExternalEncoding))
         showIndent(outfile, level)
-        outfile.write('argsstring=%s,\n' % quote_python(self.argsstring).encode(ExternalEncoding))
+        outfile.write('argsstring=%s,\n' % quote_python(
+            self.argsstring).encode(ExternalEncoding))
         showIndent(outfile, level)
-        outfile.write('name=%s,\n' % quote_python(self.name).encode(ExternalEncoding))
+        outfile.write('name=%s,\n' % quote_python(
+            self.name).encode(ExternalEncoding))
         showIndent(outfile, level)
-        outfile.write('read=%s,\n' % quote_python(self.read).encode(ExternalEncoding))
+        outfile.write('read=%s,\n' % quote_python(
+            self.read).encode(ExternalEncoding))
         showIndent(outfile, level)
-        outfile.write('write=%s,\n' % quote_python(self.write).encode(ExternalEncoding))
+        outfile.write('write=%s,\n' % quote_python(
+            self.write).encode(ExternalEncoding))
         showIndent(outfile, level)
-        outfile.write('bitfield=%s,\n' % quote_python(self.bitfield).encode(ExternalEncoding))
+        outfile.write('bitfield=%s,\n' % quote_python(
+            self.bitfield).encode(ExternalEncoding))
         showIndent(outfile, level)
         outfile.write('reimplements=[\n')
         level += 1
@@ -2169,7 +2456,8 @@ class memberdefType(GeneratedsSuper):
         for reimplementedby in self.reimplementedby:
             showIndent(outfile, level)
             outfile.write('model_.reimplementedby(\n')
-            reimplementedby.exportLiteral(outfile, level, name_='reimplementedby')
+            reimplementedby.exportLiteral(
+                outfile, level, name_='reimplementedby')
             showIndent(outfile, level)
             outfile.write('),\n')
         level -= 1
@@ -2214,19 +2502,22 @@ class memberdefType(GeneratedsSuper):
         if self.briefdescription:
             showIndent(outfile, level)
             outfile.write('briefdescription=model_.descriptionType(\n')
-            self.briefdescription.exportLiteral(outfile, level, name_='briefdescription')
+            self.briefdescription.exportLiteral(
+                outfile, level, name_='briefdescription')
             showIndent(outfile, level)
             outfile.write('),\n')
         if self.detaileddescription:
             showIndent(outfile, level)
             outfile.write('detaileddescription=model_.descriptionType(\n')
-            self.detaileddescription.exportLiteral(outfile, level, name_='detaileddescription')
+            self.detaileddescription.exportLiteral(
+                outfile, level, name_='detaileddescription')
             showIndent(outfile, level)
             outfile.write('),\n')
         if self.inbodydescription:
             showIndent(outfile, level)
             outfile.write('inbodydescription=model_.descriptionType(\n')
-            self.inbodydescription.exportLiteral(outfile, level, name_='inbodydescription')
+            self.inbodydescription.exportLiteral(
+                outfile, level, name_='inbodydescription')
             showIndent(outfile, level)
             outfile.write('),\n')
         if self.location:
@@ -2259,12 +2550,14 @@ class memberdefType(GeneratedsSuper):
         level -= 1
         showIndent(outfile, level)
         outfile.write('],\n')
+
     def build(self, node_):
         attrs = node_.attributes
         self.buildAttributes(attrs)
         for child_ in node_.childNodes:
             nodeName_ = child_.nodeName.split(':')[-1]
             self.buildChildren(child_, nodeName_)
+
     def buildAttributes(self, attrs):
         if attrs.get('initonly'):
             self.initonly = attrs.get('initonly').value
@@ -2308,110 +2601,111 @@ class memberdefType(GeneratedsSuper):
             self.settable = attrs.get('settable').value
         if attrs.get('id'):
             self.id = attrs.get('id').value
+
     def buildChildren(self, child_, nodeName_):
         if child_.nodeType == Node.ELEMENT_NODE and \
-            nodeName_ == 'templateparamlist':
+                nodeName_ == 'templateparamlist':
             obj_ = templateparamlistType.factory()
             obj_.build(child_)
             self.set_templateparamlist(obj_)
         elif child_.nodeType == Node.ELEMENT_NODE and \
-            nodeName_ == 'type':
+                nodeName_ == 'type':
             obj_ = linkedTextType.factory()
             obj_.build(child_)
             self.set_type(obj_)
         elif child_.nodeType == Node.ELEMENT_NODE and \
-            nodeName_ == 'definition':
+                nodeName_ == 'definition':
             definition_ = ''
             for text__content_ in child_.childNodes:
                 definition_ += text__content_.nodeValue
             self.definition = definition_
         elif child_.nodeType == Node.ELEMENT_NODE and \
-            nodeName_ == 'argsstring':
+                nodeName_ == 'argsstring':
             argsstring_ = ''
             for text__content_ in child_.childNodes:
                 argsstring_ += text__content_.nodeValue
             self.argsstring = argsstring_
         elif child_.nodeType == Node.ELEMENT_NODE and \
-            nodeName_ == 'name':
+                nodeName_ == 'name':
             name_ = ''
             for text__content_ in child_.childNodes:
                 name_ += text__content_.nodeValue
             self.name = name_
         elif child_.nodeType == Node.ELEMENT_NODE and \
-            nodeName_ == 'read':
+                nodeName_ == 'read':
             read_ = ''
             for text__content_ in child_.childNodes:
                 read_ += text__content_.nodeValue
             self.read = read_
         elif child_.nodeType == Node.ELEMENT_NODE and \
-            nodeName_ == 'write':
+                nodeName_ == 'write':
             write_ = ''
             for text__content_ in child_.childNodes:
                 write_ += text__content_.nodeValue
             self.write = write_
         elif child_.nodeType == Node.ELEMENT_NODE and \
-            nodeName_ == 'bitfield':
+                nodeName_ == 'bitfield':
             bitfield_ = ''
             for text__content_ in child_.childNodes:
                 bitfield_ += text__content_.nodeValue
             self.bitfield = bitfield_
         elif child_.nodeType == Node.ELEMENT_NODE and \
-            nodeName_ == 'reimplements':
+                nodeName_ == 'reimplements':
             obj_ = reimplementType.factory()
             obj_.build(child_)
             self.reimplements.append(obj_)
         elif child_.nodeType == Node.ELEMENT_NODE and \
-            nodeName_ == 'reimplementedby':
+                nodeName_ == 'reimplementedby':
             obj_ = reimplementType.factory()
             obj_.build(child_)
             self.reimplementedby.append(obj_)
         elif child_.nodeType == Node.ELEMENT_NODE and \
-            nodeName_ == 'param':
+                nodeName_ == 'param':
             obj_ = paramType.factory()
             obj_.build(child_)
             self.param.append(obj_)
         elif child_.nodeType == Node.ELEMENT_NODE and \
-            nodeName_ == 'enumvalue':
+                nodeName_ == 'enumvalue':
             obj_ = enumvalueType.factory()
             obj_.build(child_)
             self.enumvalue.append(obj_)
         elif child_.nodeType == Node.ELEMENT_NODE and \
-            nodeName_ == 'initializer':
+                nodeName_ == 'initializer':
             obj_ = linkedTextType.factory()
             obj_.build(child_)
             self.set_initializer(obj_)
         elif child_.nodeType == Node.ELEMENT_NODE and \
-            nodeName_ == 'exceptions':
+                nodeName_ == 'exceptions':
             obj_ = linkedTextType.factory()
             obj_.build(child_)
             self.set_exceptions(obj_)
         elif child_.nodeType == Node.ELEMENT_NODE and \
-            nodeName_ == 'briefdescription':
+                nodeName_ == 'briefdescription':
             obj_ = descriptionType.factory()
             obj_.build(child_)
             self.set_briefdescription(obj_)
         elif child_.nodeType == Node.ELEMENT_NODE and \
-            nodeName_ == 'detaileddescription':
+                nodeName_ == 'detaileddescription':
             obj_ = descriptionType.factory()
             obj_.build(child_)
             self.set_detaileddescription(obj_)
         elif child_.nodeType == Node.ELEMENT_NODE and \
-            nodeName_ == 'inbodydescription':
+                nodeName_ == 'inbodydescription':
             obj_ = descriptionType.factory()
             obj_.build(child_)
             self.set_inbodydescription(obj_)
         elif child_.nodeType == Node.ELEMENT_NODE and \
-            nodeName_ == 'location':
+                nodeName_ == 'location':
             obj_ = locationType.factory()
             obj_.build(child_)
             self.set_location(obj_)
         elif child_.nodeType == Node.ELEMENT_NODE and \
-            nodeName_ == 'references':
+                nodeName_ == 'references':
             obj_ = referenceType.factory()
             obj_.build(child_)
             self.references.append(obj_)
         elif child_.nodeType == Node.ELEMENT_NODE and \
-            nodeName_ == 'referencedby':
+                nodeName_ == 'referencedby':
             obj_ = referenceType.factory()
             obj_.build(child_)
             self.referencedby.append(obj_)
@@ -2421,8 +2715,10 @@ class memberdefType(GeneratedsSuper):
 class definition(GeneratedsSuper):
     subclass = None
     superclass = None
+
     def __init__(self, valueOf_=''):
         self.valueOf_ = valueOf_
+
     def factory(*args_, **kwargs_):
         if definition.subclass:
             return definition.subclass(*args_, **kwargs_)
@@ -2431,6 +2727,7 @@ class definition(GeneratedsSuper):
     factory = staticmethod(factory)
     def getValueOf_(self): return self.valueOf_
     def setValueOf_(self, valueOf_): self.valueOf_ = valueOf_
+
     def export(self, outfile, level, namespace_='', name_='definition', namespacedef_=''):
         showIndent(outfile, level)
         outfile.write('<%s%s %s' % (namespace_, name_, namespacedef_, ))
@@ -2442,33 +2739,40 @@ class definition(GeneratedsSuper):
             outfile.write('</%s%s>\n' % (namespace_, name_))
         else:
             outfile.write(' />\n')
+
     def exportAttributes(self, outfile, level, namespace_='', name_='definition'):
         pass
+
     def exportChildren(self, outfile, level, namespace_='', name_='definition'):
-        if self.valueOf_.find('![CDATA')>-1:
-            value=quote_xml('%s' % self.valueOf_)
-            value=value.replace('![CDATA','<![CDATA')
-            value=value.replace(']]',']]>')
+        if self.valueOf_.find('![CDATA') > -1:
+            value = quote_xml('%s' % self.valueOf_)
+            value = value.replace('![CDATA', '<![CDATA')
+            value = value.replace(']]', ']]>')
             outfile.write(value)
         else:
             outfile.write(quote_xml('%s' % self.valueOf_))
+
     def hasContent_(self):
         if (
             self.valueOf_ is not None
-            ):
+        ):
             return True
         else:
             return False
+
     def exportLiteral(self, outfile, level, name_='definition'):
         level += 1
         self.exportLiteralAttributes(outfile, level, name_)
         if self.hasContent_():
             self.exportLiteralChildren(outfile, level, name_)
+
     def exportLiteralAttributes(self, outfile, level, name_):
         pass
+
     def exportLiteralChildren(self, outfile, level, name_):
         showIndent(outfile, level)
         outfile.write('valueOf_ = "%s",\n' % (self.valueOf_,))
+
     def build(self, node_):
         attrs = node_.attributes
         self.buildAttributes(attrs)
@@ -2476,21 +2780,25 @@ class definition(GeneratedsSuper):
         for child_ in node_.childNodes:
             nodeName_ = child_.nodeName.split(':')[-1]
             self.buildChildren(child_, nodeName_)
+
     def buildAttributes(self, attrs):
         pass
+
     def buildChildren(self, child_, nodeName_):
         if child_.nodeType == Node.TEXT_NODE:
             self.valueOf_ += child_.nodeValue
         elif child_.nodeType == Node.CDATA_SECTION_NODE:
-            self.valueOf_ += '![CDATA['+child_.nodeValue+']]'
+            self.valueOf_ += '![CDATA[' + child_.nodeValue + ']]'
 # end class definition
 
 
 class argsstring(GeneratedsSuper):
     subclass = None
     superclass = None
+
     def __init__(self, valueOf_=''):
         self.valueOf_ = valueOf_
+
     def factory(*args_, **kwargs_):
         if argsstring.subclass:
             return argsstring.subclass(*args_, **kwargs_)
@@ -2499,6 +2807,7 @@ class argsstring(GeneratedsSuper):
     factory = staticmethod(factory)
     def getValueOf_(self): return self.valueOf_
     def setValueOf_(self, valueOf_): self.valueOf_ = valueOf_
+
     def export(self, outfile, level, namespace_='', name_='argsstring', namespacedef_=''):
         showIndent(outfile, level)
         outfile.write('<%s%s %s' % (namespace_, name_, namespacedef_, ))
@@ -2510,33 +2819,40 @@ class argsstring(GeneratedsSuper):
             outfile.write('</%s%s>\n' % (namespace_, name_))
         else:
             outfile.write(' />\n')
+
     def exportAttributes(self, outfile, level, namespace_='', name_='argsstring'):
         pass
+
     def exportChildren(self, outfile, level, namespace_='', name_='argsstring'):
-        if self.valueOf_.find('![CDATA')>-1:
-            value=quote_xml('%s' % self.valueOf_)
-            value=value.replace('![CDATA','<![CDATA')
-            value=value.replace(']]',']]>')
+        if self.valueOf_.find('![CDATA') > -1:
+            value = quote_xml('%s' % self.valueOf_)
+            value = value.replace('![CDATA', '<![CDATA')
+            value = value.replace(']]', ']]>')
             outfile.write(value)
         else:
             outfile.write(quote_xml('%s' % self.valueOf_))
+
     def hasContent_(self):
         if (
             self.valueOf_ is not None
-            ):
+        ):
             return True
         else:
             return False
+
     def exportLiteral(self, outfile, level, name_='argsstring'):
         level += 1
         self.exportLiteralAttributes(outfile, level, name_)
         if self.hasContent_():
             self.exportLiteralChildren(outfile, level, name_)
+
     def exportLiteralAttributes(self, outfile, level, name_):
         pass
+
     def exportLiteralChildren(self, outfile, level, name_):
         showIndent(outfile, level)
         outfile.write('valueOf_ = "%s",\n' % (self.valueOf_,))
+
     def build(self, node_):
         attrs = node_.attributes
         self.buildAttributes(attrs)
@@ -2544,21 +2860,25 @@ class argsstring(GeneratedsSuper):
         for child_ in node_.childNodes:
             nodeName_ = child_.nodeName.split(':')[-1]
             self.buildChildren(child_, nodeName_)
+
     def buildAttributes(self, attrs):
         pass
+
     def buildChildren(self, child_, nodeName_):
         if child_.nodeType == Node.TEXT_NODE:
             self.valueOf_ += child_.nodeValue
         elif child_.nodeType == Node.CDATA_SECTION_NODE:
-            self.valueOf_ += '![CDATA['+child_.nodeValue+']]'
+            self.valueOf_ += '![CDATA[' + child_.nodeValue + ']]'
 # end class argsstring
 
 
 class read(GeneratedsSuper):
     subclass = None
     superclass = None
+
     def __init__(self, valueOf_=''):
         self.valueOf_ = valueOf_
+
     def factory(*args_, **kwargs_):
         if read.subclass:
             return read.subclass(*args_, **kwargs_)
@@ -2567,6 +2887,7 @@ class read(GeneratedsSuper):
     factory = staticmethod(factory)
     def getValueOf_(self): return self.valueOf_
     def setValueOf_(self, valueOf_): self.valueOf_ = valueOf_
+
     def export(self, outfile, level, namespace_='', name_='read', namespacedef_=''):
         showIndent(outfile, level)
         outfile.write('<%s%s %s' % (namespace_, name_, namespacedef_, ))
@@ -2578,33 +2899,40 @@ class read(GeneratedsSuper):
             outfile.write('</%s%s>\n' % (namespace_, name_))
         else:
             outfile.write(' />\n')
+
     def exportAttributes(self, outfile, level, namespace_='', name_='read'):
         pass
+
     def exportChildren(self, outfile, level, namespace_='', name_='read'):
-        if self.valueOf_.find('![CDATA')>-1:
-            value=quote_xml('%s' % self.valueOf_)
-            value=value.replace('![CDATA','<![CDATA')
-            value=value.replace(']]',']]>')
+        if self.valueOf_.find('![CDATA') > -1:
+            value = quote_xml('%s' % self.valueOf_)
+            value = value.replace('![CDATA', '<![CDATA')
+            value = value.replace(']]', ']]>')
             outfile.write(value)
         else:
             outfile.write(quote_xml('%s' % self.valueOf_))
+
     def hasContent_(self):
         if (
             self.valueOf_ is not None
-            ):
+        ):
             return True
         else:
             return False
+
     def exportLiteral(self, outfile, level, name_='read'):
         level += 1
         self.exportLiteralAttributes(outfile, level, name_)
         if self.hasContent_():
             self.exportLiteralChildren(outfile, level, name_)
+
     def exportLiteralAttributes(self, outfile, level, name_):
         pass
+
     def exportLiteralChildren(self, outfile, level, name_):
         showIndent(outfile, level)
         outfile.write('valueOf_ = "%s",\n' % (self.valueOf_,))
+
     def build(self, node_):
         attrs = node_.attributes
         self.buildAttributes(attrs)
@@ -2612,21 +2940,25 @@ class read(GeneratedsSuper):
         for child_ in node_.childNodes:
             nodeName_ = child_.nodeName.split(':')[-1]
             self.buildChildren(child_, nodeName_)
+
     def buildAttributes(self, attrs):
         pass
+
     def buildChildren(self, child_, nodeName_):
         if child_.nodeType == Node.TEXT_NODE:
             self.valueOf_ += child_.nodeValue
         elif child_.nodeType == Node.CDATA_SECTION_NODE:
-            self.valueOf_ += '![CDATA['+child_.nodeValue+']]'
+            self.valueOf_ += '![CDATA[' + child_.nodeValue + ']]'
 # end class read
 
 
 class write(GeneratedsSuper):
     subclass = None
     superclass = None
+
     def __init__(self, valueOf_=''):
         self.valueOf_ = valueOf_
+
     def factory(*args_, **kwargs_):
         if write.subclass:
             return write.subclass(*args_, **kwargs_)
@@ -2635,6 +2967,7 @@ class write(GeneratedsSuper):
     factory = staticmethod(factory)
     def getValueOf_(self): return self.valueOf_
     def setValueOf_(self, valueOf_): self.valueOf_ = valueOf_
+
     def export(self, outfile, level, namespace_='', name_='write', namespacedef_=''):
         showIndent(outfile, level)
         outfile.write('<%s%s %s' % (namespace_, name_, namespacedef_, ))
@@ -2646,33 +2979,40 @@ class write(GeneratedsSuper):
             outfile.write('</%s%s>\n' % (namespace_, name_))
         else:
             outfile.write(' />\n')
+
     def exportAttributes(self, outfile, level, namespace_='', name_='write'):
         pass
+
     def exportChildren(self, outfile, level, namespace_='', name_='write'):
-        if self.valueOf_.find('![CDATA')>-1:
-            value=quote_xml('%s' % self.valueOf_)
-            value=value.replace('![CDATA','<![CDATA')
-            value=value.replace(']]',']]>')
+        if self.valueOf_.find('![CDATA') > -1:
+            value = quote_xml('%s' % self.valueOf_)
+            value = value.replace('![CDATA', '<![CDATA')
+            value = value.replace(']]', ']]>')
             outfile.write(value)
         else:
             outfile.write(quote_xml('%s' % self.valueOf_))
+
     def hasContent_(self):
         if (
             self.valueOf_ is not None
-            ):
+        ):
             return True
         else:
             return False
+
     def exportLiteral(self, outfile, level, name_='write'):
         level += 1
         self.exportLiteralAttributes(outfile, level, name_)
         if self.hasContent_():
             self.exportLiteralChildren(outfile, level, name_)
+
     def exportLiteralAttributes(self, outfile, level, name_):
         pass
+
     def exportLiteralChildren(self, outfile, level, name_):
         showIndent(outfile, level)
         outfile.write('valueOf_ = "%s",\n' % (self.valueOf_,))
+
     def build(self, node_):
         attrs = node_.attributes
         self.buildAttributes(attrs)
@@ -2680,21 +3020,25 @@ class write(GeneratedsSuper):
         for child_ in node_.childNodes:
             nodeName_ = child_.nodeName.split(':')[-1]
             self.buildChildren(child_, nodeName_)
+
     def buildAttributes(self, attrs):
         pass
+
     def buildChildren(self, child_, nodeName_):
         if child_.nodeType == Node.TEXT_NODE:
             self.valueOf_ += child_.nodeValue
         elif child_.nodeType == Node.CDATA_SECTION_NODE:
-            self.valueOf_ += '![CDATA['+child_.nodeValue+']]'
+            self.valueOf_ += '![CDATA[' + child_.nodeValue + ']]'
 # end class write
 
 
 class bitfield(GeneratedsSuper):
     subclass = None
     superclass = None
+
     def __init__(self, valueOf_=''):
         self.valueOf_ = valueOf_
+
     def factory(*args_, **kwargs_):
         if bitfield.subclass:
             return bitfield.subclass(*args_, **kwargs_)
@@ -2703,6 +3047,7 @@ class bitfield(GeneratedsSuper):
     factory = staticmethod(factory)
     def getValueOf_(self): return self.valueOf_
     def setValueOf_(self, valueOf_): self.valueOf_ = valueOf_
+
     def export(self, outfile, level, namespace_='', name_='bitfield', namespacedef_=''):
         showIndent(outfile, level)
         outfile.write('<%s%s %s' % (namespace_, name_, namespacedef_, ))
@@ -2714,33 +3059,40 @@ class bitfield(GeneratedsSuper):
             outfile.write('</%s%s>\n' % (namespace_, name_))
         else:
             outfile.write(' />\n')
+
     def exportAttributes(self, outfile, level, namespace_='', name_='bitfield'):
         pass
+
     def exportChildren(self, outfile, level, namespace_='', name_='bitfield'):
-        if self.valueOf_.find('![CDATA')>-1:
-            value=quote_xml('%s' % self.valueOf_)
-            value=value.replace('![CDATA','<![CDATA')
-            value=value.replace(']]',']]>')
+        if self.valueOf_.find('![CDATA') > -1:
+            value = quote_xml('%s' % self.valueOf_)
+            value = value.replace('![CDATA', '<![CDATA')
+            value = value.replace(']]', ']]>')
             outfile.write(value)
         else:
             outfile.write(quote_xml('%s' % self.valueOf_))
+
     def hasContent_(self):
         if (
             self.valueOf_ is not None
-            ):
+        ):
             return True
         else:
             return False
+
     def exportLiteral(self, outfile, level, name_='bitfield'):
         level += 1
         self.exportLiteralAttributes(outfile, level, name_)
         if self.hasContent_():
             self.exportLiteralChildren(outfile, level, name_)
+
     def exportLiteralAttributes(self, outfile, level, name_):
         pass
+
     def exportLiteralChildren(self, outfile, level, name_):
         showIndent(outfile, level)
         outfile.write('valueOf_ = "%s",\n' % (self.valueOf_,))
+
     def build(self, node_):
         attrs = node_.attributes
         self.buildAttributes(attrs)
@@ -2748,19 +3100,22 @@ class bitfield(GeneratedsSuper):
         for child_ in node_.childNodes:
             nodeName_ = child_.nodeName.split(':')[-1]
             self.buildChildren(child_, nodeName_)
+
     def buildAttributes(self, attrs):
         pass
+
     def buildChildren(self, child_, nodeName_):
         if child_.nodeType == Node.TEXT_NODE:
             self.valueOf_ += child_.nodeValue
         elif child_.nodeType == Node.CDATA_SECTION_NODE:
-            self.valueOf_ += '![CDATA['+child_.nodeValue+']]'
+            self.valueOf_ += '![CDATA[' + child_.nodeValue + ']]'
 # end class bitfield
 
 
 class descriptionType(GeneratedsSuper):
     subclass = None
     superclass = None
+
     def __init__(self, title=None, para=None, sect1=None, internal=None, mixedclass_=None, content_=None):
         if mixedclass_ is None:
             self.mixedclass_ = MixedContainer
@@ -2770,6 +3125,7 @@ class descriptionType(GeneratedsSuper):
             self.content_ = []
         else:
             self.content_ = content_
+
     def factory(*args_, **kwargs_):
         if descriptionType.subclass:
             return descriptionType.subclass(*args_, **kwargs_)
@@ -2788,35 +3144,43 @@ class descriptionType(GeneratedsSuper):
     def insert_sect1(self, index, value): self.sect1[index] = value
     def get_internal(self): return self.internal
     def set_internal(self, internal): self.internal = internal
+
     def export(self, outfile, level, namespace_='', name_='descriptionType', namespacedef_=''):
         showIndent(outfile, level)
         outfile.write('<%s%s %s' % (namespace_, name_, namespacedef_, ))
-        self.exportAttributes(outfile, level, namespace_, name_='descriptionType')
+        self.exportAttributes(outfile, level, namespace_,
+                              name_='descriptionType')
         outfile.write('>')
         self.exportChildren(outfile, level + 1, namespace_, name_)
         outfile.write('</%s%s>\n' % (namespace_, name_))
+
     def exportAttributes(self, outfile, level, namespace_='', name_='descriptionType'):
         pass
+
     def exportChildren(self, outfile, level, namespace_='', name_='descriptionType'):
         for item_ in self.content_:
             item_.export(outfile, level, item_.name, namespace_)
+
     def hasContent_(self):
         if (
             self.title is not None or
             self.para is not None or
             self.sect1 is not None or
             self.internal is not None
-            ):
+        ):
             return True
         else:
             return False
+
     def exportLiteral(self, outfile, level, name_='descriptionType'):
         level += 1
         self.exportLiteralAttributes(outfile, level, name_)
         if self.hasContent_():
             self.exportLiteralChildren(outfile, level, name_)
+
     def exportLiteralAttributes(self, outfile, level, name_):
         pass
+
     def exportLiteralChildren(self, outfile, level, name_):
         showIndent(outfile, level)
         outfile.write('content_ = [\n')
@@ -2842,46 +3206,49 @@ class descriptionType(GeneratedsSuper):
             item_.exportLiteral(outfile, level, name_)
         showIndent(outfile, level)
         outfile.write('],\n')
+
     def build(self, node_):
         attrs = node_.attributes
         self.buildAttributes(attrs)
         for child_ in node_.childNodes:
             nodeName_ = child_.nodeName.split(':')[-1]
             self.buildChildren(child_, nodeName_)
+
     def buildAttributes(self, attrs):
         pass
+
     def buildChildren(self, child_, nodeName_):
         if child_.nodeType == Node.ELEMENT_NODE and \
-            nodeName_ == 'title':
+                nodeName_ == 'title':
             childobj_ = docTitleType.factory()
             childobj_.build(child_)
             obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
-                MixedContainer.TypeNone, 'title', childobj_)
+                                    MixedContainer.TypeNone, 'title', childobj_)
             self.content_.append(obj_)
         elif child_.nodeType == Node.ELEMENT_NODE and \
-            nodeName_ == 'para':
+                nodeName_ == 'para':
             childobj_ = docParaType.factory()
             childobj_.build(child_)
             obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
-                MixedContainer.TypeNone, 'para', childobj_)
+                                    MixedContainer.TypeNone, 'para', childobj_)
             self.content_.append(obj_)
         elif child_.nodeType == Node.ELEMENT_NODE and \
-            nodeName_ == 'sect1':
+                nodeName_ == 'sect1':
             childobj_ = docSect1Type.factory()
             childobj_.build(child_)
             obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
-                MixedContainer.TypeNone, 'sect1', childobj_)
+                                    MixedContainer.TypeNone, 'sect1', childobj_)
             self.content_.append(obj_)
         elif child_.nodeType == Node.ELEMENT_NODE and \
-            nodeName_ == 'internal':
+                nodeName_ == 'internal':
             childobj_ = docInternalType.factory()
             childobj_.build(child_)
             obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
-                MixedContainer.TypeNone, 'internal', childobj_)
+                                    MixedContainer.TypeNone, 'internal', childobj_)
             self.content_.append(obj_)
         elif child_.nodeType == Node.TEXT_NODE:
             obj_ = self.mixedclass_(MixedContainer.CategoryText,
-                MixedContainer.TypeNone, '', child_.nodeValue)
+                                    MixedContainer.TypeNone, '', child_.nodeValue)
             self.content_.append(obj_)
 # end class descriptionType
 
@@ -2889,6 +3256,7 @@ class descriptionType(GeneratedsSuper):
 class enumvalueType(GeneratedsSuper):
     subclass = None
     superclass = None
+
     def __init__(self, prot=None, id=None, name=None, initializer=None, briefdescription=None, detaileddescription=None, mixedclass_=None, content_=None):
         self.prot = prot
         self.id = id
@@ -2900,6 +3268,7 @@ class enumvalueType(GeneratedsSuper):
             self.content_ = []
         else:
             self.content_ = content_
+
     def factory(*args_, **kwargs_):
         if enumvalueType.subclass:
             return enumvalueType.subclass(*args_, **kwargs_)
@@ -2911,43 +3280,55 @@ class enumvalueType(GeneratedsSuper):
     def get_initializer(self): return self.initializer
     def set_initializer(self, initializer): self.initializer = initializer
     def get_briefdescription(self): return self.briefdescription
-    def set_briefdescription(self, briefdescription): self.briefdescription = briefdescription
+    def set_briefdescription(
+        self, briefdescription): self.briefdescription = briefdescription
+
     def get_detaileddescription(self): return self.detaileddescription
-    def set_detaileddescription(self, detaileddescription): self.detaileddescription = detaileddescription
+    def set_detaileddescription(
+        self, detaileddescription): self.detaileddescription = detaileddescription
+
     def get_prot(self): return self.prot
     def set_prot(self, prot): self.prot = prot
     def get_id(self): return self.id
     def set_id(self, id): self.id = id
+
     def export(self, outfile, level, namespace_='', name_='enumvalueType', namespacedef_=''):
         showIndent(outfile, level)
         outfile.write('<%s%s %s' % (namespace_, name_, namespacedef_, ))
-        self.exportAttributes(outfile, level, namespace_, name_='enumvalueType')
+        self.exportAttributes(outfile, level, namespace_,
+                              name_='enumvalueType')
         outfile.write('>')
         self.exportChildren(outfile, level + 1, namespace_, name_)
         outfile.write('</%s%s>\n' % (namespace_, name_))
+
     def exportAttributes(self, outfile, level, namespace_='', name_='enumvalueType'):
         if self.prot is not None:
             outfile.write(' prot=%s' % (quote_attrib(self.prot), ))
         if self.id is not None:
-            outfile.write(' id=%s' % (self.format_string(quote_attrib(self.id).encode(ExternalEncoding), input_name='id'), ))
+            outfile.write(' id=%s' % (self.format_string(quote_attrib(
+                self.id).encode(ExternalEncoding), input_name='id'), ))
+
     def exportChildren(self, outfile, level, namespace_='', name_='enumvalueType'):
         for item_ in self.content_:
             item_.export(outfile, level, item_.name, namespace_)
+
     def hasContent_(self):
         if (
             self.name is not None or
             self.initializer is not None or
             self.briefdescription is not None or
             self.detaileddescription is not None
-            ):
+        ):
             return True
         else:
             return False
+
     def exportLiteral(self, outfile, level, name_='enumvalueType'):
         level += 1
         self.exportLiteralAttributes(outfile, level, name_)
         if self.hasContent_():
             self.exportLiteralChildren(outfile, level, name_)
+
     def exportLiteralAttributes(self, outfile, level, name_):
         if self.prot is not None:
             showIndent(outfile, level)
@@ -2955,6 +3336,7 @@ class enumvalueType(GeneratedsSuper):
         if self.id is not None:
             showIndent(outfile, level)
             outfile.write('id = %s,\n' % (self.id,))
+
     def exportLiteralChildren(self, outfile, level, name_):
         showIndent(outfile, level)
         outfile.write('content_ = [\n')
@@ -2980,51 +3362,54 @@ class enumvalueType(GeneratedsSuper):
             item_.exportLiteral(outfile, level, name_)
         showIndent(outfile, level)
         outfile.write('],\n')
+
     def build(self, node_):
         attrs = node_.attributes
         self.buildAttributes(attrs)
         for child_ in node_.childNodes:
             nodeName_ = child_.nodeName.split(':')[-1]
             self.buildChildren(child_, nodeName_)
+
     def buildAttributes(self, attrs):
         if attrs.get('prot'):
             self.prot = attrs.get('prot').value
         if attrs.get('id'):
             self.id = attrs.get('id').value
+
     def buildChildren(self, child_, nodeName_):
         if child_.nodeType == Node.ELEMENT_NODE and \
-            nodeName_ == 'name':
+                nodeName_ == 'name':
             value_ = []
             for text_ in child_.childNodes:
                 value_.append(text_.nodeValue)
             valuestr_ = ''.join(value_)
             obj_ = self.mixedclass_(MixedContainer.CategorySimple,
-                MixedContainer.TypeString, 'name', valuestr_)
+                                    MixedContainer.TypeString, 'name', valuestr_)
             self.content_.append(obj_)
         elif child_.nodeType == Node.ELEMENT_NODE and \
-            nodeName_ == 'initializer':
+                nodeName_ == 'initializer':
             childobj_ = linkedTextType.factory()
             childobj_.build(child_)
             obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
-                MixedContainer.TypeNone, 'initializer', childobj_)
+                                    MixedContainer.TypeNone, 'initializer', childobj_)
             self.content_.append(obj_)
         elif child_.nodeType == Node.ELEMENT_NODE and \
-            nodeName_ == 'briefdescription':
+                nodeName_ == 'briefdescription':
             childobj_ = descriptionType.factory()
             childobj_.build(child_)
             obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
-                MixedContainer.TypeNone, 'briefdescription', childobj_)
+                                    MixedContainer.TypeNone, 'briefdescription', childobj_)
             self.content_.append(obj_)
         elif child_.nodeType == Node.ELEMENT_NODE and \
-            nodeName_ == 'detaileddescription':
+                nodeName_ == 'detaileddescription':
             childobj_ = descriptionType.factory()
             childobj_.build(child_)
             obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
-                MixedContainer.TypeNone, 'detaileddescription', childobj_)
+                                    MixedContainer.TypeNone, 'detaileddescription', childobj_)
             self.content_.append(obj_)
         elif child_.nodeType == Node.TEXT_NODE:
             obj_ = self.mixedclass_(MixedContainer.CategoryText,
-                MixedContainer.TypeNone, '', child_.nodeValue)
+                                    MixedContainer.TypeNone, '', child_.nodeValue)
             self.content_.append(obj_)
 # end class enumvalueType
 
@@ -3032,11 +3417,13 @@ class enumvalueType(GeneratedsSuper):
 class templateparamlistType(GeneratedsSuper):
     subclass = None
     superclass = None
+
     def __init__(self, param=None):
         if param is None:
             self.param = []
         else:
             self.param = param
+
     def factory(*args_, **kwargs_):
         if templateparamlistType.subclass:
             return templateparamlistType.subclass(*args_, **kwargs_)
@@ -3047,10 +3434,12 @@ class templateparamlistType(GeneratedsSuper):
     def set_param(self, param): self.param = param
     def add_param(self, value): self.param.append(value)
     def insert_param(self, index, value): self.param[index] = value
+
     def export(self, outfile, level, namespace_='', name_='templateparamlistType', namespacedef_=''):
         showIndent(outfile, level)
         outfile.write('<%s%s %s' % (namespace_, name_, namespacedef_, ))
-        self.exportAttributes(outfile, level, namespace_, name_='templateparamlistType')
+        self.exportAttributes(outfile, level, namespace_,
+                              name_='templateparamlistType')
         if self.hasContent_():
             outfile.write('>\n')
             self.exportChildren(outfile, level + 1, namespace_, name_)
@@ -3058,25 +3447,31 @@ class templateparamlistType(GeneratedsSuper):
             outfile.write('</%s%s>\n' % (namespace_, name_))
         else:
             outfile.write(' />\n')
+
     def exportAttributes(self, outfile, level, namespace_='', name_='templateparamlistType'):
         pass
+
     def exportChildren(self, outfile, level, namespace_='', name_='templateparamlistType'):
         for param_ in self.param:
             param_.export(outfile, level, namespace_, name_='param')
+
     def hasContent_(self):
         if (
             self.param is not None
-            ):
+        ):
             return True
         else:
             return False
+
     def exportLiteral(self, outfile, level, name_='templateparamlistType'):
         level += 1
         self.exportLiteralAttributes(outfile, level, name_)
         if self.hasContent_():
             self.exportLiteralChildren(outfile, level, name_)
+
     def exportLiteralAttributes(self, outfile, level, name_):
         pass
+
     def exportLiteralChildren(self, outfile, level, name_):
         showIndent(outfile, level)
         outfile.write('param=[\n')
@@ -3090,17 +3485,20 @@ class templateparamlistType(GeneratedsSuper):
         level -= 1
         showIndent(outfile, level)
         outfile.write('],\n')
+
     def build(self, node_):
         attrs = node_.attributes
         self.buildAttributes(attrs)
         for child_ in node_.childNodes:
             nodeName_ = child_.nodeName.split(':')[-1]
             self.buildChildren(child_, nodeName_)
+
     def buildAttributes(self, attrs):
         pass
+
     def buildChildren(self, child_, nodeName_):
         if child_.nodeType == Node.ELEMENT_NODE and \
-            nodeName_ == 'param':
+                nodeName_ == 'param':
             obj_ = paramType.factory()
             obj_.build(child_)
             self.param.append(obj_)
@@ -3110,6 +3508,7 @@ class templateparamlistType(GeneratedsSuper):
 class paramType(GeneratedsSuper):
     subclass = None
     superclass = None
+
     def __init__(self, type_=None, declname=None, defname=None, array=None, defval=None, briefdescription=None):
         self.type_ = type_
         self.declname = declname
@@ -3117,6 +3516,7 @@ class paramType(GeneratedsSuper):
         self.array = array
         self.defval = defval
         self.briefdescription = briefdescription
+
     def factory(*args_, **kwargs_):
         if paramType.subclass:
             return paramType.subclass(*args_, **kwargs_)
@@ -3134,7 +3534,10 @@ class paramType(GeneratedsSuper):
     def get_defval(self): return self.defval
     def set_defval(self, defval): self.defval = defval
     def get_briefdescription(self): return self.briefdescription
-    def set_briefdescription(self, briefdescription): self.briefdescription = briefdescription
+
+    def set_briefdescription(
+        self, briefdescription): self.briefdescription = briefdescription
+
     def export(self, outfile, level, namespace_='', name_='paramType', namespacedef_=''):
         showIndent(outfile, level)
         outfile.write('<%s%s %s' % (namespace_, name_, namespacedef_, ))
@@ -3146,24 +3549,31 @@ class paramType(GeneratedsSuper):
             outfile.write('</%s%s>\n' % (namespace_, name_))
         else:
             outfile.write(' />\n')
+
     def exportAttributes(self, outfile, level, namespace_='', name_='paramType'):
         pass
+
     def exportChildren(self, outfile, level, namespace_='', name_='paramType'):
         if self.type_:
             self.type_.export(outfile, level, namespace_, name_='type')
         if self.declname is not None:
             showIndent(outfile, level)
-            outfile.write('<%sdeclname>%s</%sdeclname>\n' % (namespace_, self.format_string(quote_xml(self.declname).encode(ExternalEncoding), input_name='declname'), namespace_))
+            outfile.write('<%sdeclname>%s</%sdeclname>\n' % (namespace_, self.format_string(
+                quote_xml(self.declname).encode(ExternalEncoding), input_name='declname'), namespace_))
         if self.defname is not None:
             showIndent(outfile, level)
-            outfile.write('<%sdefname>%s</%sdefname>\n' % (namespace_, self.format_string(quote_xml(self.defname).encode(ExternalEncoding), input_name='defname'), namespace_))
+            outfile.write('<%sdefname>%s</%sdefname>\n' % (namespace_, self.format_string(
+                quote_xml(self.defname).encode(ExternalEncoding), input_name='defname'), namespace_))
         if self.array is not None:
             showIndent(outfile, level)
-            outfile.write('<%sarray>%s</%sarray>\n' % (namespace_, self.format_string(quote_xml(self.array).encode(ExternalEncoding), input_name='array'), namespace_))
+            outfile.write('<%sarray>%s</%sarray>\n' % (namespace_, self.format_string(
+                quote_xml(self.array).encode(ExternalEncoding), input_name='array'), namespace_))
         if self.defval:
             self.defval.export(outfile, level, namespace_, name_='defval')
         if self.briefdescription:
-            self.briefdescription.export(outfile, level, namespace_, name_='briefdescription')
+            self.briefdescription.export(
+                outfile, level, namespace_, name_='briefdescription')
+
     def hasContent_(self):
         if (
             self.type_ is not None or
@@ -3172,17 +3582,20 @@ class paramType(GeneratedsSuper):
             self.array is not None or
             self.defval is not None or
             self.briefdescription is not None
-            ):
+        ):
             return True
         else:
             return False
+
     def exportLiteral(self, outfile, level, name_='paramType'):
         level += 1
         self.exportLiteralAttributes(outfile, level, name_)
         if self.hasContent_():
             self.exportLiteralChildren(outfile, level, name_)
+
     def exportLiteralAttributes(self, outfile, level, name_):
         pass
+
     def exportLiteralChildren(self, outfile, level, name_):
         if self.type_:
             showIndent(outfile, level)
@@ -3191,11 +3604,14 @@ class paramType(GeneratedsSuper):
             showIndent(outfile, level)
             outfile.write('),\n')
         showIndent(outfile, level)
-        outfile.write('declname=%s,\n' % quote_python(self.declname).encode(ExternalEncoding))
+        outfile.write('declname=%s,\n' % quote_python(
+            self.declname).encode(ExternalEncoding))
         showIndent(outfile, level)
-        outfile.write('defname=%s,\n' % quote_python(self.defname).encode(ExternalEncoding))
+        outfile.write('defname=%s,\n' % quote_python(
+            self.defname).encode(ExternalEncoding))
         showIndent(outfile, level)
-        outfile.write('array=%s,\n' % quote_python(self.array).encode(ExternalEncoding))
+        outfile.write('array=%s,\n' % quote_python(
+            self.array).encode(ExternalEncoding))
         if self.defval:
             showIndent(outfile, level)
             outfile.write('defval=model_.linkedTextType(\n')
@@ -3205,48 +3621,52 @@ class paramType(GeneratedsSuper):
         if self.briefdescription:
             showIndent(outfile, level)
             outfile.write('briefdescription=model_.descriptionType(\n')
-            self.briefdescription.exportLiteral(outfile, level, name_='briefdescription')
+            self.briefdescription.exportLiteral(
+                outfile, level, name_='briefdescription')
             showIndent(outfile, level)
             outfile.write('),\n')
+
     def build(self, node_):
         attrs = node_.attributes
         self.buildAttributes(attrs)
         for child_ in node_.childNodes:
             nodeName_ = child_.nodeName.split(':')[-1]
             self.buildChildren(child_, nodeName_)
+
     def buildAttributes(self, attrs):
         pass
+
     def buildChildren(self, child_, nodeName_):
         if child_.nodeType == Node.ELEMENT_NODE and \
-            nodeName_ == 'type':
+                nodeName_ == 'type':
             obj_ = linkedTextType.factory()
             obj_.build(child_)
             self.set_type(obj_)
         elif child_.nodeType == Node.ELEMENT_NODE and \
-            nodeName_ == 'declname':
+                nodeName_ == 'declname':
             declname_ = ''
             for text__content_ in child_.childNodes:
                 declname_ += text__content_.nodeValue
             self.declname = declname_
         elif child_.nodeType == Node.ELEMENT_NODE and \
-            nodeName_ == 'defname':
+                nodeName_ == 'defname':
             defname_ = ''
             for text__content_ in child_.childNodes:
                 defname_ += text__content_.nodeValue
             self.defname = defname_
         elif child_.nodeType == Node.ELEMENT_NODE and \
-            nodeName_ == 'array':
+                nodeName_ == 'array':
             array_ = ''
             for text__content_ in child_.childNodes:
                 array_ += text__content_.nodeValue
             self.array = array_
         elif child_.nodeType == Node.ELEMENT_NODE and \
-            nodeName_ == 'defval':
+                nodeName_ == 'defval':
             obj_ = linkedTextType.factory()
             obj_.build(child_)
             self.set_defval(obj_)
         elif child_.nodeType == Node.ELEMENT_NODE and \
-            nodeName_ == 'briefdescription':
+                nodeName_ == 'briefdescription':
             obj_ = descriptionType.factory()
             obj_.build(child_)
             self.set_briefdescription(obj_)
@@ -3256,8 +3676,10 @@ class paramType(GeneratedsSuper):
 class declname(GeneratedsSuper):
     subclass = None
     superclass = None
+
     def __init__(self, valueOf_=''):
         self.valueOf_ = valueOf_
+
     def factory(*args_, **kwargs_):
         if declname.subclass:
             return declname.subclass(*args_, **kwargs_)
@@ -3266,6 +3688,7 @@ class declname(GeneratedsSuper):
     factory = staticmethod(factory)
     def getValueOf_(self): return self.valueOf_
     def setValueOf_(self, valueOf_): self.valueOf_ = valueOf_
+
     def export(self, outfile, level, namespace_='', name_='declname', namespacedef_=''):
         showIndent(outfile, level)
         outfile.write('<%s%s %s' % (namespace_, name_, namespacedef_, ))
@@ -3277,33 +3700,40 @@ class declname(GeneratedsSuper):
             outfile.write('</%s%s>\n' % (namespace_, name_))
         else:
             outfile.write(' />\n')
+
     def exportAttributes(self, outfile, level, namespace_='', name_='declname'):
         pass
+
     def exportChildren(self, outfile, level, namespace_='', name_='declname'):
-        if self.valueOf_.find('![CDATA')>-1:
-            value=quote_xml('%s' % self.valueOf_)
-            value=value.replace('![CDATA','<![CDATA')
-            value=value.replace(']]',']]>')
+        if self.valueOf_.find('![CDATA') > -1:
+            value = quote_xml('%s' % self.valueOf_)
+            value = value.replace('![CDATA', '<![CDATA')
+            value = value.replace(']]', ']]>')
             outfile.write(value)
         else:
             outfile.write(quote_xml('%s' % self.valueOf_))
+
     def hasContent_(self):
         if (
             self.valueOf_ is not None
-            ):
+        ):
             return True
         else:
             return False
+
     def exportLiteral(self, outfile, level, name_='declname'):
         level += 1
         self.exportLiteralAttributes(outfile, level, name_)
         if self.hasContent_():
             self.exportLiteralChildren(outfile, level, name_)
+
     def exportLiteralAttributes(self, outfile, level, name_):
         pass
+
     def exportLiteralChildren(self, outfile, level, name_):
         showIndent(outfile, level)
         outfile.write('valueOf_ = "%s",\n' % (self.valueOf_,))
+
     def build(self, node_):
         attrs = node_.attributes
         self.buildAttributes(attrs)
@@ -3311,21 +3741,25 @@ class declname(GeneratedsSuper):
         for child_ in node_.childNodes:
             nodeName_ = child_.nodeName.split(':')[-1]
             self.buildChildren(child_, nodeName_)
+
     def buildAttributes(self, attrs):
         pass
+
     def buildChildren(self, child_, nodeName_):
         if child_.nodeType == Node.TEXT_NODE:
             self.valueOf_ += child_.nodeValue
         elif child_.nodeType == Node.CDATA_SECTION_NODE:
-            self.valueOf_ += '![CDATA['+child_.nodeValue+']]'
+            self.valueOf_ += '![CDATA[' + child_.nodeValue + ']]'
 # end class declname
 
 
 class defname(GeneratedsSuper):
     subclass = None
     superclass = None
+
     def __init__(self, valueOf_=''):
         self.valueOf_ = valueOf_
+
     def factory(*args_, **kwargs_):
         if defname.subclass:
             return defname.subclass(*args_, **kwargs_)
@@ -3334,6 +3768,7 @@ class defname(GeneratedsSuper):
     factory = staticmethod(factory)
     def getValueOf_(self): return self.valueOf_
     def setValueOf_(self, valueOf_): self.valueOf_ = valueOf_
+
     def export(self, outfile, level, namespace_='', name_='defname', namespacedef_=''):
         showIndent(outfile, level)
         outfile.write('<%s%s %s' % (namespace_, name_, namespacedef_, ))
@@ -3345,33 +3780,40 @@ class defname(GeneratedsSuper):
             outfile.write('</%s%s>\n' % (namespace_, name_))
         else:
             outfile.write(' />\n')
+
     def exportAttributes(self, outfile, level, namespace_='', name_='defname'):
         pass
+
     def exportChildren(self, outfile, level, namespace_='', name_='defname'):
-        if self.valueOf_.find('![CDATA')>-1:
-            value=quote_xml('%s' % self.valueOf_)
-            value=value.replace('![CDATA','<![CDATA')
-            value=value.replace(']]',']]>')
+        if self.valueOf_.find('![CDATA') > -1:
+            value = quote_xml('%s' % self.valueOf_)
+            value = value.replace('![CDATA', '<![CDATA')
+            value = value.replace(']]', ']]>')
             outfile.write(value)
         else:
             outfile.write(quote_xml('%s' % self.valueOf_))
+
     def hasContent_(self):
         if (
             self.valueOf_ is not None
-            ):
+        ):
             return True
         else:
             return False
+
     def exportLiteral(self, outfile, level, name_='defname'):
         level += 1
         self.exportLiteralAttributes(outfile, level, name_)
         if self.hasContent_():
             self.exportLiteralChildren(outfile, level, name_)
+
     def exportLiteralAttributes(self, outfile, level, name_):
         pass
+
     def exportLiteralChildren(self, outfile, level, name_):
         showIndent(outfile, level)
         outfile.write('valueOf_ = "%s",\n' % (self.valueOf_,))
+
     def build(self, node_):
         attrs = node_.attributes
         self.buildAttributes(attrs)
@@ -3379,21 +3821,25 @@ class defname(GeneratedsSuper):
         for child_ in node_.childNodes:
             nodeName_ = child_.nodeName.split(':')[-1]
             self.buildChildren(child_, nodeName_)
+
     def buildAttributes(self, attrs):
         pass
+
     def buildChildren(self, child_, nodeName_):
         if child_.nodeType == Node.TEXT_NODE:
             self.valueOf_ += child_.nodeValue
         elif child_.nodeType == Node.CDATA_SECTION_NODE:
-            self.valueOf_ += '![CDATA['+child_.nodeValue+']]'
+            self.valueOf_ += '![CDATA[' + child_.nodeValue + ']]'
 # end class defname
 
 
 class array(GeneratedsSuper):
     subclass = None
     superclass = None
+
     def __init__(self, valueOf_=''):
         self.valueOf_ = valueOf_
+
     def factory(*args_, **kwargs_):
         if array.subclass:
             return array.subclass(*args_, **kwargs_)
@@ -3402,6 +3848,7 @@ class array(GeneratedsSuper):
     factory = staticmethod(factory)
     def getValueOf_(self): return self.valueOf_
     def setValueOf_(self, valueOf_): self.valueOf_ = valueOf_
+
     def export(self, outfile, level, namespace_='', name_='array', namespacedef_=''):
         showIndent(outfile, level)
         outfile.write('<%s%s %s' % (namespace_, name_, namespacedef_, ))
@@ -3413,33 +3860,40 @@ class array(GeneratedsSuper):
             outfile.write('</%s%s>\n' % (namespace_, name_))
         else:
             outfile.write(' />\n')
+
     def exportAttributes(self, outfile, level, namespace_='', name_='array'):
         pass
+
     def exportChildren(self, outfile, level, namespace_='', name_='array'):
-        if self.valueOf_.find('![CDATA')>-1:
-            value=quote_xml('%s' % self.valueOf_)
-            value=value.replace('![CDATA','<![CDATA')
-            value=value.replace(']]',']]>')
+        if self.valueOf_.find('![CDATA') > -1:
+            value = quote_xml('%s' % self.valueOf_)
+            value = value.replace('![CDATA', '<![CDATA')
+            value = value.replace(']]', ']]>')
             outfile.write(value)
         else:
             outfile.write(quote_xml('%s' % self.valueOf_))
+
     def hasContent_(self):
         if (
             self.valueOf_ is not None
-            ):
+        ):
             return True
         else:
             return False
+
     def exportLiteral(self, outfile, level, name_='array'):
         level += 1
         self.exportLiteralAttributes(outfile, level, name_)
         if self.hasContent_():
             self.exportLiteralChildren(outfile, level, name_)
+
     def exportLiteralAttributes(self, outfile, level, name_):
         pass
+
     def exportLiteralChildren(self, outfile, level, name_):
         showIndent(outfile, level)
         outfile.write('valueOf_ = "%s",\n' % (self.valueOf_,))
+
     def build(self, node_):
         attrs = node_.attributes
         self.buildAttributes(attrs)
@@ -3447,19 +3901,22 @@ class array(GeneratedsSuper):
         for child_ in node_.childNodes:
             nodeName_ = child_.nodeName.split(':')[-1]
             self.buildChildren(child_, nodeName_)
+
     def buildAttributes(self, attrs):
         pass
+
     def buildChildren(self, child_, nodeName_):
         if child_.nodeType == Node.TEXT_NODE:
             self.valueOf_ += child_.nodeValue
         elif child_.nodeType == Node.CDATA_SECTION_NODE:
-            self.valueOf_ += '![CDATA['+child_.nodeValue+']]'
+            self.valueOf_ += '![CDATA[' + child_.nodeValue + ']]'
 # end class array
 
 
 class linkedTextType(GeneratedsSuper):
     subclass = None
     superclass = None
+
     def __init__(self, ref=None, mixedclass_=None, content_=None):
         if mixedclass_ is None:
             self.mixedclass_ = MixedContainer
@@ -3469,6 +3926,7 @@ class linkedTextType(GeneratedsSuper):
             self.content_ = []
         else:
             self.content_ = content_
+
     def factory(*args_, **kwargs_):
         if linkedTextType.subclass:
             return linkedTextType.subclass(*args_, **kwargs_)
@@ -3479,32 +3937,40 @@ class linkedTextType(GeneratedsSuper):
     def set_ref(self, ref): self.ref = ref
     def add_ref(self, value): self.ref.append(value)
     def insert_ref(self, index, value): self.ref[index] = value
+
     def export(self, outfile, level, namespace_='', name_='linkedTextType', namespacedef_=''):
         showIndent(outfile, level)
         outfile.write('<%s%s %s' % (namespace_, name_, namespacedef_, ))
-        self.exportAttributes(outfile, level, namespace_, name_='linkedTextType')
+        self.exportAttributes(outfile, level, namespace_,
+                              name_='linkedTextType')
         outfile.write('>')
         self.exportChildren(outfile, level + 1, namespace_, name_)
         outfile.write('</%s%s>\n' % (namespace_, name_))
+
     def exportAttributes(self, outfile, level, namespace_='', name_='linkedTextType'):
         pass
+
     def exportChildren(self, outfile, level, namespace_='', name_='linkedTextType'):
         for item_ in self.content_:
             item_.export(outfile, level, item_.name, namespace_)
+
     def hasContent_(self):
         if (
             self.ref is not None
-            ):
+        ):
             return True
         else:
             return False
+
     def exportLiteral(self, outfile, level, name_='linkedTextType'):
         level += 1
         self.exportLiteralAttributes(outfile, level, name_)
         if self.hasContent_():
             self.exportLiteralChildren(outfile, level, name_)
+
     def exportLiteralAttributes(self, outfile, level, name_):
         pass
+
     def exportLiteralChildren(self, outfile, level, name_):
         showIndent(outfile, level)
         outfile.write('content_ = [\n')
@@ -3512,25 +3978,28 @@ class linkedTextType(GeneratedsSuper):
             item_.exportLiteral(outfile, level, name_)
         showIndent(outfile, level)
         outfile.write('],\n')
+
     def build(self, node_):
         attrs = node_.attributes
         self.buildAttributes(attrs)
         for child_ in node_.childNodes:
             nodeName_ = child_.nodeName.split(':')[-1]
             self.buildChildren(child_, nodeName_)
+
     def buildAttributes(self, attrs):
         pass
+
     def buildChildren(self, child_, nodeName_):
         if child_.nodeType == Node.ELEMENT_NODE and \
-            nodeName_ == 'ref':
+                nodeName_ == 'ref':
             childobj_ = docRefTextType.factory()
             childobj_.build(child_)
             obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
-                MixedContainer.TypeNone, 'ref', childobj_)
+                                    MixedContainer.TypeNone, 'ref', childobj_)
             self.content_.append(obj_)
         elif child_.nodeType == Node.TEXT_NODE:
             obj_ = self.mixedclass_(MixedContainer.CategoryText,
-                MixedContainer.TypeNone, '', child_.nodeValue)
+                                    MixedContainer.TypeNone, '', child_.nodeValue)
             self.content_.append(obj_)
 # end class linkedTextType
 
@@ -3538,11 +4007,13 @@ class linkedTextType(GeneratedsSuper):
 class graphType(GeneratedsSuper):
     subclass = None
     superclass = None
+
     def __init__(self, node=None):
         if node is None:
             self.node = []
         else:
             self.node = node
+
     def factory(*args_, **kwargs_):
         if graphType.subclass:
             return graphType.subclass(*args_, **kwargs_)
@@ -3553,6 +4024,7 @@ class graphType(GeneratedsSuper):
     def set_node(self, node): self.node = node
     def add_node(self, value): self.node.append(value)
     def insert_node(self, index, value): self.node[index] = value
+
     def export(self, outfile, level, namespace_='', name_='graphType', namespacedef_=''):
         showIndent(outfile, level)
         outfile.write('<%s%s %s' % (namespace_, name_, namespacedef_, ))
@@ -3564,25 +4036,31 @@ class graphType(GeneratedsSuper):
             outfile.write('</%s%s>\n' % (namespace_, name_))
         else:
             outfile.write(' />\n')
+
     def exportAttributes(self, outfile, level, namespace_='', name_='graphType'):
         pass
+
     def exportChildren(self, outfile, level, namespace_='', name_='graphType'):
         for node_ in self.node:
             node_.export(outfile, level, namespace_, name_='node')
+
     def hasContent_(self):
         if (
             self.node is not None
-            ):
+        ):
             return True
         else:
             return False
+
     def exportLiteral(self, outfile, level, name_='graphType'):
         level += 1
         self.exportLiteralAttributes(outfile, level, name_)
         if self.hasContent_():
             self.exportLiteralChildren(outfile, level, name_)
+
     def exportLiteralAttributes(self, outfile, level, name_):
         pass
+
     def exportLiteralChildren(self, outfile, level, name_):
         showIndent(outfile, level)
         outfile.write('node=[\n')
@@ -3596,17 +4074,20 @@ class graphType(GeneratedsSuper):
         level -= 1
         showIndent(outfile, level)
         outfile.write('],\n')
+
     def build(self, node_):
         attrs = node_.attributes
         self.buildAttributes(attrs)
         for child_ in node_.childNodes:
             nodeName_ = child_.nodeName.split(':')[-1]
             self.buildChildren(child_, nodeName_)
+
     def buildAttributes(self, attrs):
         pass
+
     def buildChildren(self, child_, nodeName_):
         if child_.nodeType == Node.ELEMENT_NODE and \
-            nodeName_ == 'node':
+                nodeName_ == 'node':
             obj_ = nodeType.factory()
             obj_.build(child_)
             self.node.append(obj_)
@@ -3616,6 +4097,7 @@ class graphType(GeneratedsSuper):
 class nodeType(GeneratedsSuper):
     subclass = None
     superclass = None
+
     def __init__(self, id=None, label=None, link=None, childnode=None):
         self.id = id
         self.label = label
@@ -3624,6 +4106,7 @@ class nodeType(GeneratedsSuper):
             self.childnode = []
         else:
             self.childnode = childnode
+
     def factory(*args_, **kwargs_):
         if nodeType.subclass:
             return nodeType.subclass(*args_, **kwargs_)
@@ -3640,6 +4123,7 @@ class nodeType(GeneratedsSuper):
     def insert_childnode(self, index, value): self.childnode[index] = value
     def get_id(self): return self.id
     def set_id(self, id): self.id = id
+
     def export(self, outfile, level, namespace_='', name_='nodeType', namespacedef_=''):
         showIndent(outfile, level)
         outfile.write('<%s%s %s' % (namespace_, name_, namespacedef_, ))
@@ -3651,38 +4135,47 @@ class nodeType(GeneratedsSuper):
             outfile.write('</%s%s>\n' % (namespace_, name_))
         else:
             outfile.write(' />\n')
+
     def exportAttributes(self, outfile, level, namespace_='', name_='nodeType'):
         if self.id is not None:
-            outfile.write(' id=%s' % (self.format_string(quote_attrib(self.id).encode(ExternalEncoding), input_name='id'), ))
+            outfile.write(' id=%s' % (self.format_string(quote_attrib(
+                self.id).encode(ExternalEncoding), input_name='id'), ))
+
     def exportChildren(self, outfile, level, namespace_='', name_='nodeType'):
         if self.label is not None:
             showIndent(outfile, level)
-            outfile.write('<%slabel>%s</%slabel>\n' % (namespace_, self.format_string(quote_xml(self.label).encode(ExternalEncoding), input_name='label'), namespace_))
+            outfile.write('<%slabel>%s</%slabel>\n' % (namespace_, self.format_string(
+                quote_xml(self.label).encode(ExternalEncoding), input_name='label'), namespace_))
         if self.link:
             self.link.export(outfile, level, namespace_, name_='link')
         for childnode_ in self.childnode:
             childnode_.export(outfile, level, namespace_, name_='childnode')
+
     def hasContent_(self):
         if (
             self.label is not None or
             self.link is not None or
             self.childnode is not None
-            ):
+        ):
             return True
         else:
             return False
+
     def exportLiteral(self, outfile, level, name_='nodeType'):
         level += 1
         self.exportLiteralAttributes(outfile, level, name_)
         if self.hasContent_():
             self.exportLiteralChildren(outfile, level, name_)
+
     def exportLiteralAttributes(self, outfile, level, name_):
         if self.id is not None:
             showIndent(outfile, level)
             outfile.write('id = %s,\n' % (self.id,))
+
     def exportLiteralChildren(self, outfile, level, name_):
         showIndent(outfile, level)
-        outfile.write('label=%s,\n' % quote_python(self.label).encode(ExternalEncoding))
+        outfile.write('label=%s,\n' % quote_python(
+            self.label).encode(ExternalEncoding))
         if self.link:
             showIndent(outfile, level)
             outfile.write('link=model_.linkType(\n')
@@ -3701,29 +4194,32 @@ class nodeType(GeneratedsSuper):
         level -= 1
         showIndent(outfile, level)
         outfile.write('],\n')
+
     def build(self, node_):
         attrs = node_.attributes
         self.buildAttributes(attrs)
         for child_ in node_.childNodes:
             nodeName_ = child_.nodeName.split(':')[-1]
             self.buildChildren(child_, nodeName_)
+
     def buildAttributes(self, attrs):
         if attrs.get('id'):
             self.id = attrs.get('id').value
+
     def buildChildren(self, child_, nodeName_):
         if child_.nodeType == Node.ELEMENT_NODE and \
-            nodeName_ == 'label':
+                nodeName_ == 'label':
             label_ = ''
             for text__content_ in child_.childNodes:
                 label_ += text__content_.nodeValue
             self.label = label_
         elif child_.nodeType == Node.ELEMENT_NODE and \
-            nodeName_ == 'link':
+                nodeName_ == 'link':
             obj_ = linkType.factory()
             obj_.build(child_)
             self.set_link(obj_)
         elif child_.nodeType == Node.ELEMENT_NODE and \
-            nodeName_ == 'childnode':
+                nodeName_ == 'childnode':
             obj_ = childnodeType.factory()
             obj_.build(child_)
             self.childnode.append(obj_)
@@ -3733,8 +4229,10 @@ class nodeType(GeneratedsSuper):
 class label(GeneratedsSuper):
     subclass = None
     superclass = None
+
     def __init__(self, valueOf_=''):
         self.valueOf_ = valueOf_
+
     def factory(*args_, **kwargs_):
         if label.subclass:
             return label.subclass(*args_, **kwargs_)
@@ -3743,6 +4241,7 @@ class label(GeneratedsSuper):
     factory = staticmethod(factory)
     def getValueOf_(self): return self.valueOf_
     def setValueOf_(self, valueOf_): self.valueOf_ = valueOf_
+
     def export(self, outfile, level, namespace_='', name_='label', namespacedef_=''):
         showIndent(outfile, level)
         outfile.write('<%s%s %s' % (namespace_, name_, namespacedef_, ))
@@ -3754,33 +4253,40 @@ class label(GeneratedsSuper):
             outfile.write('</%s%s>\n' % (namespace_, name_))
         else:
             outfile.write(' />\n')
+
     def exportAttributes(self, outfile, level, namespace_='', name_='label'):
         pass
+
     def exportChildren(self, outfile, level, namespace_='', name_='label'):
-        if self.valueOf_.find('![CDATA')>-1:
-            value=quote_xml('%s' % self.valueOf_)
-            value=value.replace('![CDATA','<![CDATA')
-            value=value.replace(']]',']]>')
+        if self.valueOf_.find('![CDATA') > -1:
+            value = quote_xml('%s' % self.valueOf_)
+            value = value.replace('![CDATA', '<![CDATA')
+            value = value.replace(']]', ']]>')
             outfile.write(value)
         else:
             outfile.write(quote_xml('%s' % self.valueOf_))
+
     def hasContent_(self):
         if (
             self.valueOf_ is not None
-            ):
+        ):
             return True
         else:
             return False
+
     def exportLiteral(self, outfile, level, name_='label'):
         level += 1
         self.exportLiteralAttributes(outfile, level, name_)
         if self.hasContent_():
             self.exportLiteralChildren(outfile, level, name_)
+
     def exportLiteralAttributes(self, outfile, level, name_):
         pass
+
     def exportLiteralChildren(self, outfile, level, name_):
         showIndent(outfile, level)
         outfile.write('valueOf_ = "%s",\n' % (self.valueOf_,))
+
     def build(self, node_):
         attrs = node_.attributes
         self.buildAttributes(attrs)
@@ -3788,19 +4294,22 @@ class label(GeneratedsSuper):
         for child_ in node_.childNodes:
             nodeName_ = child_.nodeName.split(':')[-1]
             self.buildChildren(child_, nodeName_)
+
     def buildAttributes(self, attrs):
         pass
+
     def buildChildren(self, child_, nodeName_):
         if child_.nodeType == Node.TEXT_NODE:
             self.valueOf_ += child_.nodeValue
         elif child_.nodeType == Node.CDATA_SECTION_NODE:
-            self.valueOf_ += '![CDATA['+child_.nodeValue+']]'
+            self.valueOf_ += '![CDATA[' + child_.nodeValue + ']]'
 # end class label
 
 
 class childnodeType(GeneratedsSuper):
     subclass = None
     superclass = None
+
     def __init__(self, relation=None, refid=None, edgelabel=None):
         self.relation = relation
         self.refid = refid
@@ -3808,6 +4317,7 @@ class childnodeType(GeneratedsSuper):
             self.edgelabel = []
         else:
             self.edgelabel = edgelabel
+
     def factory(*args_, **kwargs_):
         if childnodeType.subclass:
             return childnodeType.subclass(*args_, **kwargs_)
@@ -3822,10 +4332,12 @@ class childnodeType(GeneratedsSuper):
     def set_relation(self, relation): self.relation = relation
     def get_refid(self): return self.refid
     def set_refid(self, refid): self.refid = refid
+
     def export(self, outfile, level, namespace_='', name_='childnodeType', namespacedef_=''):
         showIndent(outfile, level)
         outfile.write('<%s%s %s' % (namespace_, name_, namespacedef_, ))
-        self.exportAttributes(outfile, level, namespace_, name_='childnodeType')
+        self.exportAttributes(outfile, level, namespace_,
+                              name_='childnodeType')
         if self.hasContent_():
             outfile.write('>\n')
             self.exportChildren(outfile, level + 1, namespace_, name_)
@@ -3833,27 +4345,34 @@ class childnodeType(GeneratedsSuper):
             outfile.write('</%s%s>\n' % (namespace_, name_))
         else:
             outfile.write(' />\n')
+
     def exportAttributes(self, outfile, level, namespace_='', name_='childnodeType'):
         if self.relation is not None:
             outfile.write(' relation=%s' % (quote_attrib(self.relation), ))
         if self.refid is not None:
-            outfile.write(' refid=%s' % (self.format_string(quote_attrib(self.refid).encode(ExternalEncoding), input_name='refid'), ))
+            outfile.write(' refid=%s' % (self.format_string(quote_attrib(
+                self.refid).encode(ExternalEncoding), input_name='refid'), ))
+
     def exportChildren(self, outfile, level, namespace_='', name_='childnodeType'):
         for edgelabel_ in self.edgelabel:
             showIndent(outfile, level)
-            outfile.write('<%sedgelabel>%s</%sedgelabel>\n' % (namespace_, self.format_string(quote_xml(edgelabel_).encode(ExternalEncoding), input_name='edgelabel'), namespace_))
+            outfile.write('<%sedgelabel>%s</%sedgelabel>\n' % (namespace_, self.format_string(
+                quote_xml(edgelabel_).encode(ExternalEncoding), input_name='edgelabel'), namespace_))
+
     def hasContent_(self):
         if (
             self.edgelabel is not None
-            ):
+        ):
             return True
         else:
             return False
+
     def exportLiteral(self, outfile, level, name_='childnodeType'):
         level += 1
         self.exportLiteralAttributes(outfile, level, name_)
         if self.hasContent_():
             self.exportLiteralChildren(outfile, level, name_)
+
     def exportLiteralAttributes(self, outfile, level, name_):
         if self.relation is not None:
             showIndent(outfile, level)
@@ -3861,30 +4380,35 @@ class childnodeType(GeneratedsSuper):
         if self.refid is not None:
             showIndent(outfile, level)
             outfile.write('refid = %s,\n' % (self.refid,))
+
     def exportLiteralChildren(self, outfile, level, name_):
         showIndent(outfile, level)
         outfile.write('edgelabel=[\n')
         level += 1
         for edgelabel in self.edgelabel:
             showIndent(outfile, level)
-            outfile.write('%s,\n' % quote_python(edgelabel).encode(ExternalEncoding))
+            outfile.write('%s,\n' % quote_python(
+                edgelabel).encode(ExternalEncoding))
         level -= 1
         showIndent(outfile, level)
         outfile.write('],\n')
+
     def build(self, node_):
         attrs = node_.attributes
         self.buildAttributes(attrs)
         for child_ in node_.childNodes:
             nodeName_ = child_.nodeName.split(':')[-1]
             self.buildChildren(child_, nodeName_)
+
     def buildAttributes(self, attrs):
         if attrs.get('relation'):
             self.relation = attrs.get('relation').value
         if attrs.get('refid'):
             self.refid = attrs.get('refid').value
+
     def buildChildren(self, child_, nodeName_):
         if child_.nodeType == Node.ELEMENT_NODE and \
-            nodeName_ == 'edgelabel':
+                nodeName_ == 'edgelabel':
             edgelabel_ = ''
             for text__content_ in child_.childNodes:
                 edgelabel_ += text__content_.nodeValue
@@ -3895,8 +4419,10 @@ class childnodeType(GeneratedsSuper):
 class edgelabel(GeneratedsSuper):
     subclass = None
     superclass = None
+
     def __init__(self, valueOf_=''):
         self.valueOf_ = valueOf_
+
     def factory(*args_, **kwargs_):
         if edgelabel.subclass:
             return edgelabel.subclass(*args_, **kwargs_)
@@ -3905,6 +4431,7 @@ class edgelabel(GeneratedsSuper):
     factory = staticmethod(factory)
     def getValueOf_(self): return self.valueOf_
     def setValueOf_(self, valueOf_): self.valueOf_ = valueOf_
+
     def export(self, outfile, level, namespace_='', name_='edgelabel', namespacedef_=''):
         showIndent(outfile, level)
         outfile.write('<%s%s %s' % (namespace_, name_, namespacedef_, ))
@@ -3916,33 +4443,40 @@ class edgelabel(GeneratedsSuper):
             outfile.write('</%s%s>\n' % (namespace_, name_))
         else:
             outfile.write(' />\n')
+
     def exportAttributes(self, outfile, level, namespace_='', name_='edgelabel'):
         pass
+
     def exportChildren(self, outfile, level, namespace_='', name_='edgelabel'):
-        if self.valueOf_.find('![CDATA')>-1:
-            value=quote_xml('%s' % self.valueOf_)
-            value=value.replace('![CDATA','<![CDATA')
-            value=value.replace(']]',']]>')
+        if self.valueOf_.find('![CDATA') > -1:
+            value = quote_xml('%s' % self.valueOf_)
+            value = value.replace('![CDATA', '<![CDATA')
+            value = value.replace(']]', ']]>')
             outfile.write(value)
         else:
             outfile.write(quote_xml('%s' % self.valueOf_))
+
     def hasContent_(self):
         if (
             self.valueOf_ is not None
-            ):
+        ):
             return True
         else:
             return False
+
     def exportLiteral(self, outfile, level, name_='edgelabel'):
         level += 1
         self.exportLiteralAttributes(outfile, level, name_)
         if self.hasContent_():
             self.exportLiteralChildren(outfile, level, name_)
+
     def exportLiteralAttributes(self, outfile, level, name_):
         pass
+
     def exportLiteralChildren(self, outfile, level, name_):
         showIndent(outfile, level)
         outfile.write('valueOf_ = "%s",\n' % (self.valueOf_,))
+
     def build(self, node_):
         attrs = node_.attributes
         self.buildAttributes(attrs)
@@ -3950,23 +4484,27 @@ class edgelabel(GeneratedsSuper):
         for child_ in node_.childNodes:
             nodeName_ = child_.nodeName.split(':')[-1]
             self.buildChildren(child_, nodeName_)
+
     def buildAttributes(self, attrs):
         pass
+
     def buildChildren(self, child_, nodeName_):
         if child_.nodeType == Node.TEXT_NODE:
             self.valueOf_ += child_.nodeValue
         elif child_.nodeType == Node.CDATA_SECTION_NODE:
-            self.valueOf_ += '![CDATA['+child_.nodeValue+']]'
+            self.valueOf_ += '![CDATA[' + child_.nodeValue + ']]'
 # end class edgelabel
 
 
 class linkType(GeneratedsSuper):
     subclass = None
     superclass = None
+
     def __init__(self, refid=None, external=None, valueOf_=''):
         self.refid = refid
         self.external = external
         self.valueOf_ = valueOf_
+
     def factory(*args_, **kwargs_):
         if linkType.subclass:
             return linkType.subclass(*args_, **kwargs_)
@@ -3979,6 +4517,7 @@ class linkType(GeneratedsSuper):
     def set_external(self, external): self.external = external
     def getValueOf_(self): return self.valueOf_
     def setValueOf_(self, valueOf_): self.valueOf_ = valueOf_
+
     def export(self, outfile, level, namespace_='', name_='linkType', namespacedef_=''):
         showIndent(outfile, level)
         outfile.write('<%s%s %s' % (namespace_, name_, namespacedef_, ))
@@ -3990,31 +4529,38 @@ class linkType(GeneratedsSuper):
             outfile.write('</%s%s>\n' % (namespace_, name_))
         else:
             outfile.write(' />\n')
+
     def exportAttributes(self, outfile, level, namespace_='', name_='linkType'):
         if self.refid is not None:
-            outfile.write(' refid=%s' % (self.format_string(quote_attrib(self.refid).encode(ExternalEncoding), input_name='refid'), ))
+            outfile.write(' refid=%s' % (self.format_string(quote_attrib(
+                self.refid).encode(ExternalEncoding), input_name='refid'), ))
         if self.external is not None:
-            outfile.write(' external=%s' % (self.format_string(quote_attrib(self.external).encode(ExternalEncoding), input_name='external'), ))
+            outfile.write(' external=%s' % (self.format_string(quote_attrib(
+                self.external).encode(ExternalEncoding), input_name='external'), ))
+
     def exportChildren(self, outfile, level, namespace_='', name_='linkType'):
-        if self.valueOf_.find('![CDATA')>-1:
-            value=quote_xml('%s' % self.valueOf_)
-            value=value.replace('![CDATA','<![CDATA')
-            value=value.replace(']]',']]>')
+        if self.valueOf_.find('![CDATA') > -1:
+            value = quote_xml('%s' % self.valueOf_)
+            value = value.replace('![CDATA', '<![CDATA')
+            value = value.replace(']]', ']]>')
             outfile.write(value)
         else:
             outfile.write(quote_xml('%s' % self.valueOf_))
+
     def hasContent_(self):
         if (
             self.valueOf_ is not None
-            ):
+        ):
             return True
         else:
             return False
+
     def exportLiteral(self, outfile, level, name_='linkType'):
         level += 1
         self.exportLiteralAttributes(outfile, level, name_)
         if self.hasContent_():
             self.exportLiteralChildren(outfile, level, name_)
+
     def exportLiteralAttributes(self, outfile, level, name_):
         if self.refid is not None:
             showIndent(outfile, level)
@@ -4022,9 +4568,11 @@ class linkType(GeneratedsSuper):
         if self.external is not None:
             showIndent(outfile, level)
             outfile.write('external = %s,\n' % (self.external,))
+
     def exportLiteralChildren(self, outfile, level, name_):
         showIndent(outfile, level)
         outfile.write('valueOf_ = "%s",\n' % (self.valueOf_,))
+
     def build(self, node_):
         attrs = node_.attributes
         self.buildAttributes(attrs)
@@ -4032,27 +4580,31 @@ class linkType(GeneratedsSuper):
         for child_ in node_.childNodes:
             nodeName_ = child_.nodeName.split(':')[-1]
             self.buildChildren(child_, nodeName_)
+
     def buildAttributes(self, attrs):
         if attrs.get('refid'):
             self.refid = attrs.get('refid').value
         if attrs.get('external'):
             self.external = attrs.get('external').value
+
     def buildChildren(self, child_, nodeName_):
         if child_.nodeType == Node.TEXT_NODE:
             self.valueOf_ += child_.nodeValue
         elif child_.nodeType == Node.CDATA_SECTION_NODE:
-            self.valueOf_ += '![CDATA['+child_.nodeValue+']]'
+            self.valueOf_ += '![CDATA[' + child_.nodeValue + ']]'
 # end class linkType
 
 
 class listingType(GeneratedsSuper):
     subclass = None
     superclass = None
+
     def __init__(self, codeline=None):
         if codeline is None:
             self.codeline = []
         else:
             self.codeline = codeline
+
     def factory(*args_, **kwargs_):
         if listingType.subclass:
             return listingType.subclass(*args_, **kwargs_)
@@ -4063,6 +4615,7 @@ class listingType(GeneratedsSuper):
     def set_codeline(self, codeline): self.codeline = codeline
     def add_codeline(self, value): self.codeline.append(value)
     def insert_codeline(self, index, value): self.codeline[index] = value
+
     def export(self, outfile, level, namespace_='', name_='listingType', namespacedef_=''):
         showIndent(outfile, level)
         outfile.write('<%s%s %s' % (namespace_, name_, namespacedef_, ))
@@ -4074,25 +4627,31 @@ class listingType(GeneratedsSuper):
             outfile.write('</%s%s>\n' % (namespace_, name_))
         else:
             outfile.write(' />\n')
+
     def exportAttributes(self, outfile, level, namespace_='', name_='listingType'):
         pass
+
     def exportChildren(self, outfile, level, namespace_='', name_='listingType'):
         for codeline_ in self.codeline:
             codeline_.export(outfile, level, namespace_, name_='codeline')
+
     def hasContent_(self):
         if (
             self.codeline is not None
-            ):
+        ):
             return True
         else:
             return False
+
     def exportLiteral(self, outfile, level, name_='listingType'):
         level += 1
         self.exportLiteralAttributes(outfile, level, name_)
         if self.hasContent_():
             self.exportLiteralChildren(outfile, level, name_)
+
     def exportLiteralAttributes(self, outfile, level, name_):
         pass
+
     def exportLiteralChildren(self, outfile, level, name_):
         showIndent(outfile, level)
         outfile.write('codeline=[\n')
@@ -4106,17 +4665,20 @@ class listingType(GeneratedsSuper):
         level -= 1
         showIndent(outfile, level)
         outfile.write('],\n')
+
     def build(self, node_):
         attrs = node_.attributes
         self.buildAttributes(attrs)
         for child_ in node_.childNodes:
             nodeName_ = child_.nodeName.split(':')[-1]
             self.buildChildren(child_, nodeName_)
+
     def buildAttributes(self, attrs):
         pass
+
     def buildChildren(self, child_, nodeName_):
         if child_.nodeType == Node.ELEMENT_NODE and \
-            nodeName_ == 'codeline':
+                nodeName_ == 'codeline':
             obj_ = codelineType.factory()
             obj_.build(child_)
             self.codeline.append(obj_)
@@ -4126,6 +4688,7 @@ class listingType(GeneratedsSuper):
 class codelineType(GeneratedsSuper):
     subclass = None
     superclass = None
+
     def __init__(self, external=None, lineno=None, refkind=None, refid=None, highlight=None):
         self.external = external
         self.lineno = lineno
@@ -4135,6 +4698,7 @@ class codelineType(GeneratedsSuper):
             self.highlight = []
         else:
             self.highlight = highlight
+
     def factory(*args_, **kwargs_):
         if codelineType.subclass:
             return codelineType.subclass(*args_, **kwargs_)
@@ -4153,6 +4717,7 @@ class codelineType(GeneratedsSuper):
     def set_refkind(self, refkind): self.refkind = refkind
     def get_refid(self): return self.refid
     def set_refid(self, refid): self.refid = refid
+
     def export(self, outfile, level, namespace_='', name_='codelineType', namespacedef_=''):
         showIndent(outfile, level)
         outfile.write('<%s%s %s' % (namespace_, name_, namespacedef_, ))
@@ -4164,30 +4729,37 @@ class codelineType(GeneratedsSuper):
             outfile.write('</%s%s>\n' % (namespace_, name_))
         else:
             outfile.write(' />\n')
+
     def exportAttributes(self, outfile, level, namespace_='', name_='codelineType'):
         if self.external is not None:
             outfile.write(' external=%s' % (quote_attrib(self.external), ))
         if self.lineno is not None:
-            outfile.write(' lineno="%s"' % self.format_integer(self.lineno, input_name='lineno'))
+            outfile.write(' lineno="%s"' % self.format_integer(
+                self.lineno, input_name='lineno'))
         if self.refkind is not None:
             outfile.write(' refkind=%s' % (quote_attrib(self.refkind), ))
         if self.refid is not None:
-            outfile.write(' refid=%s' % (self.format_string(quote_attrib(self.refid).encode(ExternalEncoding), input_name='refid'), ))
+            outfile.write(' refid=%s' % (self.format_string(quote_attrib(
+                self.refid).encode(ExternalEncoding), input_name='refid'), ))
+
     def exportChildren(self, outfile, level, namespace_='', name_='codelineType'):
         for highlight_ in self.highlight:
             highlight_.export(outfile, level, namespace_, name_='highlight')
+
     def hasContent_(self):
         if (
             self.highlight is not None
-            ):
+        ):
             return True
         else:
             return False
+
     def exportLiteral(self, outfile, level, name_='codelineType'):
         level += 1
         self.exportLiteralAttributes(outfile, level, name_)
         if self.hasContent_():
             self.exportLiteralChildren(outfile, level, name_)
+
     def exportLiteralAttributes(self, outfile, level, name_):
         if self.external is not None:
             showIndent(outfile, level)
@@ -4201,6 +4773,7 @@ class codelineType(GeneratedsSuper):
         if self.refid is not None:
             showIndent(outfile, level)
             outfile.write('refid = %s,\n' % (self.refid,))
+
     def exportLiteralChildren(self, outfile, level, name_):
         showIndent(outfile, level)
         outfile.write('highlight=[\n')
@@ -4214,12 +4787,14 @@ class codelineType(GeneratedsSuper):
         level -= 1
         showIndent(outfile, level)
         outfile.write('],\n')
+
     def build(self, node_):
         attrs = node_.attributes
         self.buildAttributes(attrs)
         for child_ in node_.childNodes:
             nodeName_ = child_.nodeName.split(':')[-1]
             self.buildChildren(child_, nodeName_)
+
     def buildAttributes(self, attrs):
         if attrs.get('external'):
             self.external = attrs.get('external').value
@@ -4232,9 +4807,10 @@ class codelineType(GeneratedsSuper):
             self.refkind = attrs.get('refkind').value
         if attrs.get('refid'):
             self.refid = attrs.get('refid').value
+
     def buildChildren(self, child_, nodeName_):
         if child_.nodeType == Node.ELEMENT_NODE and \
-            nodeName_ == 'highlight':
+                nodeName_ == 'highlight':
             obj_ = highlightType.factory()
             obj_.build(child_)
             self.highlight.append(obj_)
@@ -4244,6 +4820,7 @@ class codelineType(GeneratedsSuper):
 class highlightType(GeneratedsSuper):
     subclass = None
     superclass = None
+
     def __init__(self, classxx=None, sp=None, ref=None, mixedclass_=None, content_=None):
         self.classxx = classxx
         if mixedclass_ is None:
@@ -4254,6 +4831,7 @@ class highlightType(GeneratedsSuper):
             self.content_ = []
         else:
             self.content_ = content_
+
     def factory(*args_, **kwargs_):
         if highlightType.subclass:
             return highlightType.subclass(*args_, **kwargs_)
@@ -4270,36 +4848,44 @@ class highlightType(GeneratedsSuper):
     def insert_ref(self, index, value): self.ref[index] = value
     def get_class(self): return self.classxx
     def set_class(self, classxx): self.classxx = classxx
+
     def export(self, outfile, level, namespace_='', name_='highlightType', namespacedef_=''):
         showIndent(outfile, level)
         outfile.write('<%s%s %s' % (namespace_, name_, namespacedef_, ))
-        self.exportAttributes(outfile, level, namespace_, name_='highlightType')
+        self.exportAttributes(outfile, level, namespace_,
+                              name_='highlightType')
         outfile.write('>')
         self.exportChildren(outfile, level + 1, namespace_, name_)
         outfile.write('</%s%s>\n' % (namespace_, name_))
+
     def exportAttributes(self, outfile, level, namespace_='', name_='highlightType'):
         if self.classxx is not None:
             outfile.write(' class=%s' % (quote_attrib(self.classxx), ))
+
     def exportChildren(self, outfile, level, namespace_='', name_='highlightType'):
         for item_ in self.content_:
             item_.export(outfile, level, item_.name, namespace_)
+
     def hasContent_(self):
         if (
             self.sp is not None or
             self.ref is not None
-            ):
+        ):
             return True
         else:
             return False
+
     def exportLiteral(self, outfile, level, name_='highlightType'):
         level += 1
         self.exportLiteralAttributes(outfile, level, name_)
         if self.hasContent_():
             self.exportLiteralChildren(outfile, level, name_)
+
     def exportLiteralAttributes(self, outfile, level, name_):
         if self.classxx is not None:
             showIndent(outfile, level)
             outfile.write('classxx = "%s",\n' % (self.classxx,))
+
     def exportLiteralChildren(self, outfile, level, name_):
         showIndent(outfile, level)
         outfile.write('content_ = [\n')
@@ -4313,35 +4899,38 @@ class highlightType(GeneratedsSuper):
             item_.exportLiteral(outfile, level, name_)
         showIndent(outfile, level)
         outfile.write('],\n')
+
     def build(self, node_):
         attrs = node_.attributes
         self.buildAttributes(attrs)
         for child_ in node_.childNodes:
             nodeName_ = child_.nodeName.split(':')[-1]
             self.buildChildren(child_, nodeName_)
+
     def buildAttributes(self, attrs):
         if attrs.get('class'):
             self.classxx = attrs.get('class').value
+
     def buildChildren(self, child_, nodeName_):
         if child_.nodeType == Node.ELEMENT_NODE and \
-            nodeName_ == 'sp':
+                nodeName_ == 'sp':
             value_ = []
             for text_ in child_.childNodes:
                 value_.append(text_.nodeValue)
             valuestr_ = ''.join(value_)
             obj_ = self.mixedclass_(MixedContainer.CategorySimple,
-                MixedContainer.TypeString, 'sp', valuestr_)
+                                    MixedContainer.TypeString, 'sp', valuestr_)
             self.content_.append(obj_)
         elif child_.nodeType == Node.ELEMENT_NODE and \
-            nodeName_ == 'ref':
+                nodeName_ == 'ref':
             childobj_ = docRefTextType.factory()
             childobj_.build(child_)
             obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
-                MixedContainer.TypeNone, 'ref', childobj_)
+                                    MixedContainer.TypeNone, 'ref', childobj_)
             self.content_.append(obj_)
         elif child_.nodeType == Node.TEXT_NODE:
             obj_ = self.mixedclass_(MixedContainer.CategoryText,
-                MixedContainer.TypeNone, '', child_.nodeValue)
+                                    MixedContainer.TypeNone, '', child_.nodeValue)
             self.content_.append(obj_)
 # end class highlightType
 
@@ -4349,8 +4938,10 @@ class highlightType(GeneratedsSuper):
 class sp(GeneratedsSuper):
     subclass = None
     superclass = None
+
     def __init__(self, valueOf_=''):
         self.valueOf_ = valueOf_
+
     def factory(*args_, **kwargs_):
         if sp.subclass:
             return sp.subclass(*args_, **kwargs_)
@@ -4359,6 +4950,7 @@ class sp(GeneratedsSuper):
     factory = staticmethod(factory)
     def getValueOf_(self): return self.valueOf_
     def setValueOf_(self, valueOf_): self.valueOf_ = valueOf_
+
     def export(self, outfile, level, namespace_='', name_='sp', namespacedef_=''):
         showIndent(outfile, level)
         outfile.write('<%s%s %s' % (namespace_, name_, namespacedef_, ))
@@ -4370,33 +4962,40 @@ class sp(GeneratedsSuper):
             outfile.write('</%s%s>\n' % (namespace_, name_))
         else:
             outfile.write(' />\n')
+
     def exportAttributes(self, outfile, level, namespace_='', name_='sp'):
         pass
+
     def exportChildren(self, outfile, level, namespace_='', name_='sp'):
-        if self.valueOf_.find('![CDATA')>-1:
-            value=quote_xml('%s' % self.valueOf_)
-            value=value.replace('![CDATA','<![CDATA')
-            value=value.replace(']]',']]>')
+        if self.valueOf_.find('![CDATA') > -1:
+            value = quote_xml('%s' % self.valueOf_)
+            value = value.replace('![CDATA', '<![CDATA')
+            value = value.replace(']]', ']]>')
             outfile.write(value)
         else:
             outfile.write(quote_xml('%s' % self.valueOf_))
+
     def hasContent_(self):
         if (
             self.valueOf_ is not None
-            ):
+        ):
             return True
         else:
             return False
+
     def exportLiteral(self, outfile, level, name_='sp'):
         level += 1
         self.exportLiteralAttributes(outfile, level, name_)
         if self.hasContent_():
             self.exportLiteralChildren(outfile, level, name_)
+
     def exportLiteralAttributes(self, outfile, level, name_):
         pass
+
     def exportLiteralChildren(self, outfile, level, name_):
         showIndent(outfile, level)
         outfile.write('valueOf_ = "%s",\n' % (self.valueOf_,))
+
     def build(self, node_):
         attrs = node_.attributes
         self.buildAttributes(attrs)
@@ -4404,19 +5003,22 @@ class sp(GeneratedsSuper):
         for child_ in node_.childNodes:
             nodeName_ = child_.nodeName.split(':')[-1]
             self.buildChildren(child_, nodeName_)
+
     def buildAttributes(self, attrs):
         pass
+
     def buildChildren(self, child_, nodeName_):
         if child_.nodeType == Node.TEXT_NODE:
             self.valueOf_ += child_.nodeValue
         elif child_.nodeType == Node.CDATA_SECTION_NODE:
-            self.valueOf_ += '![CDATA['+child_.nodeValue+']]'
+            self.valueOf_ += '![CDATA[' + child_.nodeValue + ']]'
 # end class sp
 
 
 class referenceType(GeneratedsSuper):
     subclass = None
     superclass = None
+
     def __init__(self, endline=None, startline=None, refid=None, compoundref=None, valueOf_='', mixedclass_=None, content_=None):
         self.endline = endline
         self.startline = startline
@@ -4430,6 +5032,7 @@ class referenceType(GeneratedsSuper):
             self.content_ = []
         else:
             self.content_ = content_
+
     def factory(*args_, **kwargs_):
         if referenceType.subclass:
             return referenceType.subclass(*args_, **kwargs_)
@@ -4446,42 +5049,53 @@ class referenceType(GeneratedsSuper):
     def set_compoundref(self, compoundref): self.compoundref = compoundref
     def getValueOf_(self): return self.valueOf_
     def setValueOf_(self, valueOf_): self.valueOf_ = valueOf_
+
     def export(self, outfile, level, namespace_='', name_='referenceType', namespacedef_=''):
         showIndent(outfile, level)
         outfile.write('<%s%s %s' % (namespace_, name_, namespacedef_, ))
-        self.exportAttributes(outfile, level, namespace_, name_='referenceType')
+        self.exportAttributes(outfile, level, namespace_,
+                              name_='referenceType')
         outfile.write('>')
         self.exportChildren(outfile, level + 1, namespace_, name_)
         outfile.write('</%s%s>\n' % (namespace_, name_))
+
     def exportAttributes(self, outfile, level, namespace_='', name_='referenceType'):
         if self.endline is not None:
-            outfile.write(' endline="%s"' % self.format_integer(self.endline, input_name='endline'))
+            outfile.write(' endline="%s"' % self.format_integer(
+                self.endline, input_name='endline'))
         if self.startline is not None:
-            outfile.write(' startline="%s"' % self.format_integer(self.startline, input_name='startline'))
+            outfile.write(' startline="%s"' % self.format_integer(
+                self.startline, input_name='startline'))
         if self.refid is not None:
-            outfile.write(' refid=%s' % (self.format_string(quote_attrib(self.refid).encode(ExternalEncoding), input_name='refid'), ))
+            outfile.write(' refid=%s' % (self.format_string(quote_attrib(
+                self.refid).encode(ExternalEncoding), input_name='refid'), ))
         if self.compoundref is not None:
-            outfile.write(' compoundref=%s' % (self.format_string(quote_attrib(self.compoundref).encode(ExternalEncoding), input_name='compoundref'), ))
+            outfile.write(' compoundref=%s' % (self.format_string(quote_attrib(
+                self.compoundref).encode(ExternalEncoding), input_name='compoundref'), ))
+
     def exportChildren(self, outfile, level, namespace_='', name_='referenceType'):
-        if self.valueOf_.find('![CDATA')>-1:
-            value=quote_xml('%s' % self.valueOf_)
-            value=value.replace('![CDATA','<![CDATA')
-            value=value.replace(']]',']]>')
+        if self.valueOf_.find('![CDATA') > -1:
+            value = quote_xml('%s' % self.valueOf_)
+            value = value.replace('![CDATA', '<![CDATA')
+            value = value.replace(']]', ']]>')
             outfile.write(value)
         else:
             outfile.write(quote_xml('%s' % self.valueOf_))
+
     def hasContent_(self):
         if (
             self.valueOf_ is not None
-            ):
+        ):
             return True
         else:
             return False
+
     def exportLiteral(self, outfile, level, name_='referenceType'):
         level += 1
         self.exportLiteralAttributes(outfile, level, name_)
         if self.hasContent_():
             self.exportLiteralChildren(outfile, level, name_)
+
     def exportLiteralAttributes(self, outfile, level, name_):
         if self.endline is not None:
             showIndent(outfile, level)
@@ -4495,9 +5109,11 @@ class referenceType(GeneratedsSuper):
         if self.compoundref is not None:
             showIndent(outfile, level)
             outfile.write('compoundref = %s,\n' % (self.compoundref,))
+
     def exportLiteralChildren(self, outfile, level, name_):
         showIndent(outfile, level)
         outfile.write('valueOf_ = "%s",\n' % (self.valueOf_,))
+
     def build(self, node_):
         attrs = node_.attributes
         self.buildAttributes(attrs)
@@ -4505,6 +5121,7 @@ class referenceType(GeneratedsSuper):
         for child_ in node_.childNodes:
             nodeName_ = child_.nodeName.split(':')[-1]
             self.buildChildren(child_, nodeName_)
+
     def buildAttributes(self, attrs):
         if attrs.get('endline'):
             try:
@@ -4520,21 +5137,23 @@ class referenceType(GeneratedsSuper):
             self.refid = attrs.get('refid').value
         if attrs.get('compoundref'):
             self.compoundref = attrs.get('compoundref').value
+
     def buildChildren(self, child_, nodeName_):
         if child_.nodeType == Node.TEXT_NODE:
             obj_ = self.mixedclass_(MixedContainer.CategoryText,
-                MixedContainer.TypeNone, '', child_.nodeValue)
+                                    MixedContainer.TypeNone, '', child_.nodeValue)
             self.content_.append(obj_)
         if child_.nodeType == Node.TEXT_NODE:
             self.valueOf_ += child_.nodeValue
         elif child_.nodeType == Node.CDATA_SECTION_NODE:
-            self.valueOf_ += '![CDATA['+child_.nodeValue+']]'
+            self.valueOf_ += '![CDATA[' + child_.nodeValue + ']]'
 # end class referenceType
 
 
 class locationType(GeneratedsSuper):
     subclass = None
     superclass = None
+
     def __init__(self, bodystart=None, line=None, bodyend=None, bodyfile=None, file=None, valueOf_=''):
         self.bodystart = bodystart
         self.line = line
@@ -4542,6 +5161,7 @@ class locationType(GeneratedsSuper):
         self.bodyfile = bodyfile
         self.file = file
         self.valueOf_ = valueOf_
+
     def factory(*args_, **kwargs_):
         if locationType.subclass:
             return locationType.subclass(*args_, **kwargs_)
@@ -4560,6 +5180,7 @@ class locationType(GeneratedsSuper):
     def set_file(self, file): self.file = file
     def getValueOf_(self): return self.valueOf_
     def setValueOf_(self, valueOf_): self.valueOf_ = valueOf_
+
     def export(self, outfile, level, namespace_='', name_='locationType', namespacedef_=''):
         showIndent(outfile, level)
         outfile.write('<%s%s %s' % (namespace_, name_, namespacedef_, ))
@@ -4571,37 +5192,47 @@ class locationType(GeneratedsSuper):
             outfile.write('</%s%s>\n' % (namespace_, name_))
         else:
             outfile.write(' />\n')
+
     def exportAttributes(self, outfile, level, namespace_='', name_='locationType'):
         if self.bodystart is not None:
-            outfile.write(' bodystart="%s"' % self.format_integer(self.bodystart, input_name='bodystart'))
+            outfile.write(' bodystart="%s"' % self.format_integer(
+                self.bodystart, input_name='bodystart'))
         if self.line is not None:
-            outfile.write(' line="%s"' % self.format_integer(self.line, input_name='line'))
+            outfile.write(' line="%s"' % self.format_integer(
+                self.line, input_name='line'))
         if self.bodyend is not None:
-            outfile.write(' bodyend="%s"' % self.format_integer(self.bodyend, input_name='bodyend'))
+            outfile.write(' bodyend="%s"' % self.format_integer(
+                self.bodyend, input_name='bodyend'))
         if self.bodyfile is not None:
-            outfile.write(' bodyfile=%s' % (self.format_string(quote_attrib(self.bodyfile).encode(ExternalEncoding), input_name='bodyfile'), ))
+            outfile.write(' bodyfile=%s' % (self.format_string(quote_attrib(
+                self.bodyfile).encode(ExternalEncoding), input_name='bodyfile'), ))
         if self.file is not None:
-            outfile.write(' file=%s' % (self.format_string(quote_attrib(self.file).encode(ExternalEncoding), input_name='file'), ))
+            outfile.write(' file=%s' % (self.format_string(quote_attrib(
+                self.file).encode(ExternalEncoding), input_name='file'), ))
+
     def exportChildren(self, outfile, level, namespace_='', name_='locationType'):
-        if self.valueOf_.find('![CDATA')>-1:
-            value=quote_xml('%s' % self.valueOf_)
-            value=value.replace('![CDATA','<![CDATA')
-            value=value.replace(']]',']]>')
+        if self.valueOf_.find('![CDATA') > -1:
+            value = quote_xml('%s' % self.valueOf_)
+            value = value.replace('![CDATA', '<![CDATA')
+            value = value.replace(']]', ']]>')
             outfile.write(value)
         else:
             outfile.write(quote_xml('%s' % self.valueOf_))
+
     def hasContent_(self):
         if (
             self.valueOf_ is not None
-            ):
+        ):
             return True
         else:
             return False
+
     def exportLiteral(self, outfile, level, name_='locationType'):
         level += 1
         self.exportLiteralAttributes(outfile, level, name_)
         if self.hasContent_():
             self.exportLiteralChildren(outfile, level, name_)
+
     def exportLiteralAttributes(self, outfile, level, name_):
         if self.bodystart is not None:
             showIndent(outfile, level)
@@ -4618,9 +5249,11 @@ class locationType(GeneratedsSuper):
         if self.file is not None:
             showIndent(outfile, level)
             outfile.write('file = %s,\n' % (self.file,))
+
     def exportLiteralChildren(self, outfile, level, name_):
         showIndent(outfile, level)
         outfile.write('valueOf_ = "%s",\n' % (self.valueOf_,))
+
     def build(self, node_):
         attrs = node_.attributes
         self.buildAttributes(attrs)
@@ -4628,6 +5261,7 @@ class locationType(GeneratedsSuper):
         for child_ in node_.childNodes:
             nodeName_ = child_.nodeName.split(':')[-1]
             self.buildChildren(child_, nodeName_)
+
     def buildAttributes(self, attrs):
         if attrs.get('bodystart'):
             try:
@@ -4648,17 +5282,19 @@ class locationType(GeneratedsSuper):
             self.bodyfile = attrs.get('bodyfile').value
         if attrs.get('file'):
             self.file = attrs.get('file').value
+
     def buildChildren(self, child_, nodeName_):
         if child_.nodeType == Node.TEXT_NODE:
             self.valueOf_ += child_.nodeValue
         elif child_.nodeType == Node.CDATA_SECTION_NODE:
-            self.valueOf_ += '![CDATA['+child_.nodeValue+']]'
+            self.valueOf_ += '![CDATA[' + child_.nodeValue + ']]'
 # end class locationType
 
 
 class docSect1Type(GeneratedsSuper):
     subclass = None
     superclass = None
+
     def __init__(self, id=None, title=None, para=None, sect2=None, internal=None, mixedclass_=None, content_=None):
         self.id = id
         if mixedclass_ is None:
@@ -4669,6 +5305,7 @@ class docSect1Type(GeneratedsSuper):
             self.content_ = []
         else:
             self.content_ = content_
+
     def factory(*args_, **kwargs_):
         if docSect1Type.subclass:
             return docSect1Type.subclass(*args_, **kwargs_)
@@ -4689,6 +5326,7 @@ class docSect1Type(GeneratedsSuper):
     def set_internal(self, internal): self.internal = internal
     def get_id(self): return self.id
     def set_id(self, id): self.id = id
+
     def export(self, outfile, level, namespace_='', name_='docSect1Type', namespacedef_=''):
         showIndent(outfile, level)
         outfile.write('<%s%s %s' % (namespace_, name_, namespacedef_, ))
@@ -4696,31 +5334,38 @@ class docSect1Type(GeneratedsSuper):
         outfile.write('>')
         self.exportChildren(outfile, level + 1, namespace_, name_)
         outfile.write('</%s%s>\n' % (namespace_, name_))
+
     def exportAttributes(self, outfile, level, namespace_='', name_='docSect1Type'):
         if self.id is not None:
-            outfile.write(' id=%s' % (self.format_string(quote_attrib(self.id).encode(ExternalEncoding), input_name='id'), ))
+            outfile.write(' id=%s' % (self.format_string(quote_attrib(
+                self.id).encode(ExternalEncoding), input_name='id'), ))
+
     def exportChildren(self, outfile, level, namespace_='', name_='docSect1Type'):
         for item_ in self.content_:
             item_.export(outfile, level, item_.name, namespace_)
+
     def hasContent_(self):
         if (
             self.title is not None or
             self.para is not None or
             self.sect2 is not None or
             self.internal is not None
-            ):
+        ):
             return True
         else:
             return False
+
     def exportLiteral(self, outfile, level, name_='docSect1Type'):
         level += 1
         self.exportLiteralAttributes(outfile, level, name_)
         if self.hasContent_():
             self.exportLiteralChildren(outfile, level, name_)
+
     def exportLiteralAttributes(self, outfile, level, name_):
         if self.id is not None:
             showIndent(outfile, level)
             outfile.write('id = %s,\n' % (self.id,))
+
     def exportLiteralChildren(self, outfile, level, name_):
         showIndent(outfile, level)
         outfile.write('content_ = [\n')
@@ -4746,47 +5391,50 @@ class docSect1Type(GeneratedsSuper):
             item_.exportLiteral(outfile, level, name_)
         showIndent(outfile, level)
         outfile.write('],\n')
+
     def build(self, node_):
         attrs = node_.attributes
         self.buildAttributes(attrs)
         for child_ in node_.childNodes:
             nodeName_ = child_.nodeName.split(':')[-1]
             self.buildChildren(child_, nodeName_)
+
     def buildAttributes(self, attrs):
         if attrs.get('id'):
             self.id = attrs.get('id').value
+
     def buildChildren(self, child_, nodeName_):
         if child_.nodeType == Node.ELEMENT_NODE and \
-            nodeName_ == 'title':
+                nodeName_ == 'title':
             childobj_ = docTitleType.factory()
             childobj_.build(child_)
             obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
-                MixedContainer.TypeNone, 'title', childobj_)
+                                    MixedContainer.TypeNone, 'title', childobj_)
             self.content_.append(obj_)
         elif child_.nodeType == Node.ELEMENT_NODE and \
-            nodeName_ == 'para':
+                nodeName_ == 'para':
             childobj_ = docParaType.factory()
             childobj_.build(child_)
             obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
-                MixedContainer.TypeNone, 'para', childobj_)
+                                    MixedContainer.TypeNone, 'para', childobj_)
             self.content_.append(obj_)
         elif child_.nodeType == Node.ELEMENT_NODE and \
-            nodeName_ == 'sect2':
+                nodeName_ == 'sect2':
             childobj_ = docSect2Type.factory()
             childobj_.build(child_)
             obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
-                MixedContainer.TypeNone, 'sect2', childobj_)
+                                    MixedContainer.TypeNone, 'sect2', childobj_)
             self.content_.append(obj_)
         elif child_.nodeType == Node.ELEMENT_NODE and \
-            nodeName_ == 'internal':
+                nodeName_ == 'internal':
             childobj_ = docInternalS1Type.factory()
             childobj_.build(child_)
             obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
-                MixedContainer.TypeNone, 'internal', childobj_)
+                                    MixedContainer.TypeNone, 'internal', childobj_)
             self.content_.append(obj_)
         elif child_.nodeType == Node.TEXT_NODE:
             obj_ = self.mixedclass_(MixedContainer.CategoryText,
-                MixedContainer.TypeNone, '', child_.nodeValue)
+                                    MixedContainer.TypeNone, '', child_.nodeValue)
             self.content_.append(obj_)
 # end class docSect1Type
 
@@ -4794,6 +5442,7 @@ class docSect1Type(GeneratedsSuper):
 class docSect2Type(GeneratedsSuper):
     subclass = None
     superclass = None
+
     def __init__(self, id=None, title=None, para=None, sect3=None, internal=None, mixedclass_=None, content_=None):
         self.id = id
         if mixedclass_ is None:
@@ -4804,6 +5453,7 @@ class docSect2Type(GeneratedsSuper):
             self.content_ = []
         else:
             self.content_ = content_
+
     def factory(*args_, **kwargs_):
         if docSect2Type.subclass:
             return docSect2Type.subclass(*args_, **kwargs_)
@@ -4824,6 +5474,7 @@ class docSect2Type(GeneratedsSuper):
     def set_internal(self, internal): self.internal = internal
     def get_id(self): return self.id
     def set_id(self, id): self.id = id
+
     def export(self, outfile, level, namespace_='', name_='docSect2Type', namespacedef_=''):
         showIndent(outfile, level)
         outfile.write('<%s%s %s' % (namespace_, name_, namespacedef_, ))
@@ -4831,31 +5482,38 @@ class docSect2Type(GeneratedsSuper):
         outfile.write('>')
         self.exportChildren(outfile, level + 1, namespace_, name_)
         outfile.write('</%s%s>\n' % (namespace_, name_))
+
     def exportAttributes(self, outfile, level, namespace_='', name_='docSect2Type'):
         if self.id is not None:
-            outfile.write(' id=%s' % (self.format_string(quote_attrib(self.id).encode(ExternalEncoding), input_name='id'), ))
+            outfile.write(' id=%s' % (self.format_string(quote_attrib(
+                self.id).encode(ExternalEncoding), input_name='id'), ))
+
     def exportChildren(self, outfile, level, namespace_='', name_='docSect2Type'):
         for item_ in self.content_:
             item_.export(outfile, level, item_.name, namespace_)
+
     def hasContent_(self):
         if (
             self.title is not None or
             self.para is not None or
             self.sect3 is not None or
             self.internal is not None
-            ):
+        ):
             return True
         else:
             return False
+
     def exportLiteral(self, outfile, level, name_='docSect2Type'):
         level += 1
         self.exportLiteralAttributes(outfile, level, name_)
         if self.hasContent_():
             self.exportLiteralChildren(outfile, level, name_)
+
     def exportLiteralAttributes(self, outfile, level, name_):
         if self.id is not None:
             showIndent(outfile, level)
             outfile.write('id = %s,\n' % (self.id,))
+
     def exportLiteralChildren(self, outfile, level, name_):
         showIndent(outfile, level)
         outfile.write('content_ = [\n')
@@ -4881,47 +5539,50 @@ class docSect2Type(GeneratedsSuper):
             item_.exportLiteral(outfile, level, name_)
         showIndent(outfile, level)
         outfile.write('],\n')
+
     def build(self, node_):
         attrs = node_.attributes
         self.buildAttributes(attrs)
         for child_ in node_.childNodes:
             nodeName_ = child_.nodeName.split(':')[-1]
             self.buildChildren(child_, nodeName_)
+
     def buildAttributes(self, attrs):
         if attrs.get('id'):
             self.id = attrs.get('id').value
+
     def buildChildren(self, child_, nodeName_):
         if child_.nodeType == Node.ELEMENT_NODE and \
-            nodeName_ == 'title':
+                nodeName_ == 'title':
             childobj_ = docTitleType.factory()
             childobj_.build(child_)
             obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
-                MixedContainer.TypeNone, 'title', childobj_)
+                                    MixedContainer.TypeNone, 'title', childobj_)
             self.content_.append(obj_)
         elif child_.nodeType == Node.ELEMENT_NODE and \
-            nodeName_ == 'para':
+                nodeName_ == 'para':
             childobj_ = docParaType.factory()
             childobj_.build(child_)
             obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
-                MixedContainer.TypeNone, 'para', childobj_)
+                                    MixedContainer.TypeNone, 'para', childobj_)
             self.content_.append(obj_)
         elif child_.nodeType == Node.ELEMENT_NODE and \
-            nodeName_ == 'sect3':
+                nodeName_ == 'sect3':
             childobj_ = docSect3Type.factory()
             childobj_.build(child_)
             obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
-                MixedContainer.TypeNone, 'sect3', childobj_)
+                                    MixedContainer.TypeNone, 'sect3', childobj_)
             self.content_.append(obj_)
         elif child_.nodeType == Node.ELEMENT_NODE and \
-            nodeName_ == 'internal':
+                nodeName_ == 'internal':
             childobj_ = docInternalS2Type.factory()
             childobj_.build(child_)
             obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
-                MixedContainer.TypeNone, 'internal', childobj_)
+                                    MixedContainer.TypeNone, 'internal', childobj_)
             self.content_.append(obj_)
         elif child_.nodeType == Node.TEXT_NODE:
             obj_ = self.mixedclass_(MixedContainer.CategoryText,
-                MixedContainer.TypeNone, '', child_.nodeValue)
+                                    MixedContainer.TypeNone, '', child_.nodeValue)
             self.content_.append(obj_)
 # end class docSect2Type
 
@@ -4929,6 +5590,7 @@ class docSect2Type(GeneratedsSuper):
 class docSect3Type(GeneratedsSuper):
     subclass = None
     superclass = None
+
     def __init__(self, id=None, title=None, para=None, sect4=None, internal=None, mixedclass_=None, content_=None):
         self.id = id
         if mixedclass_ is None:
@@ -4939,6 +5601,7 @@ class docSect3Type(GeneratedsSuper):
             self.content_ = []
         else:
             self.content_ = content_
+
     def factory(*args_, **kwargs_):
         if docSect3Type.subclass:
             return docSect3Type.subclass(*args_, **kwargs_)
@@ -4959,6 +5622,7 @@ class docSect3Type(GeneratedsSuper):
     def set_internal(self, internal): self.internal = internal
     def get_id(self): return self.id
     def set_id(self, id): self.id = id
+
     def export(self, outfile, level, namespace_='', name_='docSect3Type', namespacedef_=''):
         showIndent(outfile, level)
         outfile.write('<%s%s %s' % (namespace_, name_, namespacedef_, ))
@@ -4966,31 +5630,38 @@ class docSect3Type(GeneratedsSuper):
         outfile.write('>')
         self.exportChildren(outfile, level + 1, namespace_, name_)
         outfile.write('</%s%s>\n' % (namespace_, name_))
+
     def exportAttributes(self, outfile, level, namespace_='', name_='docSect3Type'):
         if self.id is not None:
-            outfile.write(' id=%s' % (self.format_string(quote_attrib(self.id).encode(ExternalEncoding), input_name='id'), ))
+            outfile.write(' id=%s' % (self.format_string(quote_attrib(
+                self.id).encode(ExternalEncoding), input_name='id'), ))
+
     def exportChildren(self, outfile, level, namespace_='', name_='docSect3Type'):
         for item_ in self.content_:
             item_.export(outfile, level, item_.name, namespace_)
+
     def hasContent_(self):
         if (
             self.title is not None or
             self.para is not None or
             self.sect4 is not None or
             self.internal is not None
-            ):
+        ):
             return True
         else:
             return False
+
     def exportLiteral(self, outfile, level, name_='docSect3Type'):
         level += 1
         self.exportLiteralAttributes(outfile, level, name_)
         if self.hasContent_():
             self.exportLiteralChildren(outfile, level, name_)
+
     def exportLiteralAttributes(self, outfile, level, name_):
         if self.id is not None:
             showIndent(outfile, level)
             outfile.write('id = %s,\n' % (self.id,))
+
     def exportLiteralChildren(self, outfile, level, name_):
         showIndent(outfile, level)
         outfile.write('content_ = [\n')
@@ -5016,47 +5687,50 @@ class docSect3Type(GeneratedsSuper):
             item_.exportLiteral(outfile, level, name_)
         showIndent(outfile, level)
         outfile.write('],\n')
+
     def build(self, node_):
         attrs = node_.attributes
         self.buildAttributes(attrs)
         for child_ in node_.childNodes:
             nodeName_ = child_.nodeName.split(':')[-1]
             self.buildChildren(child_, nodeName_)
+
     def buildAttributes(self, attrs):
         if attrs.get('id'):
             self.id = attrs.get('id').value
+
     def buildChildren(self, child_, nodeName_):
         if child_.nodeType == Node.ELEMENT_NODE and \
-            nodeName_ == 'title':
+                nodeName_ == 'title':
             childobj_ = docTitleType.factory()
             childobj_.build(child_)
             obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
-                MixedContainer.TypeNone, 'title', childobj_)
+                                    MixedContainer.TypeNone, 'title', childobj_)
             self.content_.append(obj_)
         elif child_.nodeType == Node.ELEMENT_NODE and \
-            nodeName_ == 'para':
+                nodeName_ == 'para':
             childobj_ = docParaType.factory()
             childobj_.build(child_)
             obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
-                MixedContainer.TypeNone, 'para', childobj_)
+                                    MixedContainer.TypeNone, 'para', childobj_)
             self.content_.append(obj_)
         elif child_.nodeType == Node.ELEMENT_NODE and \
-            nodeName_ == 'sect4':
+                nodeName_ == 'sect4':
             childobj_ = docSect4Type.factory()
             childobj_.build(child_)
             obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
-                MixedContainer.TypeNone, 'sect4', childobj_)
+                                    MixedContainer.TypeNone, 'sect4', childobj_)
             self.content_.append(obj_)
         elif child_.nodeType == Node.ELEMENT_NODE and \
-            nodeName_ == 'internal':
+                nodeName_ == 'internal':
             childobj_ = docInternalS3Type.factory()
             childobj_.build(child_)
             obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
-                MixedContainer.TypeNone, 'internal', childobj_)
+                                    MixedContainer.TypeNone, 'internal', childobj_)
             self.content_.append(obj_)
         elif child_.nodeType == Node.TEXT_NODE:
             obj_ = self.mixedclass_(MixedContainer.CategoryText,
-                MixedContainer.TypeNone, '', child_.nodeValue)
+                                    MixedContainer.TypeNone, '', child_.nodeValue)
             self.content_.append(obj_)
 # end class docSect3Type
 
@@ -5064,6 +5738,7 @@ class docSect3Type(GeneratedsSuper):
 class docSect4Type(GeneratedsSuper):
     subclass = None
     superclass = None
+
     def __init__(self, id=None, title=None, para=None, internal=None, mixedclass_=None, content_=None):
         self.id = id
         if mixedclass_ is None:
@@ -5074,6 +5749,7 @@ class docSect4Type(GeneratedsSuper):
             self.content_ = []
         else:
             self.content_ = content_
+
     def factory(*args_, **kwargs_):
         if docSect4Type.subclass:
             return docSect4Type.subclass(*args_, **kwargs_)
@@ -5090,6 +5766,7 @@ class docSect4Type(GeneratedsSuper):
     def set_internal(self, internal): self.internal = internal
     def get_id(self): return self.id
     def set_id(self, id): self.id = id
+
     def export(self, outfile, level, namespace_='', name_='docSect4Type', namespacedef_=''):
         showIndent(outfile, level)
         outfile.write('<%s%s %s' % (namespace_, name_, namespacedef_, ))
@@ -5097,30 +5774,37 @@ class docSect4Type(GeneratedsSuper):
         outfile.write('>')
         self.exportChildren(outfile, level + 1, namespace_, name_)
         outfile.write('</%s%s>\n' % (namespace_, name_))
+
     def exportAttributes(self, outfile, level, namespace_='', name_='docSect4Type'):
         if self.id is not None:
-            outfile.write(' id=%s' % (self.format_string(quote_attrib(self.id).encode(ExternalEncoding), input_name='id'), ))
+            outfile.write(' id=%s' % (self.format_string(quote_attrib(
+                self.id).encode(ExternalEncoding), input_name='id'), ))
+
     def exportChildren(self, outfile, level, namespace_='', name_='docSect4Type'):
         for item_ in self.content_:
             item_.export(outfile, level, item_.name, namespace_)
+
     def hasContent_(self):
         if (
             self.title is not None or
             self.para is not None or
             self.internal is not None
-            ):
+        ):
             return True
         else:
             return False
+
     def exportLiteral(self, outfile, level, name_='docSect4Type'):
         level += 1
         self.exportLiteralAttributes(outfile, level, name_)
         if self.hasContent_():
             self.exportLiteralChildren(outfile, level, name_)
+
     def exportLiteralAttributes(self, outfile, level, name_):
         if self.id is not None:
             showIndent(outfile, level)
             outfile.write('id = %s,\n' % (self.id,))
+
     def exportLiteralChildren(self, outfile, level, name_):
         showIndent(outfile, level)
         outfile.write('content_ = [\n')
@@ -5140,40 +5824,43 @@ class docSect4Type(GeneratedsSuper):
             item_.exportLiteral(outfile, level, name_)
         showIndent(outfile, level)
         outfile.write('],\n')
+
     def build(self, node_):
         attrs = node_.attributes
         self.buildAttributes(attrs)
         for child_ in node_.childNodes:
             nodeName_ = child_.nodeName.split(':')[-1]
             self.buildChildren(child_, nodeName_)
+
     def buildAttributes(self, attrs):
         if attrs.get('id'):
             self.id = attrs.get('id').value
+
     def buildChildren(self, child_, nodeName_):
         if child_.nodeType == Node.ELEMENT_NODE and \
-            nodeName_ == 'title':
+                nodeName_ == 'title':
             childobj_ = docTitleType.factory()
             childobj_.build(child_)
             obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
-                MixedContainer.TypeNone, 'title', childobj_)
+                                    MixedContainer.TypeNone, 'title', childobj_)
             self.content_.append(obj_)
         elif child_.nodeType == Node.ELEMENT_NODE and \
-            nodeName_ == 'para':
+                nodeName_ == 'para':
             childobj_ = docParaType.factory()
             childobj_.build(child_)
             obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
-                MixedContainer.TypeNone, 'para', childobj_)
+                                    MixedContainer.TypeNone, 'para', childobj_)
             self.content_.append(obj_)
         elif child_.nodeType == Node.ELEMENT_NODE and \
-            nodeName_ == 'internal':
+                nodeName_ == 'internal':
             childobj_ = docInternalS4Type.factory()
             childobj_.build(child_)
             obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
-                MixedContainer.TypeNone, 'internal', childobj_)
+                                    MixedContainer.TypeNone, 'internal', childobj_)
             self.content_.append(obj_)
         elif child_.nodeType == Node.TEXT_NODE:
             obj_ = self.mixedclass_(MixedContainer.CategoryText,
-                MixedContainer.TypeNone, '', child_.nodeValue)
+                                    MixedContainer.TypeNone, '', child_.nodeValue)
             self.content_.append(obj_)
 # end class docSect4Type
 
@@ -5181,6 +5868,7 @@ class docSect4Type(GeneratedsSuper):
 class docInternalType(GeneratedsSuper):
     subclass = None
     superclass = None
+
     def __init__(self, para=None, sect1=None, mixedclass_=None, content_=None):
         if mixedclass_ is None:
             self.mixedclass_ = MixedContainer
@@ -5190,6 +5878,7 @@ class docInternalType(GeneratedsSuper):
             self.content_ = []
         else:
             self.content_ = content_
+
     def factory(*args_, **kwargs_):
         if docInternalType.subclass:
             return docInternalType.subclass(*args_, **kwargs_)
@@ -5204,33 +5893,41 @@ class docInternalType(GeneratedsSuper):
     def set_sect1(self, sect1): self.sect1 = sect1
     def add_sect1(self, value): self.sect1.append(value)
     def insert_sect1(self, index, value): self.sect1[index] = value
+
     def export(self, outfile, level, namespace_='', name_='docInternalType', namespacedef_=''):
         showIndent(outfile, level)
         outfile.write('<%s%s %s' % (namespace_, name_, namespacedef_, ))
-        self.exportAttributes(outfile, level, namespace_, name_='docInternalType')
+        self.exportAttributes(outfile, level, namespace_,
+                              name_='docInternalType')
         outfile.write('>')
         self.exportChildren(outfile, level + 1, namespace_, name_)
         outfile.write('</%s%s>\n' % (namespace_, name_))
+
     def exportAttributes(self, outfile, level, namespace_='', name_='docInternalType'):
         pass
+
     def exportChildren(self, outfile, level, namespace_='', name_='docInternalType'):
         for item_ in self.content_:
             item_.export(outfile, level, item_.name, namespace_)
+
     def hasContent_(self):
         if (
             self.para is not None or
             self.sect1 is not None
-            ):
+        ):
             return True
         else:
             return False
+
     def exportLiteral(self, outfile, level, name_='docInternalType'):
         level += 1
         self.exportLiteralAttributes(outfile, level, name_)
         if self.hasContent_():
             self.exportLiteralChildren(outfile, level, name_)
+
     def exportLiteralAttributes(self, outfile, level, name_):
         pass
+
     def exportLiteralChildren(self, outfile, level, name_):
         showIndent(outfile, level)
         outfile.write('content_ = [\n')
@@ -5244,32 +5941,35 @@ class docInternalType(GeneratedsSuper):
             item_.exportLiteral(outfile, level, name_)
         showIndent(outfile, level)
         outfile.write('],\n')
+
     def build(self, node_):
         attrs = node_.attributes
         self.buildAttributes(attrs)
         for child_ in node_.childNodes:
             nodeName_ = child_.nodeName.split(':')[-1]
             self.buildChildren(child_, nodeName_)
+
     def buildAttributes(self, attrs):
         pass
+
     def buildChildren(self, child_, nodeName_):
         if child_.nodeType == Node.ELEMENT_NODE and \
-            nodeName_ == 'para':
+                nodeName_ == 'para':
             childobj_ = docParaType.factory()
             childobj_.build(child_)
             obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
-                MixedContainer.TypeNone, 'para', childobj_)
+                                    MixedContainer.TypeNone, 'para', childobj_)
             self.content_.append(obj_)
         elif child_.nodeType == Node.ELEMENT_NODE and \
-            nodeName_ == 'sect1':
+                nodeName_ == 'sect1':
             childobj_ = docSect1Type.factory()
             childobj_.build(child_)
             obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
-                MixedContainer.TypeNone, 'sect1', childobj_)
+                                    MixedContainer.TypeNone, 'sect1', childobj_)
             self.content_.append(obj_)
         elif child_.nodeType == Node.TEXT_NODE:
             obj_ = self.mixedclass_(MixedContainer.CategoryText,
-                MixedContainer.TypeNone, '', child_.nodeValue)
+                                    MixedContainer.TypeNone, '', child_.nodeValue)
             self.content_.append(obj_)
 # end class docInternalType
 
@@ -5277,6 +5977,7 @@ class docInternalType(GeneratedsSuper):
 class docInternalS1Type(GeneratedsSuper):
     subclass = None
     superclass = None
+
     def __init__(self, para=None, sect2=None, mixedclass_=None, content_=None):
         if mixedclass_ is None:
             self.mixedclass_ = MixedContainer
@@ -5286,6 +5987,7 @@ class docInternalS1Type(GeneratedsSuper):
             self.content_ = []
         else:
             self.content_ = content_
+
     def factory(*args_, **kwargs_):
         if docInternalS1Type.subclass:
             return docInternalS1Type.subclass(*args_, **kwargs_)
@@ -5300,33 +6002,41 @@ class docInternalS1Type(GeneratedsSuper):
     def set_sect2(self, sect2): self.sect2 = sect2
     def add_sect2(self, value): self.sect2.append(value)
     def insert_sect2(self, index, value): self.sect2[index] = value
+
     def export(self, outfile, level, namespace_='', name_='docInternalS1Type', namespacedef_=''):
         showIndent(outfile, level)
         outfile.write('<%s%s %s' % (namespace_, name_, namespacedef_, ))
-        self.exportAttributes(outfile, level, namespace_, name_='docInternalS1Type')
+        self.exportAttributes(outfile, level, namespace_,
+                              name_='docInternalS1Type')
         outfile.write('>')
         self.exportChildren(outfile, level + 1, namespace_, name_)
         outfile.write('</%s%s>\n' % (namespace_, name_))
+
     def exportAttributes(self, outfile, level, namespace_='', name_='docInternalS1Type'):
         pass
+
     def exportChildren(self, outfile, level, namespace_='', name_='docInternalS1Type'):
         for item_ in self.content_:
             item_.export(outfile, level, item_.name, namespace_)
+
     def hasContent_(self):
         if (
             self.para is not None or
             self.sect2 is not None
-            ):
+        ):
             return True
         else:
             return False
+
     def exportLiteral(self, outfile, level, name_='docInternalS1Type'):
         level += 1
         self.exportLiteralAttributes(outfile, level, name_)
         if self.hasContent_():
             self.exportLiteralChildren(outfile, level, name_)
+
     def exportLiteralAttributes(self, outfile, level, name_):
         pass
+
     def exportLiteralChildren(self, outfile, level, name_):
         showIndent(outfile, level)
         outfile.write('content_ = [\n')
@@ -5340,32 +6050,35 @@ class docInternalS1Type(GeneratedsSuper):
             item_.exportLiteral(outfile, level, name_)
         showIndent(outfile, level)
         outfile.write('],\n')
+
     def build(self, node_):
         attrs = node_.attributes
         self.buildAttributes(attrs)
         for child_ in node_.childNodes:
             nodeName_ = child_.nodeName.split(':')[-1]
             self.buildChildren(child_, nodeName_)
+
     def buildAttributes(self, attrs):
         pass
+
     def buildChildren(self, child_, nodeName_):
         if child_.nodeType == Node.ELEMENT_NODE and \
-            nodeName_ == 'para':
+                nodeName_ == 'para':
             childobj_ = docParaType.factory()
             childobj_.build(child_)
             obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
-                MixedContainer.TypeNone, 'para', childobj_)
+                                    MixedContainer.TypeNone, 'para', childobj_)
             self.content_.append(obj_)
         elif child_.nodeType == Node.ELEMENT_NODE and \
-            nodeName_ == 'sect2':
+                nodeName_ == 'sect2':
             childobj_ = docSect2Type.factory()
             childobj_.build(child_)
             obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
-                MixedContainer.TypeNone, 'sect2', childobj_)
+                                    MixedContainer.TypeNone, 'sect2', childobj_)
             self.content_.append(obj_)
         elif child_.nodeType == Node.TEXT_NODE:
             obj_ = self.mixedclass_(MixedContainer.CategoryText,
-                MixedContainer.TypeNone, '', child_.nodeValue)
+                                    MixedContainer.TypeNone, '', child_.nodeValue)
             self.content_.append(obj_)
 # end class docInternalS1Type
 
@@ -5373,6 +6086,7 @@ class docInternalS1Type(GeneratedsSuper):
 class docInternalS2Type(GeneratedsSuper):
     subclass = None
     superclass = None
+
     def __init__(self, para=None, sect3=None, mixedclass_=None, content_=None):
         if mixedclass_ is None:
             self.mixedclass_ = MixedContainer
@@ -5382,6 +6096,7 @@ class docInternalS2Type(GeneratedsSuper):
             self.content_ = []
         else:
             self.content_ = content_
+
     def factory(*args_, **kwargs_):
         if docInternalS2Type.subclass:
             return docInternalS2Type.subclass(*args_, **kwargs_)
@@ -5396,33 +6111,41 @@ class docInternalS2Type(GeneratedsSuper):
     def set_sect3(self, sect3): self.sect3 = sect3
     def add_sect3(self, value): self.sect3.append(value)
     def insert_sect3(self, index, value): self.sect3[index] = value
+
     def export(self, outfile, level, namespace_='', name_='docInternalS2Type', namespacedef_=''):
         showIndent(outfile, level)
         outfile.write('<%s%s %s' % (namespace_, name_, namespacedef_, ))
-        self.exportAttributes(outfile, level, namespace_, name_='docInternalS2Type')
+        self.exportAttributes(outfile, level, namespace_,
+                              name_='docInternalS2Type')
         outfile.write('>')
         self.exportChildren(outfile, level + 1, namespace_, name_)
         outfile.write('</%s%s>\n' % (namespace_, name_))
+
     def exportAttributes(self, outfile, level, namespace_='', name_='docInternalS2Type'):
         pass
+
     def exportChildren(self, outfile, level, namespace_='', name_='docInternalS2Type'):
         for item_ in self.content_:
             item_.export(outfile, level, item_.name, namespace_)
+
     def hasContent_(self):
         if (
             self.para is not None or
             self.sect3 is not None
-            ):
+        ):
             return True
         else:
             return False
+
     def exportLiteral(self, outfile, level, name_='docInternalS2Type'):
         level += 1
         self.exportLiteralAttributes(outfile, level, name_)
         if self.hasContent_():
             self.exportLiteralChildren(outfile, level, name_)
+
     def exportLiteralAttributes(self, outfile, level, name_):
         pass
+
     def exportLiteralChildren(self, outfile, level, name_):
         showIndent(outfile, level)
         outfile.write('content_ = [\n')
@@ -5436,32 +6159,35 @@ class docInternalS2Type(GeneratedsSuper):
             item_.exportLiteral(outfile, level, name_)
         showIndent(outfile, level)
         outfile.write('],\n')
+
     def build(self, node_):
         attrs = node_.attributes
         self.buildAttributes(attrs)
         for child_ in node_.childNodes:
             nodeName_ = child_.nodeName.split(':')[-1]
             self.buildChildren(child_, nodeName_)
+
     def buildAttributes(self, attrs):
         pass
+
     def buildChildren(self, child_, nodeName_):
         if child_.nodeType == Node.ELEMENT_NODE and \
-            nodeName_ == 'para':
+                nodeName_ == 'para':
             childobj_ = docParaType.factory()
             childobj_.build(child_)
             obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
-                MixedContainer.TypeNone, 'para', childobj_)
+                                    MixedContainer.TypeNone, 'para', childobj_)
             self.content_.append(obj_)
         elif child_.nodeType == Node.ELEMENT_NODE and \
-            nodeName_ == 'sect3':
+                nodeName_ == 'sect3':
             childobj_ = docSect3Type.factory()
             childobj_.build(child_)
             obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
-                MixedContainer.TypeNone, 'sect3', childobj_)
+                                    MixedContainer.TypeNone, 'sect3', childobj_)
             self.content_.append(obj_)
         elif child_.nodeType == Node.TEXT_NODE:
             obj_ = self.mixedclass_(MixedContainer.CategoryText,
-                MixedContainer.TypeNone, '', child_.nodeValue)
+                                    MixedContainer.TypeNone, '', child_.nodeValue)
             self.content_.append(obj_)
 # end class docInternalS2Type
 
@@ -5469,6 +6195,7 @@ class docInternalS2Type(GeneratedsSuper):
 class docInternalS3Type(GeneratedsSuper):
     subclass = None
     superclass = None
+
     def __init__(self, para=None, sect3=None, mixedclass_=None, content_=None):
         if mixedclass_ is None:
             self.mixedclass_ = MixedContainer
@@ -5478,6 +6205,7 @@ class docInternalS3Type(GeneratedsSuper):
             self.content_ = []
         else:
             self.content_ = content_
+
     def factory(*args_, **kwargs_):
         if docInternalS3Type.subclass:
             return docInternalS3Type.subclass(*args_, **kwargs_)
@@ -5492,33 +6220,41 @@ class docInternalS3Type(GeneratedsSuper):
     def set_sect3(self, sect3): self.sect3 = sect3
     def add_sect3(self, value): self.sect3.append(value)
     def insert_sect3(self, index, value): self.sect3[index] = value
+
     def export(self, outfile, level, namespace_='', name_='docInternalS3Type', namespacedef_=''):
         showIndent(outfile, level)
         outfile.write('<%s%s %s' % (namespace_, name_, namespacedef_, ))
-        self.exportAttributes(outfile, level, namespace_, name_='docInternalS3Type')
+        self.exportAttributes(outfile, level, namespace_,
+                              name_='docInternalS3Type')
         outfile.write('>')
         self.exportChildren(outfile, level + 1, namespace_, name_)
         outfile.write('</%s%s>\n' % (namespace_, name_))
+
     def exportAttributes(self, outfile, level, namespace_='', name_='docInternalS3Type'):
         pass
+
     def exportChildren(self, outfile, level, namespace_='', name_='docInternalS3Type'):
         for item_ in self.content_:
             item_.export(outfile, level, item_.name, namespace_)
+
     def hasContent_(self):
         if (
             self.para is not None or
             self.sect3 is not None
-            ):
+        ):
             return True
         else:
             return False
+
     def exportLiteral(self, outfile, level, name_='docInternalS3Type'):
         level += 1
         self.exportLiteralAttributes(outfile, level, name_)
         if self.hasContent_():
             self.exportLiteralChildren(outfile, level, name_)
+
     def exportLiteralAttributes(self, outfile, level, name_):
         pass
+
     def exportLiteralChildren(self, outfile, level, name_):
         showIndent(outfile, level)
         outfile.write('content_ = [\n')
@@ -5532,32 +6268,35 @@ class docInternalS3Type(GeneratedsSuper):
             item_.exportLiteral(outfile, level, name_)
         showIndent(outfile, level)
         outfile.write('],\n')
+
     def build(self, node_):
         attrs = node_.attributes
         self.buildAttributes(attrs)
         for child_ in node_.childNodes:
             nodeName_ = child_.nodeName.split(':')[-1]
             self.buildChildren(child_, nodeName_)
+
     def buildAttributes(self, attrs):
         pass
+
     def buildChildren(self, child_, nodeName_):
         if child_.nodeType == Node.ELEMENT_NODE and \
-            nodeName_ == 'para':
+                nodeName_ == 'para':
             childobj_ = docParaType.factory()
             childobj_.build(child_)
             obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
-                MixedContainer.TypeNone, 'para', childobj_)
+                                    MixedContainer.TypeNone, 'para', childobj_)
             self.content_.append(obj_)
         elif child_.nodeType == Node.ELEMENT_NODE and \
-            nodeName_ == 'sect3':
+                nodeName_ == 'sect3':
             childobj_ = docSect4Type.factory()
             childobj_.build(child_)
             obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
-                MixedContainer.TypeNone, 'sect3', childobj_)
+                                    MixedContainer.TypeNone, 'sect3', childobj_)
             self.content_.append(obj_)
         elif child_.nodeType == Node.TEXT_NODE:
             obj_ = self.mixedclass_(MixedContainer.CategoryText,
-                MixedContainer.TypeNone, '', child_.nodeValue)
+                                    MixedContainer.TypeNone, '', child_.nodeValue)
             self.content_.append(obj_)
 # end class docInternalS3Type
 
@@ -5565,6 +6304,7 @@ class docInternalS3Type(GeneratedsSuper):
 class docInternalS4Type(GeneratedsSuper):
     subclass = None
     superclass = None
+
     def __init__(self, para=None, mixedclass_=None, content_=None):
         if mixedclass_ is None:
             self.mixedclass_ = MixedContainer
@@ -5574,6 +6314,7 @@ class docInternalS4Type(GeneratedsSuper):
             self.content_ = []
         else:
             self.content_ = content_
+
     def factory(*args_, **kwargs_):
         if docInternalS4Type.subclass:
             return docInternalS4Type.subclass(*args_, **kwargs_)
@@ -5584,32 +6325,40 @@ class docInternalS4Type(GeneratedsSuper):
     def set_para(self, para): self.para = para
     def add_para(self, value): self.para.append(value)
     def insert_para(self, index, value): self.para[index] = value
+
     def export(self, outfile, level, namespace_='', name_='docInternalS4Type', namespacedef_=''):
         showIndent(outfile, level)
         outfile.write('<%s%s %s' % (namespace_, name_, namespacedef_, ))
-        self.exportAttributes(outfile, level, namespace_, name_='docInternalS4Type')
+        self.exportAttributes(outfile, level, namespace_,
+                              name_='docInternalS4Type')
         outfile.write('>')
         self.exportChildren(outfile, level + 1, namespace_, name_)
         outfile.write('</%s%s>\n' % (namespace_, name_))
+
     def exportAttributes(self, outfile, level, namespace_='', name_='docInternalS4Type'):
         pass
+
     def exportChildren(self, outfile, level, namespace_='', name_='docInternalS4Type'):
         for item_ in self.content_:
             item_.export(outfile, level, item_.name, namespace_)
+
     def hasContent_(self):
         if (
             self.para is not None
-            ):
+        ):
             return True
         else:
             return False
+
     def exportLiteral(self, outfile, level, name_='docInternalS4Type'):
         level += 1
         self.exportLiteralAttributes(outfile, level, name_)
         if self.hasContent_():
             self.exportLiteralChildren(outfile, level, name_)
+
     def exportLiteralAttributes(self, outfile, level, name_):
         pass
+
     def exportLiteralChildren(self, outfile, level, name_):
         showIndent(outfile, level)
         outfile.write('content_ = [\n')
@@ -5617,25 +6366,28 @@ class docInternalS4Type(GeneratedsSuper):
             item_.exportLiteral(outfile, level, name_)
         showIndent(outfile, level)
         outfile.write('],\n')
+
     def build(self, node_):
         attrs = node_.attributes
         self.buildAttributes(attrs)
         for child_ in node_.childNodes:
             nodeName_ = child_.nodeName.split(':')[-1]
             self.buildChildren(child_, nodeName_)
+
     def buildAttributes(self, attrs):
         pass
+
     def buildChildren(self, child_, nodeName_):
         if child_.nodeType == Node.ELEMENT_NODE and \
-            nodeName_ == 'para':
+                nodeName_ == 'para':
             childobj_ = docParaType.factory()
             childobj_.build(child_)
             obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
-                MixedContainer.TypeNone, 'para', childobj_)
+                                    MixedContainer.TypeNone, 'para', childobj_)
             self.content_.append(obj_)
         elif child_.nodeType == Node.TEXT_NODE:
             obj_ = self.mixedclass_(MixedContainer.CategoryText,
-                MixedContainer.TypeNone, '', child_.nodeValue)
+                                    MixedContainer.TypeNone, '', child_.nodeValue)
             self.content_.append(obj_)
 # end class docInternalS4Type
 
@@ -5643,6 +6395,7 @@ class docInternalS4Type(GeneratedsSuper):
 class docTitleType(GeneratedsSuper):
     subclass = None
     superclass = None
+
     def __init__(self, valueOf_='', mixedclass_=None, content_=None):
         if mixedclass_ is None:
             self.mixedclass_ = MixedContainer
@@ -5652,6 +6405,7 @@ class docTitleType(GeneratedsSuper):
             self.content_ = []
         else:
             self.content_ = content_
+
     def factory(*args_, **kwargs_):
         if docTitleType.subclass:
             return docTitleType.subclass(*args_, **kwargs_)
@@ -5660,6 +6414,7 @@ class docTitleType(GeneratedsSuper):
     factory = staticmethod(factory)
     def getValueOf_(self): return self.valueOf_
     def setValueOf_(self, valueOf_): self.valueOf_ = valueOf_
+
     def export(self, outfile, level, namespace_='', name_='docTitleType', namespacedef_=''):
         showIndent(outfile, level)
         outfile.write('<%s%s %s' % (namespace_, name_, namespacedef_, ))
@@ -5667,33 +6422,40 @@ class docTitleType(GeneratedsSuper):
         outfile.write('>')
         self.exportChildren(outfile, level + 1, namespace_, name_)
         outfile.write('</%s%s>\n' % (namespace_, name_))
+
     def exportAttributes(self, outfile, level, namespace_='', name_='docTitleType'):
         pass
+
     def exportChildren(self, outfile, level, namespace_='', name_='docTitleType'):
-        if self.valueOf_.find('![CDATA')>-1:
-            value=quote_xml('%s' % self.valueOf_)
-            value=value.replace('![CDATA','<![CDATA')
-            value=value.replace(']]',']]>')
+        if self.valueOf_.find('![CDATA') > -1:
+            value = quote_xml('%s' % self.valueOf_)
+            value = value.replace('![CDATA', '<![CDATA')
+            value = value.replace(']]', ']]>')
             outfile.write(value)
         else:
             outfile.write(quote_xml('%s' % self.valueOf_))
+
     def hasContent_(self):
         if (
             self.valueOf_ is not None
-            ):
+        ):
             return True
         else:
             return False
+
     def exportLiteral(self, outfile, level, name_='docTitleType'):
         level += 1
         self.exportLiteralAttributes(outfile, level, name_)
         if self.hasContent_():
             self.exportLiteralChildren(outfile, level, name_)
+
     def exportLiteralAttributes(self, outfile, level, name_):
         pass
+
     def exportLiteralChildren(self, outfile, level, name_):
         showIndent(outfile, level)
         outfile.write('valueOf_ = "%s",\n' % (self.valueOf_,))
+
     def build(self, node_):
         attrs = node_.attributes
         self.buildAttributes(attrs)
@@ -5701,23 +6463,26 @@ class docTitleType(GeneratedsSuper):
         for child_ in node_.childNodes:
             nodeName_ = child_.nodeName.split(':')[-1]
             self.buildChildren(child_, nodeName_)
+
     def buildAttributes(self, attrs):
         pass
+
     def buildChildren(self, child_, nodeName_):
         if child_.nodeType == Node.TEXT_NODE:
             obj_ = self.mixedclass_(MixedContainer.CategoryText,
-                MixedContainer.TypeNone, '', child_.nodeValue)
+                                    MixedContainer.TypeNone, '', child_.nodeValue)
             self.content_.append(obj_)
         if child_.nodeType == Node.TEXT_NODE:
             self.valueOf_ += child_.nodeValue
         elif child_.nodeType == Node.CDATA_SECTION_NODE:
-            self.valueOf_ += '![CDATA['+child_.nodeValue+']]'
+            self.valueOf_ += '![CDATA[' + child_.nodeValue + ']]'
 # end class docTitleType
 
 
 class docParaType(GeneratedsSuper):
     subclass = None
     superclass = None
+
     def __init__(self, valueOf_='', mixedclass_=None, content_=None):
         if mixedclass_ is None:
             self.mixedclass_ = MixedContainer
@@ -5727,6 +6492,7 @@ class docParaType(GeneratedsSuper):
             self.content_ = []
         else:
             self.content_ = content_
+
     def factory(*args_, **kwargs_):
         if docParaType.subclass:
             return docParaType.subclass(*args_, **kwargs_)
@@ -5735,6 +6501,7 @@ class docParaType(GeneratedsSuper):
     factory = staticmethod(factory)
     def getValueOf_(self): return self.valueOf_
     def setValueOf_(self, valueOf_): self.valueOf_ = valueOf_
+
     def export(self, outfile, level, namespace_='', name_='docParaType', namespacedef_=''):
         showIndent(outfile, level)
         outfile.write('<%s%s %s' % (namespace_, name_, namespacedef_, ))
@@ -5742,33 +6509,40 @@ class docParaType(GeneratedsSuper):
         outfile.write('>')
         self.exportChildren(outfile, level + 1, namespace_, name_)
         outfile.write('</%s%s>\n' % (namespace_, name_))
+
     def exportAttributes(self, outfile, level, namespace_='', name_='docParaType'):
         pass
+
     def exportChildren(self, outfile, level, namespace_='', name_='docParaType'):
-        if self.valueOf_.find('![CDATA')>-1:
-            value=quote_xml('%s' % self.valueOf_)
-            value=value.replace('![CDATA','<![CDATA')
-            value=value.replace(']]',']]>')
+        if self.valueOf_.find('![CDATA') > -1:
+            value = quote_xml('%s' % self.valueOf_)
+            value = value.replace('![CDATA', '<![CDATA')
+            value = value.replace(']]', ']]>')
             outfile.write(value)
         else:
             outfile.write(quote_xml('%s' % self.valueOf_))
+
     def hasContent_(self):
         if (
             self.valueOf_ is not None
-            ):
+        ):
             return True
         else:
             return False
+
     def exportLiteral(self, outfile, level, name_='docParaType'):
         level += 1
         self.exportLiteralAttributes(outfile, level, name_)
         if self.hasContent_():
             self.exportLiteralChildren(outfile, level, name_)
+
     def exportLiteralAttributes(self, outfile, level, name_):
         pass
+
     def exportLiteralChildren(self, outfile, level, name_):
         showIndent(outfile, level)
         outfile.write('valueOf_ = "%s",\n' % (self.valueOf_,))
+
     def build(self, node_):
         attrs = node_.attributes
         self.buildAttributes(attrs)
@@ -5776,23 +6550,26 @@ class docParaType(GeneratedsSuper):
         for child_ in node_.childNodes:
             nodeName_ = child_.nodeName.split(':')[-1]
             self.buildChildren(child_, nodeName_)
+
     def buildAttributes(self, attrs):
         pass
+
     def buildChildren(self, child_, nodeName_):
         if child_.nodeType == Node.TEXT_NODE:
             obj_ = self.mixedclass_(MixedContainer.CategoryText,
-                MixedContainer.TypeNone, '', child_.nodeValue)
+                                    MixedContainer.TypeNone, '', child_.nodeValue)
             self.content_.append(obj_)
         if child_.nodeType == Node.TEXT_NODE:
             self.valueOf_ += child_.nodeValue
         elif child_.nodeType == Node.CDATA_SECTION_NODE:
-            self.valueOf_ += '![CDATA['+child_.nodeValue+']]'
+            self.valueOf_ += '![CDATA[' + child_.nodeValue + ']]'
 # end class docParaType
 
 
 class docMarkupType(GeneratedsSuper):
     subclass = None
     superclass = None
+
     def __init__(self, valueOf_='', mixedclass_=None, content_=None):
         if mixedclass_ is None:
             self.mixedclass_ = MixedContainer
@@ -5802,6 +6579,7 @@ class docMarkupType(GeneratedsSuper):
             self.content_ = []
         else:
             self.content_ = content_
+
     def factory(*args_, **kwargs_):
         if docMarkupType.subclass:
             return docMarkupType.subclass(*args_, **kwargs_)
@@ -5810,40 +6588,49 @@ class docMarkupType(GeneratedsSuper):
     factory = staticmethod(factory)
     def getValueOf_(self): return self.valueOf_
     def setValueOf_(self, valueOf_): self.valueOf_ = valueOf_
+
     def export(self, outfile, level, namespace_='', name_='docMarkupType', namespacedef_=''):
         showIndent(outfile, level)
         outfile.write('<%s%s %s' % (namespace_, name_, namespacedef_, ))
-        self.exportAttributes(outfile, level, namespace_, name_='docMarkupType')
+        self.exportAttributes(outfile, level, namespace_,
+                              name_='docMarkupType')
         outfile.write('>')
         self.exportChildren(outfile, level + 1, namespace_, name_)
         outfile.write('</%s%s>\n' % (namespace_, name_))
+
     def exportAttributes(self, outfile, level, namespace_='', name_='docMarkupType'):
         pass
+
     def exportChildren(self, outfile, level, namespace_='', name_='docMarkupType'):
-        if self.valueOf_.find('![CDATA')>-1:
-            value=quote_xml('%s' % self.valueOf_)
-            value=value.replace('![CDATA','<![CDATA')
-            value=value.replace(']]',']]>')
+        if self.valueOf_.find('![CDATA') > -1:
+            value = quote_xml('%s' % self.valueOf_)
+            value = value.replace('![CDATA', '<![CDATA')
+            value = value.replace(']]', ']]>')
             outfile.write(value)
         else:
             outfile.write(quote_xml('%s' % self.valueOf_))
+
     def hasContent_(self):
         if (
             self.valueOf_ is not None
-            ):
+        ):
             return True
         else:
             return False
+
     def exportLiteral(self, outfile, level, name_='docMarkupType'):
         level += 1
         self.exportLiteralAttributes(outfile, level, name_)
         if self.hasContent_():
             self.exportLiteralChildren(outfile, level, name_)
+
     def exportLiteralAttributes(self, outfile, level, name_):
         pass
+
     def exportLiteralChildren(self, outfile, level, name_):
         showIndent(outfile, level)
         outfile.write('valueOf_ = "%s",\n' % (self.valueOf_,))
+
     def build(self, node_):
         attrs = node_.attributes
         self.buildAttributes(attrs)
@@ -5851,23 +6638,26 @@ class docMarkupType(GeneratedsSuper):
         for child_ in node_.childNodes:
             nodeName_ = child_.nodeName.split(':')[-1]
             self.buildChildren(child_, nodeName_)
+
     def buildAttributes(self, attrs):
         pass
+
     def buildChildren(self, child_, nodeName_):
         if child_.nodeType == Node.TEXT_NODE:
             obj_ = self.mixedclass_(MixedContainer.CategoryText,
-                MixedContainer.TypeNone, '', child_.nodeValue)
+                                    MixedContainer.TypeNone, '', child_.nodeValue)
             self.content_.append(obj_)
         if child_.nodeType == Node.TEXT_NODE:
             self.valueOf_ += child_.nodeValue
         elif child_.nodeType == Node.CDATA_SECTION_NODE:
-            self.valueOf_ += '![CDATA['+child_.nodeValue+']]'
+            self.valueOf_ += '![CDATA[' + child_.nodeValue + ']]'
 # end class docMarkupType
 
 
 class docURLLink(GeneratedsSuper):
     subclass = None
     superclass = None
+
     def __init__(self, url=None, valueOf_='', mixedclass_=None, content_=None):
         self.url = url
         if mixedclass_ is None:
@@ -5878,6 +6668,7 @@ class docURLLink(GeneratedsSuper):
             self.content_ = []
         else:
             self.content_ = content_
+
     def factory(*args_, **kwargs_):
         if docURLLink.subclass:
             return docURLLink.subclass(*args_, **kwargs_)
@@ -5888,6 +6679,7 @@ class docURLLink(GeneratedsSuper):
     def set_url(self, url): self.url = url
     def getValueOf_(self): return self.valueOf_
     def setValueOf_(self, valueOf_): self.valueOf_ = valueOf_
+
     def export(self, outfile, level, namespace_='', name_='docURLLink', namespacedef_=''):
         showIndent(outfile, level)
         outfile.write('<%s%s %s' % (namespace_, name_, namespacedef_, ))
@@ -5895,36 +6687,44 @@ class docURLLink(GeneratedsSuper):
         outfile.write('>')
         self.exportChildren(outfile, level + 1, namespace_, name_)
         outfile.write('</%s%s>\n' % (namespace_, name_))
+
     def exportAttributes(self, outfile, level, namespace_='', name_='docURLLink'):
         if self.url is not None:
-            outfile.write(' url=%s' % (self.format_string(quote_attrib(self.url).encode(ExternalEncoding), input_name='url'), ))
+            outfile.write(' url=%s' % (self.format_string(quote_attrib(
+                self.url).encode(ExternalEncoding), input_name='url'), ))
+
     def exportChildren(self, outfile, level, namespace_='', name_='docURLLink'):
-        if self.valueOf_.find('![CDATA')>-1:
-            value=quote_xml('%s' % self.valueOf_)
-            value=value.replace('![CDATA','<![CDATA')
-            value=value.replace(']]',']]>')
+        if self.valueOf_.find('![CDATA') > -1:
+            value = quote_xml('%s' % self.valueOf_)
+            value = value.replace('![CDATA', '<![CDATA')
+            value = value.replace(']]', ']]>')
             outfile.write(value)
         else:
             outfile.write(quote_xml('%s' % self.valueOf_))
+
     def hasContent_(self):
         if (
             self.valueOf_ is not None
-            ):
+        ):
             return True
         else:
             return False
+
     def exportLiteral(self, outfile, level, name_='docURLLink'):
         level += 1
         self.exportLiteralAttributes(outfile, level, name_)
         if self.hasContent_():
             self.exportLiteralChildren(outfile, level, name_)
+
     def exportLiteralAttributes(self, outfile, level, name_):
         if self.url is not None:
             showIndent(outfile, level)
             outfile.write('url = %s,\n' % (self.url,))
+
     def exportLiteralChildren(self, outfile, level, name_):
         showIndent(outfile, level)
         outfile.write('valueOf_ = "%s",\n' % (self.valueOf_,))
+
     def build(self, node_):
         attrs = node_.attributes
         self.buildAttributes(attrs)
@@ -5932,24 +6732,27 @@ class docURLLink(GeneratedsSuper):
         for child_ in node_.childNodes:
             nodeName_ = child_.nodeName.split(':')[-1]
             self.buildChildren(child_, nodeName_)
+
     def buildAttributes(self, attrs):
         if attrs.get('url'):
             self.url = attrs.get('url').value
+
     def buildChildren(self, child_, nodeName_):
         if child_.nodeType == Node.TEXT_NODE:
             obj_ = self.mixedclass_(MixedContainer.CategoryText,
-                MixedContainer.TypeNone, '', child_.nodeValue)
+                                    MixedContainer.TypeNone, '', child_.nodeValue)
             self.content_.append(obj_)
         if child_.nodeType == Node.TEXT_NODE:
             self.valueOf_ += child_.nodeValue
         elif child_.nodeType == Node.CDATA_SECTION_NODE:
-            self.valueOf_ += '![CDATA['+child_.nodeValue+']]'
+            self.valueOf_ += '![CDATA[' + child_.nodeValue + ']]'
 # end class docURLLink
 
 
 class docAnchorType(GeneratedsSuper):
     subclass = None
     superclass = None
+
     def __init__(self, id=None, valueOf_='', mixedclass_=None, content_=None):
         self.id = id
         if mixedclass_ is None:
@@ -5960,6 +6763,7 @@ class docAnchorType(GeneratedsSuper):
             self.content_ = []
         else:
             self.content_ = content_
+
     def factory(*args_, **kwargs_):
         if docAnchorType.subclass:
             return docAnchorType.subclass(*args_, **kwargs_)
@@ -5970,43 +6774,53 @@ class docAnchorType(GeneratedsSuper):
     def set_id(self, id): self.id = id
     def getValueOf_(self): return self.valueOf_
     def setValueOf_(self, valueOf_): self.valueOf_ = valueOf_
+
     def export(self, outfile, level, namespace_='', name_='docAnchorType', namespacedef_=''):
         showIndent(outfile, level)
         outfile.write('<%s%s %s' % (namespace_, name_, namespacedef_, ))
-        self.exportAttributes(outfile, level, namespace_, name_='docAnchorType')
+        self.exportAttributes(outfile, level, namespace_,
+                              name_='docAnchorType')
         outfile.write('>')
         self.exportChildren(outfile, level + 1, namespace_, name_)
         outfile.write('</%s%s>\n' % (namespace_, name_))
+
     def exportAttributes(self, outfile, level, namespace_='', name_='docAnchorType'):
         if self.id is not None:
-            outfile.write(' id=%s' % (self.format_string(quote_attrib(self.id).encode(ExternalEncoding), input_name='id'), ))
+            outfile.write(' id=%s' % (self.format_string(quote_attrib(
+                self.id).encode(ExternalEncoding), input_name='id'), ))
+
     def exportChildren(self, outfile, level, namespace_='', name_='docAnchorType'):
-        if self.valueOf_.find('![CDATA')>-1:
-            value=quote_xml('%s' % self.valueOf_)
-            value=value.replace('![CDATA','<![CDATA')
-            value=value.replace(']]',']]>')
+        if self.valueOf_.find('![CDATA') > -1:
+            value = quote_xml('%s' % self.valueOf_)
+            value = value.replace('![CDATA', '<![CDATA')
+            value = value.replace(']]', ']]>')
             outfile.write(value)
         else:
             outfile.write(quote_xml('%s' % self.valueOf_))
+
     def hasContent_(self):
         if (
             self.valueOf_ is not None
-            ):
+        ):
             return True
         else:
             return False
+
     def exportLiteral(self, outfile, level, name_='docAnchorType'):
         level += 1
         self.exportLiteralAttributes(outfile, level, name_)
         if self.hasContent_():
             self.exportLiteralChildren(outfile, level, name_)
+
     def exportLiteralAttributes(self, outfile, level, name_):
         if self.id is not None:
             showIndent(outfile, level)
             outfile.write('id = %s,\n' % (self.id,))
+
     def exportLiteralChildren(self, outfile, level, name_):
         showIndent(outfile, level)
         outfile.write('valueOf_ = "%s",\n' % (self.valueOf_,))
+
     def build(self, node_):
         attrs = node_.attributes
         self.buildAttributes(attrs)
@@ -6014,24 +6828,27 @@ class docAnchorType(GeneratedsSuper):
         for child_ in node_.childNodes:
             nodeName_ = child_.nodeName.split(':')[-1]
             self.buildChildren(child_, nodeName_)
+
     def buildAttributes(self, attrs):
         if attrs.get('id'):
             self.id = attrs.get('id').value
+
     def buildChildren(self, child_, nodeName_):
         if child_.nodeType == Node.TEXT_NODE:
             obj_ = self.mixedclass_(MixedContainer.CategoryText,
-                MixedContainer.TypeNone, '', child_.nodeValue)
+                                    MixedContainer.TypeNone, '', child_.nodeValue)
             self.content_.append(obj_)
         if child_.nodeType == Node.TEXT_NODE:
             self.valueOf_ += child_.nodeValue
         elif child_.nodeType == Node.CDATA_SECTION_NODE:
-            self.valueOf_ += '![CDATA['+child_.nodeValue+']]'
+            self.valueOf_ += '![CDATA[' + child_.nodeValue + ']]'
 # end class docAnchorType
 
 
 class docFormulaType(GeneratedsSuper):
     subclass = None
     superclass = None
+
     def __init__(self, id=None, valueOf_='', mixedclass_=None, content_=None):
         self.id = id
         if mixedclass_ is None:
@@ -6042,6 +6859,7 @@ class docFormulaType(GeneratedsSuper):
             self.content_ = []
         else:
             self.content_ = content_
+
     def factory(*args_, **kwargs_):
         if docFormulaType.subclass:
             return docFormulaType.subclass(*args_, **kwargs_)
@@ -6052,43 +6870,53 @@ class docFormulaType(GeneratedsSuper):
     def set_id(self, id): self.id = id
     def getValueOf_(self): return self.valueOf_
     def setValueOf_(self, valueOf_): self.valueOf_ = valueOf_
+
     def export(self, outfile, level, namespace_='', name_='docFormulaType', namespacedef_=''):
         showIndent(outfile, level)
         outfile.write('<%s%s %s' % (namespace_, name_, namespacedef_, ))
-        self.exportAttributes(outfile, level, namespace_, name_='docFormulaType')
+        self.exportAttributes(outfile, level, namespace_,
+                              name_='docFormulaType')
         outfile.write('>')
         self.exportChildren(outfile, level + 1, namespace_, name_)
         outfile.write('</%s%s>\n' % (namespace_, name_))
+
     def exportAttributes(self, outfile, level, namespace_='', name_='docFormulaType'):
         if self.id is not None:
-            outfile.write(' id=%s' % (self.format_string(quote_attrib(self.id).encode(ExternalEncoding), input_name='id'), ))
+            outfile.write(' id=%s' % (self.format_string(quote_attrib(
+                self.id).encode(ExternalEncoding), input_name='id'), ))
+
     def exportChildren(self, outfile, level, namespace_='', name_='docFormulaType'):
-        if self.valueOf_.find('![CDATA')>-1:
-            value=quote_xml('%s' % self.valueOf_)
-            value=value.replace('![CDATA','<![CDATA')
-            value=value.replace(']]',']]>')
+        if self.valueOf_.find('![CDATA') > -1:
+            value = quote_xml('%s' % self.valueOf_)
+            value = value.replace('![CDATA', '<![CDATA')
+            value = value.replace(']]', ']]>')
             outfile.write(value)
         else:
             outfile.write(quote_xml('%s' % self.valueOf_))
+
     def hasContent_(self):
         if (
             self.valueOf_ is not None
-            ):
+        ):
             return True
         else:
             return False
+
     def exportLiteral(self, outfile, level, name_='docFormulaType'):
         level += 1
         self.exportLiteralAttributes(outfile, level, name_)
         if self.hasContent_():
             self.exportLiteralChildren(outfile, level, name_)
+
     def exportLiteralAttributes(self, outfile, level, name_):
         if self.id is not None:
             showIndent(outfile, level)
             outfile.write('id = %s,\n' % (self.id,))
+
     def exportLiteralChildren(self, outfile, level, name_):
         showIndent(outfile, level)
         outfile.write('valueOf_ = "%s",\n' % (self.valueOf_,))
+
     def build(self, node_):
         attrs = node_.attributes
         self.buildAttributes(attrs)
@@ -6096,27 +6924,31 @@ class docFormulaType(GeneratedsSuper):
         for child_ in node_.childNodes:
             nodeName_ = child_.nodeName.split(':')[-1]
             self.buildChildren(child_, nodeName_)
+
     def buildAttributes(self, attrs):
         if attrs.get('id'):
             self.id = attrs.get('id').value
+
     def buildChildren(self, child_, nodeName_):
         if child_.nodeType == Node.TEXT_NODE:
             obj_ = self.mixedclass_(MixedContainer.CategoryText,
-                MixedContainer.TypeNone, '', child_.nodeValue)
+                                    MixedContainer.TypeNone, '', child_.nodeValue)
             self.content_.append(obj_)
         if child_.nodeType == Node.TEXT_NODE:
             self.valueOf_ += child_.nodeValue
         elif child_.nodeType == Node.CDATA_SECTION_NODE:
-            self.valueOf_ += '![CDATA['+child_.nodeValue+']]'
+            self.valueOf_ += '![CDATA[' + child_.nodeValue + ']]'
 # end class docFormulaType
 
 
 class docIndexEntryType(GeneratedsSuper):
     subclass = None
     superclass = None
+
     def __init__(self, primaryie=None, secondaryie=None):
         self.primaryie = primaryie
         self.secondaryie = secondaryie
+
     def factory(*args_, **kwargs_):
         if docIndexEntryType.subclass:
             return docIndexEntryType.subclass(*args_, **kwargs_)
@@ -6127,10 +6959,12 @@ class docIndexEntryType(GeneratedsSuper):
     def set_primaryie(self, primaryie): self.primaryie = primaryie
     def get_secondaryie(self): return self.secondaryie
     def set_secondaryie(self, secondaryie): self.secondaryie = secondaryie
+
     def export(self, outfile, level, namespace_='', name_='docIndexEntryType', namespacedef_=''):
         showIndent(outfile, level)
         outfile.write('<%s%s %s' % (namespace_, name_, namespacedef_, ))
-        self.exportAttributes(outfile, level, namespace_, name_='docIndexEntryType')
+        self.exportAttributes(outfile, level, namespace_,
+                              name_='docIndexEntryType')
         if self.hasContent_():
             outfile.write('>\n')
             self.exportChildren(outfile, level + 1, namespace_, name_)
@@ -6138,52 +6972,65 @@ class docIndexEntryType(GeneratedsSuper):
             outfile.write('</%s%s>\n' % (namespace_, name_))
         else:
             outfile.write(' />\n')
+
     def exportAttributes(self, outfile, level, namespace_='', name_='docIndexEntryType'):
         pass
+
     def exportChildren(self, outfile, level, namespace_='', name_='docIndexEntryType'):
         if self.primaryie is not None:
             showIndent(outfile, level)
-            outfile.write('<%sprimaryie>%s</%sprimaryie>\n' % (namespace_, self.format_string(quote_xml(self.primaryie).encode(ExternalEncoding), input_name='primaryie'), namespace_))
+            outfile.write('<%sprimaryie>%s</%sprimaryie>\n' % (namespace_, self.format_string(
+                quote_xml(self.primaryie).encode(ExternalEncoding), input_name='primaryie'), namespace_))
         if self.secondaryie is not None:
             showIndent(outfile, level)
-            outfile.write('<%ssecondaryie>%s</%ssecondaryie>\n' % (namespace_, self.format_string(quote_xml(self.secondaryie).encode(ExternalEncoding), input_name='secondaryie'), namespace_))
+            outfile.write('<%ssecondaryie>%s</%ssecondaryie>\n' % (namespace_, self.format_string(
+                quote_xml(self.secondaryie).encode(ExternalEncoding), input_name='secondaryie'), namespace_))
+
     def hasContent_(self):
         if (
             self.primaryie is not None or
             self.secondaryie is not None
-            ):
+        ):
             return True
         else:
             return False
+
     def exportLiteral(self, outfile, level, name_='docIndexEntryType'):
         level += 1
         self.exportLiteralAttributes(outfile, level, name_)
         if self.hasContent_():
             self.exportLiteralChildren(outfile, level, name_)
+
     def exportLiteralAttributes(self, outfile, level, name_):
         pass
+
     def exportLiteralChildren(self, outfile, level, name_):
         showIndent(outfile, level)
-        outfile.write('primaryie=%s,\n' % quote_python(self.primaryie).encode(ExternalEncoding))
+        outfile.write('primaryie=%s,\n' % quote_python(
+            self.primaryie).encode(ExternalEncoding))
         showIndent(outfile, level)
-        outfile.write('secondaryie=%s,\n' % quote_python(self.secondaryie).encode(ExternalEncoding))
+        outfile.write('secondaryie=%s,\n' % quote_python(
+            self.secondaryie).encode(ExternalEncoding))
+
     def build(self, node_):
         attrs = node_.attributes
         self.buildAttributes(attrs)
         for child_ in node_.childNodes:
             nodeName_ = child_.nodeName.split(':')[-1]
             self.buildChildren(child_, nodeName_)
+
     def buildAttributes(self, attrs):
         pass
+
     def buildChildren(self, child_, nodeName_):
         if child_.nodeType == Node.ELEMENT_NODE and \
-            nodeName_ == 'primaryie':
+                nodeName_ == 'primaryie':
             primaryie_ = ''
             for text__content_ in child_.childNodes:
                 primaryie_ += text__content_.nodeValue
             self.primaryie = primaryie_
         elif child_.nodeType == Node.ELEMENT_NODE and \
-            nodeName_ == 'secondaryie':
+                nodeName_ == 'secondaryie':
             secondaryie_ = ''
             for text__content_ in child_.childNodes:
                 secondaryie_ += text__content_.nodeValue
@@ -6194,11 +7041,13 @@ class docIndexEntryType(GeneratedsSuper):
 class docListType(GeneratedsSuper):
     subclass = None
     superclass = None
+
     def __init__(self, listitem=None):
         if listitem is None:
             self.listitem = []
         else:
             self.listitem = listitem
+
     def factory(*args_, **kwargs_):
         if docListType.subclass:
             return docListType.subclass(*args_, **kwargs_)
@@ -6209,6 +7058,7 @@ class docListType(GeneratedsSuper):
     def set_listitem(self, listitem): self.listitem = listitem
     def add_listitem(self, value): self.listitem.append(value)
     def insert_listitem(self, index, value): self.listitem[index] = value
+
     def export(self, outfile, level, namespace_='', name_='docListType', namespacedef_=''):
         showIndent(outfile, level)
         outfile.write('<%s%s %s' % (namespace_, name_, namespacedef_, ))
@@ -6220,25 +7070,31 @@ class docListType(GeneratedsSuper):
             outfile.write('</%s%s>\n' % (namespace_, name_))
         else:
             outfile.write(' />\n')
+
     def exportAttributes(self, outfile, level, namespace_='', name_='docListType'):
         pass
+
     def exportChildren(self, outfile, level, namespace_='', name_='docListType'):
         for listitem_ in self.listitem:
             listitem_.export(outfile, level, namespace_, name_='listitem')
+
     def hasContent_(self):
         if (
             self.listitem is not None
-            ):
+        ):
             return True
         else:
             return False
+
     def exportLiteral(self, outfile, level, name_='docListType'):
         level += 1
         self.exportLiteralAttributes(outfile, level, name_)
         if self.hasContent_():
             self.exportLiteralChildren(outfile, level, name_)
+
     def exportLiteralAttributes(self, outfile, level, name_):
         pass
+
     def exportLiteralChildren(self, outfile, level, name_):
         showIndent(outfile, level)
         outfile.write('listitem=[\n')
@@ -6252,17 +7108,20 @@ class docListType(GeneratedsSuper):
         level -= 1
         showIndent(outfile, level)
         outfile.write('],\n')
+
     def build(self, node_):
         attrs = node_.attributes
         self.buildAttributes(attrs)
         for child_ in node_.childNodes:
             nodeName_ = child_.nodeName.split(':')[-1]
             self.buildChildren(child_, nodeName_)
+
     def buildAttributes(self, attrs):
         pass
+
     def buildChildren(self, child_, nodeName_):
         if child_.nodeType == Node.ELEMENT_NODE and \
-            nodeName_ == 'listitem':
+                nodeName_ == 'listitem':
             obj_ = docListItemType.factory()
             obj_.build(child_)
             self.listitem.append(obj_)
@@ -6272,11 +7131,13 @@ class docListType(GeneratedsSuper):
 class docListItemType(GeneratedsSuper):
     subclass = None
     superclass = None
+
     def __init__(self, para=None):
         if para is None:
             self.para = []
         else:
             self.para = para
+
     def factory(*args_, **kwargs_):
         if docListItemType.subclass:
             return docListItemType.subclass(*args_, **kwargs_)
@@ -6287,10 +7148,12 @@ class docListItemType(GeneratedsSuper):
     def set_para(self, para): self.para = para
     def add_para(self, value): self.para.append(value)
     def insert_para(self, index, value): self.para[index] = value
+
     def export(self, outfile, level, namespace_='', name_='docListItemType', namespacedef_=''):
         showIndent(outfile, level)
         outfile.write('<%s%s %s' % (namespace_, name_, namespacedef_, ))
-        self.exportAttributes(outfile, level, namespace_, name_='docListItemType')
+        self.exportAttributes(outfile, level, namespace_,
+                              name_='docListItemType')
         if self.hasContent_():
             outfile.write('>\n')
             self.exportChildren(outfile, level + 1, namespace_, name_)
@@ -6298,25 +7161,31 @@ class docListItemType(GeneratedsSuper):
             outfile.write('</%s%s>\n' % (namespace_, name_))
         else:
             outfile.write(' />\n')
+
     def exportAttributes(self, outfile, level, namespace_='', name_='docListItemType'):
         pass
+
     def exportChildren(self, outfile, level, namespace_='', name_='docListItemType'):
         for para_ in self.para:
             para_.export(outfile, level, namespace_, name_='para')
+
     def hasContent_(self):
         if (
             self.para is not None
-            ):
+        ):
             return True
         else:
             return False
+
     def exportLiteral(self, outfile, level, name_='docListItemType'):
         level += 1
         self.exportLiteralAttributes(outfile, level, name_)
         if self.hasContent_():
             self.exportLiteralChildren(outfile, level, name_)
+
     def exportLiteralAttributes(self, outfile, level, name_):
         pass
+
     def exportLiteralChildren(self, outfile, level, name_):
         showIndent(outfile, level)
         outfile.write('para=[\n')
@@ -6330,17 +7199,20 @@ class docListItemType(GeneratedsSuper):
         level -= 1
         showIndent(outfile, level)
         outfile.write('],\n')
+
     def build(self, node_):
         attrs = node_.attributes
         self.buildAttributes(attrs)
         for child_ in node_.childNodes:
             nodeName_ = child_.nodeName.split(':')[-1]
             self.buildChildren(child_, nodeName_)
+
     def buildAttributes(self, attrs):
         pass
+
     def buildChildren(self, child_, nodeName_):
         if child_.nodeType == Node.ELEMENT_NODE and \
-            nodeName_ == 'para':
+                nodeName_ == 'para':
             obj_ = docParaType.factory()
             obj_.build(child_)
             self.para.append(obj_)
@@ -6350,6 +7222,7 @@ class docListItemType(GeneratedsSuper):
 class docSimpleSectType(GeneratedsSuper):
     subclass = None
     superclass = None
+
     def __init__(self, kind=None, title=None, para=None):
         self.kind = kind
         self.title = title
@@ -6357,6 +7230,7 @@ class docSimpleSectType(GeneratedsSuper):
             self.para = []
         else:
             self.para = para
+
     def factory(*args_, **kwargs_):
         if docSimpleSectType.subclass:
             return docSimpleSectType.subclass(*args_, **kwargs_)
@@ -6371,10 +7245,12 @@ class docSimpleSectType(GeneratedsSuper):
     def insert_para(self, index, value): self.para[index] = value
     def get_kind(self): return self.kind
     def set_kind(self, kind): self.kind = kind
+
     def export(self, outfile, level, namespace_='', name_='docSimpleSectType', namespacedef_=''):
         showIndent(outfile, level)
         outfile.write('<%s%s %s' % (namespace_, name_, namespacedef_, ))
-        self.exportAttributes(outfile, level, namespace_, name_='docSimpleSectType')
+        self.exportAttributes(outfile, level, namespace_,
+                              name_='docSimpleSectType')
         if self.hasContent_():
             outfile.write('>\n')
             self.exportChildren(outfile, level + 1, namespace_, name_)
@@ -6382,31 +7258,37 @@ class docSimpleSectType(GeneratedsSuper):
             outfile.write('</%s%s>\n' % (namespace_, name_))
         else:
             outfile.write(' />\n')
+
     def exportAttributes(self, outfile, level, namespace_='', name_='docSimpleSectType'):
         if self.kind is not None:
             outfile.write(' kind=%s' % (quote_attrib(self.kind), ))
+
     def exportChildren(self, outfile, level, namespace_='', name_='docSimpleSectType'):
         if self.title:
             self.title.export(outfile, level, namespace_, name_='title')
         for para_ in self.para:
             para_.export(outfile, level, namespace_, name_='para')
+
     def hasContent_(self):
         if (
             self.title is not None or
             self.para is not None
-            ):
+        ):
             return True
         else:
             return False
+
     def exportLiteral(self, outfile, level, name_='docSimpleSectType'):
         level += 1
         self.exportLiteralAttributes(outfile, level, name_)
         if self.hasContent_():
             self.exportLiteralChildren(outfile, level, name_)
+
     def exportLiteralAttributes(self, outfile, level, name_):
         if self.kind is not None:
             showIndent(outfile, level)
             outfile.write('kind = "%s",\n' % (self.kind,))
+
     def exportLiteralChildren(self, outfile, level, name_):
         if self.title:
             showIndent(outfile, level)
@@ -6426,23 +7308,26 @@ class docSimpleSectType(GeneratedsSuper):
         level -= 1
         showIndent(outfile, level)
         outfile.write('],\n')
+
     def build(self, node_):
         attrs = node_.attributes
         self.buildAttributes(attrs)
         for child_ in node_.childNodes:
             nodeName_ = child_.nodeName.split(':')[-1]
             self.buildChildren(child_, nodeName_)
+
     def buildAttributes(self, attrs):
         if attrs.get('kind'):
             self.kind = attrs.get('kind').value
+
     def buildChildren(self, child_, nodeName_):
         if child_.nodeType == Node.ELEMENT_NODE and \
-            nodeName_ == 'title':
+                nodeName_ == 'title':
             obj_ = docTitleType.factory()
             obj_.build(child_)
             self.set_title(obj_)
         elif child_.nodeType == Node.ELEMENT_NODE and \
-            nodeName_ == 'para':
+                nodeName_ == 'para':
             obj_ = docParaType.factory()
             obj_.build(child_)
             self.para.append(obj_)
@@ -6452,8 +7337,10 @@ class docSimpleSectType(GeneratedsSuper):
 class docVarListEntryType(GeneratedsSuper):
     subclass = None
     superclass = None
+
     def __init__(self, term=None):
         self.term = term
+
     def factory(*args_, **kwargs_):
         if docVarListEntryType.subclass:
             return docVarListEntryType.subclass(*args_, **kwargs_)
@@ -6462,10 +7349,12 @@ class docVarListEntryType(GeneratedsSuper):
     factory = staticmethod(factory)
     def get_term(self): return self.term
     def set_term(self, term): self.term = term
+
     def export(self, outfile, level, namespace_='', name_='docVarListEntryType', namespacedef_=''):
         showIndent(outfile, level)
         outfile.write('<%s%s %s' % (namespace_, name_, namespacedef_, ))
-        self.exportAttributes(outfile, level, namespace_, name_='docVarListEntryType')
+        self.exportAttributes(outfile, level, namespace_,
+                              name_='docVarListEntryType')
         if self.hasContent_():
             outfile.write('>\n')
             self.exportChildren(outfile, level + 1, namespace_, name_)
@@ -6473,25 +7362,31 @@ class docVarListEntryType(GeneratedsSuper):
             outfile.write('</%s%s>\n' % (namespace_, name_))
         else:
             outfile.write(' />\n')
+
     def exportAttributes(self, outfile, level, namespace_='', name_='docVarListEntryType'):
         pass
+
     def exportChildren(self, outfile, level, namespace_='', name_='docVarListEntryType'):
         if self.term:
             self.term.export(outfile, level, namespace_, name_='term', )
+
     def hasContent_(self):
         if (
             self.term is not None
-            ):
+        ):
             return True
         else:
             return False
+
     def exportLiteral(self, outfile, level, name_='docVarListEntryType'):
         level += 1
         self.exportLiteralAttributes(outfile, level, name_)
         if self.hasContent_():
             self.exportLiteralChildren(outfile, level, name_)
+
     def exportLiteralAttributes(self, outfile, level, name_):
         pass
+
     def exportLiteralChildren(self, outfile, level, name_):
         if self.term:
             showIndent(outfile, level)
@@ -6499,17 +7394,20 @@ class docVarListEntryType(GeneratedsSuper):
             self.term.exportLiteral(outfile, level, name_='term')
             showIndent(outfile, level)
             outfile.write('),\n')
+
     def build(self, node_):
         attrs = node_.attributes
         self.buildAttributes(attrs)
         for child_ in node_.childNodes:
             nodeName_ = child_.nodeName.split(':')[-1]
             self.buildChildren(child_, nodeName_)
+
     def buildAttributes(self, attrs):
         pass
+
     def buildChildren(self, child_, nodeName_):
         if child_.nodeType == Node.ELEMENT_NODE and \
-            nodeName_ == 'term':
+                nodeName_ == 'term':
             obj_ = docTitleType.factory()
             obj_.build(child_)
             self.set_term(obj_)
@@ -6519,8 +7417,10 @@ class docVarListEntryType(GeneratedsSuper):
 class docVariableListType(GeneratedsSuper):
     subclass = None
     superclass = None
+
     def __init__(self, valueOf_=''):
         self.valueOf_ = valueOf_
+
     def factory(*args_, **kwargs_):
         if docVariableListType.subclass:
             return docVariableListType.subclass(*args_, **kwargs_)
@@ -6529,10 +7429,12 @@ class docVariableListType(GeneratedsSuper):
     factory = staticmethod(factory)
     def getValueOf_(self): return self.valueOf_
     def setValueOf_(self, valueOf_): self.valueOf_ = valueOf_
+
     def export(self, outfile, level, namespace_='', name_='docVariableListType', namespacedef_=''):
         showIndent(outfile, level)
         outfile.write('<%s%s %s' % (namespace_, name_, namespacedef_, ))
-        self.exportAttributes(outfile, level, namespace_, name_='docVariableListType')
+        self.exportAttributes(outfile, level, namespace_,
+                              name_='docVariableListType')
         if self.hasContent_():
             outfile.write('>\n')
             self.exportChildren(outfile, level + 1, namespace_, name_)
@@ -6540,33 +7442,40 @@ class docVariableListType(GeneratedsSuper):
             outfile.write('</%s%s>\n' % (namespace_, name_))
         else:
             outfile.write(' />\n')
+
     def exportAttributes(self, outfile, level, namespace_='', name_='docVariableListType'):
         pass
+
     def exportChildren(self, outfile, level, namespace_='', name_='docVariableListType'):
-        if self.valueOf_.find('![CDATA')>-1:
-            value=quote_xml('%s' % self.valueOf_)
-            value=value.replace('![CDATA','<![CDATA')
-            value=value.replace(']]',']]>')
+        if self.valueOf_.find('![CDATA') > -1:
+            value = quote_xml('%s' % self.valueOf_)
+            value = value.replace('![CDATA', '<![CDATA')
+            value = value.replace(']]', ']]>')
             outfile.write(value)
         else:
             outfile.write(quote_xml('%s' % self.valueOf_))
+
     def hasContent_(self):
         if (
             self.valueOf_ is not None
-            ):
+        ):
             return True
         else:
             return False
+
     def exportLiteral(self, outfile, level, name_='docVariableListType'):
         level += 1
         self.exportLiteralAttributes(outfile, level, name_)
         if self.hasContent_():
             self.exportLiteralChildren(outfile, level, name_)
+
     def exportLiteralAttributes(self, outfile, level, name_):
         pass
+
     def exportLiteralChildren(self, outfile, level, name_):
         showIndent(outfile, level)
         outfile.write('valueOf_ = "%s",\n' % (self.valueOf_,))
+
     def build(self, node_):
         attrs = node_.attributes
         self.buildAttributes(attrs)
@@ -6574,19 +7483,22 @@ class docVariableListType(GeneratedsSuper):
         for child_ in node_.childNodes:
             nodeName_ = child_.nodeName.split(':')[-1]
             self.buildChildren(child_, nodeName_)
+
     def buildAttributes(self, attrs):
         pass
+
     def buildChildren(self, child_, nodeName_):
         if child_.nodeType == Node.TEXT_NODE:
             self.valueOf_ += child_.nodeValue
         elif child_.nodeType == Node.CDATA_SECTION_NODE:
-            self.valueOf_ += '![CDATA['+child_.nodeValue+']]'
+            self.valueOf_ += '![CDATA[' + child_.nodeValue + ']]'
 # end class docVariableListType
 
 
 class docRefTextType(GeneratedsSuper):
     subclass = None
     superclass = None
+
     def __init__(self, refid=None, kindref=None, external=None, valueOf_='', mixedclass_=None, content_=None):
         self.refid = refid
         self.kindref = kindref
@@ -6599,6 +7511,7 @@ class docRefTextType(GeneratedsSuper):
             self.content_ = []
         else:
             self.content_ = content_
+
     def factory(*args_, **kwargs_):
         if docRefTextType.subclass:
             return docRefTextType.subclass(*args_, **kwargs_)
@@ -6613,40 +7526,49 @@ class docRefTextType(GeneratedsSuper):
     def set_external(self, external): self.external = external
     def getValueOf_(self): return self.valueOf_
     def setValueOf_(self, valueOf_): self.valueOf_ = valueOf_
+
     def export(self, outfile, level, namespace_='', name_='docRefTextType', namespacedef_=''):
         showIndent(outfile, level)
         outfile.write('<%s%s %s' % (namespace_, name_, namespacedef_, ))
-        self.exportAttributes(outfile, level, namespace_, name_='docRefTextType')
+        self.exportAttributes(outfile, level, namespace_,
+                              name_='docRefTextType')
         outfile.write('>')
         self.exportChildren(outfile, level + 1, namespace_, name_)
         outfile.write('</%s%s>\n' % (namespace_, name_))
+
     def exportAttributes(self, outfile, level, namespace_='', name_='docRefTextType'):
         if self.refid is not None:
-            outfile.write(' refid=%s' % (self.format_string(quote_attrib(self.refid).encode(ExternalEncoding), input_name='refid'), ))
+            outfile.write(' refid=%s' % (self.format_string(quote_attrib(
+                self.refid).encode(ExternalEncoding), input_name='refid'), ))
         if self.kindref is not None:
             outfile.write(' kindref=%s' % (quote_attrib(self.kindref), ))
         if self.external is not None:
-            outfile.write(' external=%s' % (self.format_string(quote_attrib(self.external).encode(ExternalEncoding), input_name='external'), ))
+            outfile.write(' external=%s' % (self.format_string(quote_attrib(
+                self.external).encode(ExternalEncoding), input_name='external'), ))
+
     def exportChildren(self, outfile, level, namespace_='', name_='docRefTextType'):
-        if self.valueOf_.find('![CDATA')>-1:
-            value=quote_xml('%s' % self.valueOf_)
-            value=value.replace('![CDATA','<![CDATA')
-            value=value.replace(']]',']]>')
+        if self.valueOf_.find('![CDATA') > -1:
+            value = quote_xml('%s' % self.valueOf_)
+            value = value.replace('![CDATA', '<![CDATA')
+            value = value.replace(']]', ']]>')
             outfile.write(value)
         else:
             outfile.write(quote_xml('%s' % self.valueOf_))
+
     def hasContent_(self):
         if (
             self.valueOf_ is not None
-            ):
+        ):
             return True
         else:
             return False
+
     def exportLiteral(self, outfile, level, name_='docRefTextType'):
         level += 1
         self.exportLiteralAttributes(outfile, level, name_)
         if self.hasContent_():
             self.exportLiteralChildren(outfile, level, name_)
+
     def exportLiteralAttributes(self, outfile, level, name_):
         if self.refid is not None:
             showIndent(outfile, level)
@@ -6657,9 +7579,11 @@ class docRefTextType(GeneratedsSuper):
         if self.external is not None:
             showIndent(outfile, level)
             outfile.write('external = %s,\n' % (self.external,))
+
     def exportLiteralChildren(self, outfile, level, name_):
         showIndent(outfile, level)
         outfile.write('valueOf_ = "%s",\n' % (self.valueOf_,))
+
     def build(self, node_):
         attrs = node_.attributes
         self.buildAttributes(attrs)
@@ -6667,6 +7591,7 @@ class docRefTextType(GeneratedsSuper):
         for child_ in node_.childNodes:
             nodeName_ = child_.nodeName.split(':')[-1]
             self.buildChildren(child_, nodeName_)
+
     def buildAttributes(self, attrs):
         if attrs.get('refid'):
             self.refid = attrs.get('refid').value
@@ -6674,21 +7599,23 @@ class docRefTextType(GeneratedsSuper):
             self.kindref = attrs.get('kindref').value
         if attrs.get('external'):
             self.external = attrs.get('external').value
+
     def buildChildren(self, child_, nodeName_):
         if child_.nodeType == Node.TEXT_NODE:
             obj_ = self.mixedclass_(MixedContainer.CategoryText,
-                MixedContainer.TypeNone, '', child_.nodeValue)
+                                    MixedContainer.TypeNone, '', child_.nodeValue)
             self.content_.append(obj_)
         if child_.nodeType == Node.TEXT_NODE:
             self.valueOf_ += child_.nodeValue
         elif child_.nodeType == Node.CDATA_SECTION_NODE:
-            self.valueOf_ += '![CDATA['+child_.nodeValue+']]'
+            self.valueOf_ += '![CDATA[' + child_.nodeValue + ']]'
 # end class docRefTextType
 
 
 class docTableType(GeneratedsSuper):
     subclass = None
     superclass = None
+
     def __init__(self, rows=None, cols=None, row=None, caption=None):
         self.rows = rows
         self.cols = cols
@@ -6697,6 +7624,7 @@ class docTableType(GeneratedsSuper):
         else:
             self.row = row
         self.caption = caption
+
     def factory(*args_, **kwargs_):
         if docTableType.subclass:
             return docTableType.subclass(*args_, **kwargs_)
@@ -6713,6 +7641,7 @@ class docTableType(GeneratedsSuper):
     def set_rows(self, rows): self.rows = rows
     def get_cols(self): return self.cols
     def set_cols(self, cols): self.cols = cols
+
     def export(self, outfile, level, namespace_='', name_='docTableType', namespacedef_=''):
         showIndent(outfile, level)
         outfile.write('<%s%s %s' % (namespace_, name_, namespacedef_, ))
@@ -6724,29 +7653,36 @@ class docTableType(GeneratedsSuper):
             outfile.write('</%s%s>\n' % (namespace_, name_))
         else:
             outfile.write(' />\n')
+
     def exportAttributes(self, outfile, level, namespace_='', name_='docTableType'):
         if self.rows is not None:
-            outfile.write(' rows="%s"' % self.format_integer(self.rows, input_name='rows'))
+            outfile.write(' rows="%s"' % self.format_integer(
+                self.rows, input_name='rows'))
         if self.cols is not None:
-            outfile.write(' cols="%s"' % self.format_integer(self.cols, input_name='cols'))
+            outfile.write(' cols="%s"' % self.format_integer(
+                self.cols, input_name='cols'))
+
     def exportChildren(self, outfile, level, namespace_='', name_='docTableType'):
         for row_ in self.row:
             row_.export(outfile, level, namespace_, name_='row')
         if self.caption:
             self.caption.export(outfile, level, namespace_, name_='caption')
+
     def hasContent_(self):
         if (
             self.row is not None or
             self.caption is not None
-            ):
+        ):
             return True
         else:
             return False
+
     def exportLiteral(self, outfile, level, name_='docTableType'):
         level += 1
         self.exportLiteralAttributes(outfile, level, name_)
         if self.hasContent_():
             self.exportLiteralChildren(outfile, level, name_)
+
     def exportLiteralAttributes(self, outfile, level, name_):
         if self.rows is not None:
             showIndent(outfile, level)
@@ -6754,6 +7690,7 @@ class docTableType(GeneratedsSuper):
         if self.cols is not None:
             showIndent(outfile, level)
             outfile.write('cols = %s,\n' % (self.cols,))
+
     def exportLiteralChildren(self, outfile, level, name_):
         showIndent(outfile, level)
         outfile.write('row=[\n')
@@ -6773,12 +7710,14 @@ class docTableType(GeneratedsSuper):
             self.caption.exportLiteral(outfile, level, name_='caption')
             showIndent(outfile, level)
             outfile.write('),\n')
+
     def build(self, node_):
         attrs = node_.attributes
         self.buildAttributes(attrs)
         for child_ in node_.childNodes:
             nodeName_ = child_.nodeName.split(':')[-1]
             self.buildChildren(child_, nodeName_)
+
     def buildAttributes(self, attrs):
         if attrs.get('rows'):
             try:
@@ -6790,14 +7729,15 @@ class docTableType(GeneratedsSuper):
                 self.cols = int(attrs.get('cols').value)
             except ValueError as exp:
                 raise ValueError('Bad integer attribute (cols): %s' % exp)
+
     def buildChildren(self, child_, nodeName_):
         if child_.nodeType == Node.ELEMENT_NODE and \
-            nodeName_ == 'row':
+                nodeName_ == 'row':
             obj_ = docRowType.factory()
             obj_.build(child_)
             self.row.append(obj_)
         elif child_.nodeType == Node.ELEMENT_NODE and \
-            nodeName_ == 'caption':
+                nodeName_ == 'caption':
             obj_ = docCaptionType.factory()
             obj_.build(child_)
             self.set_caption(obj_)
@@ -6807,11 +7747,13 @@ class docTableType(GeneratedsSuper):
 class docRowType(GeneratedsSuper):
     subclass = None
     superclass = None
+
     def __init__(self, entry=None):
         if entry is None:
             self.entry = []
         else:
             self.entry = entry
+
     def factory(*args_, **kwargs_):
         if docRowType.subclass:
             return docRowType.subclass(*args_, **kwargs_)
@@ -6822,6 +7764,7 @@ class docRowType(GeneratedsSuper):
     def set_entry(self, entry): self.entry = entry
     def add_entry(self, value): self.entry.append(value)
     def insert_entry(self, index, value): self.entry[index] = value
+
     def export(self, outfile, level, namespace_='', name_='docRowType', namespacedef_=''):
         showIndent(outfile, level)
         outfile.write('<%s%s %s' % (namespace_, name_, namespacedef_, ))
@@ -6833,25 +7776,31 @@ class docRowType(GeneratedsSuper):
             outfile.write('</%s%s>\n' % (namespace_, name_))
         else:
             outfile.write(' />\n')
+
     def exportAttributes(self, outfile, level, namespace_='', name_='docRowType'):
         pass
+
     def exportChildren(self, outfile, level, namespace_='', name_='docRowType'):
         for entry_ in self.entry:
             entry_.export(outfile, level, namespace_, name_='entry')
+
     def hasContent_(self):
         if (
             self.entry is not None
-            ):
+        ):
             return True
         else:
             return False
+
     def exportLiteral(self, outfile, level, name_='docRowType'):
         level += 1
         self.exportLiteralAttributes(outfile, level, name_)
         if self.hasContent_():
             self.exportLiteralChildren(outfile, level, name_)
+
     def exportLiteralAttributes(self, outfile, level, name_):
         pass
+
     def exportLiteralChildren(self, outfile, level, name_):
         showIndent(outfile, level)
         outfile.write('entry=[\n')
@@ -6865,17 +7814,20 @@ class docRowType(GeneratedsSuper):
         level -= 1
         showIndent(outfile, level)
         outfile.write('],\n')
+
     def build(self, node_):
         attrs = node_.attributes
         self.buildAttributes(attrs)
         for child_ in node_.childNodes:
             nodeName_ = child_.nodeName.split(':')[-1]
             self.buildChildren(child_, nodeName_)
+
     def buildAttributes(self, attrs):
         pass
+
     def buildChildren(self, child_, nodeName_):
         if child_.nodeType == Node.ELEMENT_NODE and \
-            nodeName_ == 'entry':
+                nodeName_ == 'entry':
             obj_ = docEntryType.factory()
             obj_.build(child_)
             self.entry.append(obj_)
@@ -6885,12 +7837,14 @@ class docRowType(GeneratedsSuper):
 class docEntryType(GeneratedsSuper):
     subclass = None
     superclass = None
+
     def __init__(self, thead=None, para=None):
         self.thead = thead
         if para is None:
             self.para = []
         else:
             self.para = para
+
     def factory(*args_, **kwargs_):
         if docEntryType.subclass:
             return docEntryType.subclass(*args_, **kwargs_)
@@ -6903,6 +7857,7 @@ class docEntryType(GeneratedsSuper):
     def insert_para(self, index, value): self.para[index] = value
     def get_thead(self): return self.thead
     def set_thead(self, thead): self.thead = thead
+
     def export(self, outfile, level, namespace_='', name_='docEntryType', namespacedef_=''):
         showIndent(outfile, level)
         outfile.write('<%s%s %s' % (namespace_, name_, namespacedef_, ))
@@ -6914,28 +7869,34 @@ class docEntryType(GeneratedsSuper):
             outfile.write('</%s%s>\n' % (namespace_, name_))
         else:
             outfile.write(' />\n')
+
     def exportAttributes(self, outfile, level, namespace_='', name_='docEntryType'):
         if self.thead is not None:
             outfile.write(' thead=%s' % (quote_attrib(self.thead), ))
+
     def exportChildren(self, outfile, level, namespace_='', name_='docEntryType'):
         for para_ in self.para:
             para_.export(outfile, level, namespace_, name_='para')
+
     def hasContent_(self):
         if (
             self.para is not None
-            ):
+        ):
             return True
         else:
             return False
+
     def exportLiteral(self, outfile, level, name_='docEntryType'):
         level += 1
         self.exportLiteralAttributes(outfile, level, name_)
         if self.hasContent_():
             self.exportLiteralChildren(outfile, level, name_)
+
     def exportLiteralAttributes(self, outfile, level, name_):
         if self.thead is not None:
             showIndent(outfile, level)
             outfile.write('thead = "%s",\n' % (self.thead,))
+
     def exportLiteralChildren(self, outfile, level, name_):
         showIndent(outfile, level)
         outfile.write('para=[\n')
@@ -6949,18 +7910,21 @@ class docEntryType(GeneratedsSuper):
         level -= 1
         showIndent(outfile, level)
         outfile.write('],\n')
+
     def build(self, node_):
         attrs = node_.attributes
         self.buildAttributes(attrs)
         for child_ in node_.childNodes:
             nodeName_ = child_.nodeName.split(':')[-1]
             self.buildChildren(child_, nodeName_)
+
     def buildAttributes(self, attrs):
         if attrs.get('thead'):
             self.thead = attrs.get('thead').value
+
     def buildChildren(self, child_, nodeName_):
         if child_.nodeType == Node.ELEMENT_NODE and \
-            nodeName_ == 'para':
+                nodeName_ == 'para':
             obj_ = docParaType.factory()
             obj_.build(child_)
             self.para.append(obj_)
@@ -6970,6 +7934,7 @@ class docEntryType(GeneratedsSuper):
 class docCaptionType(GeneratedsSuper):
     subclass = None
     superclass = None
+
     def __init__(self, valueOf_='', mixedclass_=None, content_=None):
         if mixedclass_ is None:
             self.mixedclass_ = MixedContainer
@@ -6979,6 +7944,7 @@ class docCaptionType(GeneratedsSuper):
             self.content_ = []
         else:
             self.content_ = content_
+
     def factory(*args_, **kwargs_):
         if docCaptionType.subclass:
             return docCaptionType.subclass(*args_, **kwargs_)
@@ -6987,40 +7953,49 @@ class docCaptionType(GeneratedsSuper):
     factory = staticmethod(factory)
     def getValueOf_(self): return self.valueOf_
     def setValueOf_(self, valueOf_): self.valueOf_ = valueOf_
+
     def export(self, outfile, level, namespace_='', name_='docCaptionType', namespacedef_=''):
         showIndent(outfile, level)
         outfile.write('<%s%s %s' % (namespace_, name_, namespacedef_, ))
-        self.exportAttributes(outfile, level, namespace_, name_='docCaptionType')
+        self.exportAttributes(outfile, level, namespace_,
+                              name_='docCaptionType')
         outfile.write('>')
         self.exportChildren(outfile, level + 1, namespace_, name_)
         outfile.write('</%s%s>\n' % (namespace_, name_))
+
     def exportAttributes(self, outfile, level, namespace_='', name_='docCaptionType'):
         pass
+
     def exportChildren(self, outfile, level, namespace_='', name_='docCaptionType'):
-        if self.valueOf_.find('![CDATA')>-1:
-            value=quote_xml('%s' % self.valueOf_)
-            value=value.replace('![CDATA','<![CDATA')
-            value=value.replace(']]',']]>')
+        if self.valueOf_.find('![CDATA') > -1:
+            value = quote_xml('%s' % self.valueOf_)
+            value = value.replace('![CDATA', '<![CDATA')
+            value = value.replace(']]', ']]>')
             outfile.write(value)
         else:
             outfile.write(quote_xml('%s' % self.valueOf_))
+
     def hasContent_(self):
         if (
             self.valueOf_ is not None
-            ):
+        ):
             return True
         else:
             return False
+
     def exportLiteral(self, outfile, level, name_='docCaptionType'):
         level += 1
         self.exportLiteralAttributes(outfile, level, name_)
         if self.hasContent_():
             self.exportLiteralChildren(outfile, level, name_)
+
     def exportLiteralAttributes(self, outfile, level, name_):
         pass
+
     def exportLiteralChildren(self, outfile, level, name_):
         showIndent(outfile, level)
         outfile.write('valueOf_ = "%s",\n' % (self.valueOf_,))
+
     def build(self, node_):
         attrs = node_.attributes
         self.buildAttributes(attrs)
@@ -7028,23 +8003,26 @@ class docCaptionType(GeneratedsSuper):
         for child_ in node_.childNodes:
             nodeName_ = child_.nodeName.split(':')[-1]
             self.buildChildren(child_, nodeName_)
+
     def buildAttributes(self, attrs):
         pass
+
     def buildChildren(self, child_, nodeName_):
         if child_.nodeType == Node.TEXT_NODE:
             obj_ = self.mixedclass_(MixedContainer.CategoryText,
-                MixedContainer.TypeNone, '', child_.nodeValue)
+                                    MixedContainer.TypeNone, '', child_.nodeValue)
             self.content_.append(obj_)
         if child_.nodeType == Node.TEXT_NODE:
             self.valueOf_ += child_.nodeValue
         elif child_.nodeType == Node.CDATA_SECTION_NODE:
-            self.valueOf_ += '![CDATA['+child_.nodeValue+']]'
+            self.valueOf_ += '![CDATA[' + child_.nodeValue + ']]'
 # end class docCaptionType
 
 
 class docHeadingType(GeneratedsSuper):
     subclass = None
     superclass = None
+
     def __init__(self, level=None, valueOf_='', mixedclass_=None, content_=None):
         self.level = level
         if mixedclass_ is None:
@@ -7055,6 +8033,7 @@ class docHeadingType(GeneratedsSuper):
             self.content_ = []
         else:
             self.content_ = content_
+
     def factory(*args_, **kwargs_):
         if docHeadingType.subclass:
             return docHeadingType.subclass(*args_, **kwargs_)
@@ -7065,43 +8044,53 @@ class docHeadingType(GeneratedsSuper):
     def set_level(self, level): self.level = level
     def getValueOf_(self): return self.valueOf_
     def setValueOf_(self, valueOf_): self.valueOf_ = valueOf_
+
     def export(self, outfile, level, namespace_='', name_='docHeadingType', namespacedef_=''):
         showIndent(outfile, level)
         outfile.write('<%s%s %s' % (namespace_, name_, namespacedef_, ))
-        self.exportAttributes(outfile, level, namespace_, name_='docHeadingType')
+        self.exportAttributes(outfile, level, namespace_,
+                              name_='docHeadingType')
         outfile.write('>')
         self.exportChildren(outfile, level + 1, namespace_, name_)
         outfile.write('</%s%s>\n' % (namespace_, name_))
+
     def exportAttributes(self, outfile, level, namespace_='', name_='docHeadingType'):
         if self.level is not None:
-            outfile.write(' level="%s"' % self.format_integer(self.level, input_name='level'))
+            outfile.write(' level="%s"' % self.format_integer(
+                self.level, input_name='level'))
+
     def exportChildren(self, outfile, level, namespace_='', name_='docHeadingType'):
-        if self.valueOf_.find('![CDATA')>-1:
-            value=quote_xml('%s' % self.valueOf_)
-            value=value.replace('![CDATA','<![CDATA')
-            value=value.replace(']]',']]>')
+        if self.valueOf_.find('![CDATA') > -1:
+            value = quote_xml('%s' % self.valueOf_)
+            value = value.replace('![CDATA', '<![CDATA')
+            value = value.replace(']]', ']]>')
             outfile.write(value)
         else:
             outfile.write(quote_xml('%s' % self.valueOf_))
+
     def hasContent_(self):
         if (
             self.valueOf_ is not None
-            ):
+        ):
             return True
         else:
             return False
+
     def exportLiteral(self, outfile, level, name_='docHeadingType'):
         level += 1
         self.exportLiteralAttributes(outfile, level, name_)
         if self.hasContent_():
             self.exportLiteralChildren(outfile, level, name_)
+
     def exportLiteralAttributes(self, outfile, level, name_):
         if self.level is not None:
             showIndent(outfile, level)
             outfile.write('level = %s,\n' % (self.level,))
+
     def exportLiteralChildren(self, outfile, level, name_):
         showIndent(outfile, level)
         outfile.write('valueOf_ = "%s",\n' % (self.valueOf_,))
+
     def build(self, node_):
         attrs = node_.attributes
         self.buildAttributes(attrs)
@@ -7109,27 +8098,30 @@ class docHeadingType(GeneratedsSuper):
         for child_ in node_.childNodes:
             nodeName_ = child_.nodeName.split(':')[-1]
             self.buildChildren(child_, nodeName_)
+
     def buildAttributes(self, attrs):
         if attrs.get('level'):
             try:
                 self.level = int(attrs.get('level').value)
             except ValueError as exp:
                 raise ValueError('Bad integer attribute (level): %s' % exp)
+
     def buildChildren(self, child_, nodeName_):
         if child_.nodeType == Node.TEXT_NODE:
             obj_ = self.mixedclass_(MixedContainer.CategoryText,
-                MixedContainer.TypeNone, '', child_.nodeValue)
+                                    MixedContainer.TypeNone, '', child_.nodeValue)
             self.content_.append(obj_)
         if child_.nodeType == Node.TEXT_NODE:
             self.valueOf_ += child_.nodeValue
         elif child_.nodeType == Node.CDATA_SECTION_NODE:
-            self.valueOf_ += '![CDATA['+child_.nodeValue+']]'
+            self.valueOf_ += '![CDATA[' + child_.nodeValue + ']]'
 # end class docHeadingType
 
 
 class docImageType(GeneratedsSuper):
     subclass = None
     superclass = None
+
     def __init__(self, width=None, type_=None, name=None, height=None, valueOf_='', mixedclass_=None, content_=None):
         self.width = width
         self.type_ = type_
@@ -7143,6 +8135,7 @@ class docImageType(GeneratedsSuper):
             self.content_ = []
         else:
             self.content_ = content_
+
     def factory(*args_, **kwargs_):
         if docImageType.subclass:
             return docImageType.subclass(*args_, **kwargs_)
@@ -7159,6 +8152,7 @@ class docImageType(GeneratedsSuper):
     def set_height(self, height): self.height = height
     def getValueOf_(self): return self.valueOf_
     def setValueOf_(self, valueOf_): self.valueOf_ = valueOf_
+
     def export(self, outfile, level, namespace_='', name_='docImageType', namespacedef_=''):
         showIndent(outfile, level)
         outfile.write('<%s%s %s' % (namespace_, name_, namespacedef_, ))
@@ -7166,35 +8160,43 @@ class docImageType(GeneratedsSuper):
         outfile.write('>')
         self.exportChildren(outfile, level + 1, namespace_, name_)
         outfile.write('</%s%s>\n' % (namespace_, name_))
+
     def exportAttributes(self, outfile, level, namespace_='', name_='docImageType'):
         if self.width is not None:
-            outfile.write(' width=%s' % (self.format_string(quote_attrib(self.width).encode(ExternalEncoding), input_name='width'), ))
+            outfile.write(' width=%s' % (self.format_string(quote_attrib(
+                self.width).encode(ExternalEncoding), input_name='width'), ))
         if self.type_ is not None:
             outfile.write(' type=%s' % (quote_attrib(self.type_), ))
         if self.name is not None:
-            outfile.write(' name=%s' % (self.format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
+            outfile.write(' name=%s' % (self.format_string(quote_attrib(
+                self.name).encode(ExternalEncoding), input_name='name'), ))
         if self.height is not None:
-            outfile.write(' height=%s' % (self.format_string(quote_attrib(self.height).encode(ExternalEncoding), input_name='height'), ))
+            outfile.write(' height=%s' % (self.format_string(quote_attrib(
+                self.height).encode(ExternalEncoding), input_name='height'), ))
+
     def exportChildren(self, outfile, level, namespace_='', name_='docImageType'):
-        if self.valueOf_.find('![CDATA')>-1:
-            value=quote_xml('%s' % self.valueOf_)
-            value=value.replace('![CDATA','<![CDATA')
-            value=value.replace(']]',']]>')
+        if self.valueOf_.find('![CDATA') > -1:
+            value = quote_xml('%s' % self.valueOf_)
+            value = value.replace('![CDATA', '<![CDATA')
+            value = value.replace(']]', ']]>')
             outfile.write(value)
         else:
             outfile.write(quote_xml('%s' % self.valueOf_))
+
     def hasContent_(self):
         if (
             self.valueOf_ is not None
-            ):
+        ):
             return True
         else:
             return False
+
     def exportLiteral(self, outfile, level, name_='docImageType'):
         level += 1
         self.exportLiteralAttributes(outfile, level, name_)
         if self.hasContent_():
             self.exportLiteralChildren(outfile, level, name_)
+
     def exportLiteralAttributes(self, outfile, level, name_):
         if self.width is not None:
             showIndent(outfile, level)
@@ -7208,9 +8210,11 @@ class docImageType(GeneratedsSuper):
         if self.height is not None:
             showIndent(outfile, level)
             outfile.write('height = %s,\n' % (self.height,))
+
     def exportLiteralChildren(self, outfile, level, name_):
         showIndent(outfile, level)
         outfile.write('valueOf_ = "%s",\n' % (self.valueOf_,))
+
     def build(self, node_):
         attrs = node_.attributes
         self.buildAttributes(attrs)
@@ -7218,6 +8222,7 @@ class docImageType(GeneratedsSuper):
         for child_ in node_.childNodes:
             nodeName_ = child_.nodeName.split(':')[-1]
             self.buildChildren(child_, nodeName_)
+
     def buildAttributes(self, attrs):
         if attrs.get('width'):
             self.width = attrs.get('width').value
@@ -7227,21 +8232,23 @@ class docImageType(GeneratedsSuper):
             self.name = attrs.get('name').value
         if attrs.get('height'):
             self.height = attrs.get('height').value
+
     def buildChildren(self, child_, nodeName_):
         if child_.nodeType == Node.TEXT_NODE:
             obj_ = self.mixedclass_(MixedContainer.CategoryText,
-                MixedContainer.TypeNone, '', child_.nodeValue)
+                                    MixedContainer.TypeNone, '', child_.nodeValue)
             self.content_.append(obj_)
         if child_.nodeType == Node.TEXT_NODE:
             self.valueOf_ += child_.nodeValue
         elif child_.nodeType == Node.CDATA_SECTION_NODE:
-            self.valueOf_ += '![CDATA['+child_.nodeValue+']]'
+            self.valueOf_ += '![CDATA[' + child_.nodeValue + ']]'
 # end class docImageType
 
 
 class docDotFileType(GeneratedsSuper):
     subclass = None
     superclass = None
+
     def __init__(self, name=None, valueOf_='', mixedclass_=None, content_=None):
         self.name = name
         if mixedclass_ is None:
@@ -7252,6 +8259,7 @@ class docDotFileType(GeneratedsSuper):
             self.content_ = []
         else:
             self.content_ = content_
+
     def factory(*args_, **kwargs_):
         if docDotFileType.subclass:
             return docDotFileType.subclass(*args_, **kwargs_)
@@ -7262,43 +8270,53 @@ class docDotFileType(GeneratedsSuper):
     def set_name(self, name): self.name = name
     def getValueOf_(self): return self.valueOf_
     def setValueOf_(self, valueOf_): self.valueOf_ = valueOf_
+
     def export(self, outfile, level, namespace_='', name_='docDotFileType', namespacedef_=''):
         showIndent(outfile, level)
         outfile.write('<%s%s %s' % (namespace_, name_, namespacedef_, ))
-        self.exportAttributes(outfile, level, namespace_, name_='docDotFileType')
+        self.exportAttributes(outfile, level, namespace_,
+                              name_='docDotFileType')
         outfile.write('>')
         self.exportChildren(outfile, level + 1, namespace_, name_)
         outfile.write('</%s%s>\n' % (namespace_, name_))
+
     def exportAttributes(self, outfile, level, namespace_='', name_='docDotFileType'):
         if self.name is not None:
-            outfile.write(' name=%s' % (self.format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
+            outfile.write(' name=%s' % (self.format_string(quote_attrib(
+                self.name).encode(ExternalEncoding), input_name='name'), ))
+
     def exportChildren(self, outfile, level, namespace_='', name_='docDotFileType'):
-        if self.valueOf_.find('![CDATA')>-1:
-            value=quote_xml('%s' % self.valueOf_)
-            value=value.replace('![CDATA','<![CDATA')
-            value=value.replace(']]',']]>')
+        if self.valueOf_.find('![CDATA') > -1:
+            value = quote_xml('%s' % self.valueOf_)
+            value = value.replace('![CDATA', '<![CDATA')
+            value = value.replace(']]', ']]>')
             outfile.write(value)
         else:
             outfile.write(quote_xml('%s' % self.valueOf_))
+
     def hasContent_(self):
         if (
             self.valueOf_ is not None
-            ):
+        ):
             return True
         else:
             return False
+
     def exportLiteral(self, outfile, level, name_='docDotFileType'):
         level += 1
         self.exportLiteralAttributes(outfile, level, name_)
         if self.hasContent_():
             self.exportLiteralChildren(outfile, level, name_)
+
     def exportLiteralAttributes(self, outfile, level, name_):
         if self.name is not None:
             showIndent(outfile, level)
             outfile.write('name = %s,\n' % (self.name,))
+
     def exportLiteralChildren(self, outfile, level, name_):
         showIndent(outfile, level)
         outfile.write('valueOf_ = "%s",\n' % (self.valueOf_,))
+
     def build(self, node_):
         attrs = node_.attributes
         self.buildAttributes(attrs)
@@ -7306,24 +8324,27 @@ class docDotFileType(GeneratedsSuper):
         for child_ in node_.childNodes:
             nodeName_ = child_.nodeName.split(':')[-1]
             self.buildChildren(child_, nodeName_)
+
     def buildAttributes(self, attrs):
         if attrs.get('name'):
             self.name = attrs.get('name').value
+
     def buildChildren(self, child_, nodeName_):
         if child_.nodeType == Node.TEXT_NODE:
             obj_ = self.mixedclass_(MixedContainer.CategoryText,
-                MixedContainer.TypeNone, '', child_.nodeValue)
+                                    MixedContainer.TypeNone, '', child_.nodeValue)
             self.content_.append(obj_)
         if child_.nodeType == Node.TEXT_NODE:
             self.valueOf_ += child_.nodeValue
         elif child_.nodeType == Node.CDATA_SECTION_NODE:
-            self.valueOf_ += '![CDATA['+child_.nodeValue+']]'
+            self.valueOf_ += '![CDATA[' + child_.nodeValue + ']]'
 # end class docDotFileType
 
 
 class docTocItemType(GeneratedsSuper):
     subclass = None
     superclass = None
+
     def __init__(self, id=None, valueOf_='', mixedclass_=None, content_=None):
         self.id = id
         if mixedclass_ is None:
@@ -7334,6 +8355,7 @@ class docTocItemType(GeneratedsSuper):
             self.content_ = []
         else:
             self.content_ = content_
+
     def factory(*args_, **kwargs_):
         if docTocItemType.subclass:
             return docTocItemType.subclass(*args_, **kwargs_)
@@ -7344,43 +8366,53 @@ class docTocItemType(GeneratedsSuper):
     def set_id(self, id): self.id = id
     def getValueOf_(self): return self.valueOf_
     def setValueOf_(self, valueOf_): self.valueOf_ = valueOf_
+
     def export(self, outfile, level, namespace_='', name_='docTocItemType', namespacedef_=''):
         showIndent(outfile, level)
         outfile.write('<%s%s %s' % (namespace_, name_, namespacedef_, ))
-        self.exportAttributes(outfile, level, namespace_, name_='docTocItemType')
+        self.exportAttributes(outfile, level, namespace_,
+                              name_='docTocItemType')
         outfile.write('>')
         self.exportChildren(outfile, level + 1, namespace_, name_)
         outfile.write('</%s%s>\n' % (namespace_, name_))
+
     def exportAttributes(self, outfile, level, namespace_='', name_='docTocItemType'):
         if self.id is not None:
-            outfile.write(' id=%s' % (self.format_string(quote_attrib(self.id).encode(ExternalEncoding), input_name='id'), ))
+            outfile.write(' id=%s' % (self.format_string(quote_attrib(
+                self.id).encode(ExternalEncoding), input_name='id'), ))
+
     def exportChildren(self, outfile, level, namespace_='', name_='docTocItemType'):
-        if self.valueOf_.find('![CDATA')>-1:
-            value=quote_xml('%s' % self.valueOf_)
-            value=value.replace('![CDATA','<![CDATA')
-            value=value.replace(']]',']]>')
+        if self.valueOf_.find('![CDATA') > -1:
+            value = quote_xml('%s' % self.valueOf_)
+            value = value.replace('![CDATA', '<![CDATA')
+            value = value.replace(']]', ']]>')
             outfile.write(value)
         else:
             outfile.write(quote_xml('%s' % self.valueOf_))
+
     def hasContent_(self):
         if (
             self.valueOf_ is not None
-            ):
+        ):
             return True
         else:
             return False
+
     def exportLiteral(self, outfile, level, name_='docTocItemType'):
         level += 1
         self.exportLiteralAttributes(outfile, level, name_)
         if self.hasContent_():
             self.exportLiteralChildren(outfile, level, name_)
+
     def exportLiteralAttributes(self, outfile, level, name_):
         if self.id is not None:
             showIndent(outfile, level)
             outfile.write('id = %s,\n' % (self.id,))
+
     def exportLiteralChildren(self, outfile, level, name_):
         showIndent(outfile, level)
         outfile.write('valueOf_ = "%s",\n' % (self.valueOf_,))
+
     def build(self, node_):
         attrs = node_.attributes
         self.buildAttributes(attrs)
@@ -7388,29 +8420,33 @@ class docTocItemType(GeneratedsSuper):
         for child_ in node_.childNodes:
             nodeName_ = child_.nodeName.split(':')[-1]
             self.buildChildren(child_, nodeName_)
+
     def buildAttributes(self, attrs):
         if attrs.get('id'):
             self.id = attrs.get('id').value
+
     def buildChildren(self, child_, nodeName_):
         if child_.nodeType == Node.TEXT_NODE:
             obj_ = self.mixedclass_(MixedContainer.CategoryText,
-                MixedContainer.TypeNone, '', child_.nodeValue)
+                                    MixedContainer.TypeNone, '', child_.nodeValue)
             self.content_.append(obj_)
         if child_.nodeType == Node.TEXT_NODE:
             self.valueOf_ += child_.nodeValue
         elif child_.nodeType == Node.CDATA_SECTION_NODE:
-            self.valueOf_ += '![CDATA['+child_.nodeValue+']]'
+            self.valueOf_ += '![CDATA[' + child_.nodeValue + ']]'
 # end class docTocItemType
 
 
 class docTocListType(GeneratedsSuper):
     subclass = None
     superclass = None
+
     def __init__(self, tocitem=None):
         if tocitem is None:
             self.tocitem = []
         else:
             self.tocitem = tocitem
+
     def factory(*args_, **kwargs_):
         if docTocListType.subclass:
             return docTocListType.subclass(*args_, **kwargs_)
@@ -7421,10 +8457,12 @@ class docTocListType(GeneratedsSuper):
     def set_tocitem(self, tocitem): self.tocitem = tocitem
     def add_tocitem(self, value): self.tocitem.append(value)
     def insert_tocitem(self, index, value): self.tocitem[index] = value
+
     def export(self, outfile, level, namespace_='', name_='docTocListType', namespacedef_=''):
         showIndent(outfile, level)
         outfile.write('<%s%s %s' % (namespace_, name_, namespacedef_, ))
-        self.exportAttributes(outfile, level, namespace_, name_='docTocListType')
+        self.exportAttributes(outfile, level, namespace_,
+                              name_='docTocListType')
         if self.hasContent_():
             outfile.write('>\n')
             self.exportChildren(outfile, level + 1, namespace_, name_)
@@ -7432,25 +8470,31 @@ class docTocListType(GeneratedsSuper):
             outfile.write('</%s%s>\n' % (namespace_, name_))
         else:
             outfile.write(' />\n')
+
     def exportAttributes(self, outfile, level, namespace_='', name_='docTocListType'):
         pass
+
     def exportChildren(self, outfile, level, namespace_='', name_='docTocListType'):
         for tocitem_ in self.tocitem:
             tocitem_.export(outfile, level, namespace_, name_='tocitem')
+
     def hasContent_(self):
         if (
             self.tocitem is not None
-            ):
+        ):
             return True
         else:
             return False
+
     def exportLiteral(self, outfile, level, name_='docTocListType'):
         level += 1
         self.exportLiteralAttributes(outfile, level, name_)
         if self.hasContent_():
             self.exportLiteralChildren(outfile, level, name_)
+
     def exportLiteralAttributes(self, outfile, level, name_):
         pass
+
     def exportLiteralChildren(self, outfile, level, name_):
         showIndent(outfile, level)
         outfile.write('tocitem=[\n')
@@ -7464,17 +8508,20 @@ class docTocListType(GeneratedsSuper):
         level -= 1
         showIndent(outfile, level)
         outfile.write('],\n')
+
     def build(self, node_):
         attrs = node_.attributes
         self.buildAttributes(attrs)
         for child_ in node_.childNodes:
             nodeName_ = child_.nodeName.split(':')[-1]
             self.buildChildren(child_, nodeName_)
+
     def buildAttributes(self, attrs):
         pass
+
     def buildChildren(self, child_, nodeName_):
         if child_.nodeType == Node.ELEMENT_NODE and \
-            nodeName_ == 'tocitem':
+                nodeName_ == 'tocitem':
             obj_ = docTocItemType.factory()
             obj_.build(child_)
             self.tocitem.append(obj_)
@@ -7484,12 +8531,14 @@ class docTocListType(GeneratedsSuper):
 class docLanguageType(GeneratedsSuper):
     subclass = None
     superclass = None
+
     def __init__(self, langid=None, para=None):
         self.langid = langid
         if para is None:
             self.para = []
         else:
             self.para = para
+
     def factory(*args_, **kwargs_):
         if docLanguageType.subclass:
             return docLanguageType.subclass(*args_, **kwargs_)
@@ -7502,10 +8551,12 @@ class docLanguageType(GeneratedsSuper):
     def insert_para(self, index, value): self.para[index] = value
     def get_langid(self): return self.langid
     def set_langid(self, langid): self.langid = langid
+
     def export(self, outfile, level, namespace_='', name_='docLanguageType', namespacedef_=''):
         showIndent(outfile, level)
         outfile.write('<%s%s %s' % (namespace_, name_, namespacedef_, ))
-        self.exportAttributes(outfile, level, namespace_, name_='docLanguageType')
+        self.exportAttributes(outfile, level, namespace_,
+                              name_='docLanguageType')
         if self.hasContent_():
             outfile.write('>\n')
             self.exportChildren(outfile, level + 1, namespace_, name_)
@@ -7513,28 +8564,35 @@ class docLanguageType(GeneratedsSuper):
             outfile.write('</%s%s>\n' % (namespace_, name_))
         else:
             outfile.write(' />\n')
+
     def exportAttributes(self, outfile, level, namespace_='', name_='docLanguageType'):
         if self.langid is not None:
-            outfile.write(' langid=%s' % (self.format_string(quote_attrib(self.langid).encode(ExternalEncoding), input_name='langid'), ))
+            outfile.write(' langid=%s' % (self.format_string(quote_attrib(
+                self.langid).encode(ExternalEncoding), input_name='langid'), ))
+
     def exportChildren(self, outfile, level, namespace_='', name_='docLanguageType'):
         for para_ in self.para:
             para_.export(outfile, level, namespace_, name_='para')
+
     def hasContent_(self):
         if (
             self.para is not None
-            ):
+        ):
             return True
         else:
             return False
+
     def exportLiteral(self, outfile, level, name_='docLanguageType'):
         level += 1
         self.exportLiteralAttributes(outfile, level, name_)
         if self.hasContent_():
             self.exportLiteralChildren(outfile, level, name_)
+
     def exportLiteralAttributes(self, outfile, level, name_):
         if self.langid is not None:
             showIndent(outfile, level)
             outfile.write('langid = %s,\n' % (self.langid,))
+
     def exportLiteralChildren(self, outfile, level, name_):
         showIndent(outfile, level)
         outfile.write('para=[\n')
@@ -7548,18 +8606,21 @@ class docLanguageType(GeneratedsSuper):
         level -= 1
         showIndent(outfile, level)
         outfile.write('],\n')
+
     def build(self, node_):
         attrs = node_.attributes
         self.buildAttributes(attrs)
         for child_ in node_.childNodes:
             nodeName_ = child_.nodeName.split(':')[-1]
             self.buildChildren(child_, nodeName_)
+
     def buildAttributes(self, attrs):
         if attrs.get('langid'):
             self.langid = attrs.get('langid').value
+
     def buildChildren(self, child_, nodeName_):
         if child_.nodeType == Node.ELEMENT_NODE and \
-            nodeName_ == 'para':
+                nodeName_ == 'para':
             obj_ = docParaType.factory()
             obj_.build(child_)
             self.para.append(obj_)
@@ -7569,12 +8630,14 @@ class docLanguageType(GeneratedsSuper):
 class docParamListType(GeneratedsSuper):
     subclass = None
     superclass = None
+
     def __init__(self, kind=None, parameteritem=None):
         self.kind = kind
         if parameteritem is None:
             self.parameteritem = []
         else:
             self.parameteritem = parameteritem
+
     def factory(*args_, **kwargs_):
         if docParamListType.subclass:
             return docParamListType.subclass(*args_, **kwargs_)
@@ -7582,15 +8645,21 @@ class docParamListType(GeneratedsSuper):
             return docParamListType(*args_, **kwargs_)
     factory = staticmethod(factory)
     def get_parameteritem(self): return self.parameteritem
-    def set_parameteritem(self, parameteritem): self.parameteritem = parameteritem
+    def set_parameteritem(
+        self, parameteritem): self.parameteritem = parameteritem
+
     def add_parameteritem(self, value): self.parameteritem.append(value)
-    def insert_parameteritem(self, index, value): self.parameteritem[index] = value
+    def insert_parameteritem(
+        self, index, value): self.parameteritem[index] = value
+
     def get_kind(self): return self.kind
     def set_kind(self, kind): self.kind = kind
+
     def export(self, outfile, level, namespace_='', name_='docParamListType', namespacedef_=''):
         showIndent(outfile, level)
         outfile.write('<%s%s %s' % (namespace_, name_, namespacedef_, ))
-        self.exportAttributes(outfile, level, namespace_, name_='docParamListType')
+        self.exportAttributes(outfile, level, namespace_,
+                              name_='docParamListType')
         if self.hasContent_():
             outfile.write('>\n')
             self.exportChildren(outfile, level + 1, namespace_, name_)
@@ -7598,28 +8667,35 @@ class docParamListType(GeneratedsSuper):
             outfile.write('</%s%s>\n' % (namespace_, name_))
         else:
             outfile.write(' />\n')
+
     def exportAttributes(self, outfile, level, namespace_='', name_='docParamListType'):
         if self.kind is not None:
             outfile.write(' kind=%s' % (quote_attrib(self.kind), ))
+
     def exportChildren(self, outfile, level, namespace_='', name_='docParamListType'):
         for parameteritem_ in self.parameteritem:
-            parameteritem_.export(outfile, level, namespace_, name_='parameteritem')
+            parameteritem_.export(
+                outfile, level, namespace_, name_='parameteritem')
+
     def hasContent_(self):
         if (
             self.parameteritem is not None
-            ):
+        ):
             return True
         else:
             return False
+
     def exportLiteral(self, outfile, level, name_='docParamListType'):
         level += 1
         self.exportLiteralAttributes(outfile, level, name_)
         if self.hasContent_():
             self.exportLiteralChildren(outfile, level, name_)
+
     def exportLiteralAttributes(self, outfile, level, name_):
         if self.kind is not None:
             showIndent(outfile, level)
             outfile.write('kind = "%s",\n' % (self.kind,))
+
     def exportLiteralChildren(self, outfile, level, name_):
         showIndent(outfile, level)
         outfile.write('parameteritem=[\n')
@@ -7633,18 +8709,21 @@ class docParamListType(GeneratedsSuper):
         level -= 1
         showIndent(outfile, level)
         outfile.write('],\n')
+
     def build(self, node_):
         attrs = node_.attributes
         self.buildAttributes(attrs)
         for child_ in node_.childNodes:
             nodeName_ = child_.nodeName.split(':')[-1]
             self.buildChildren(child_, nodeName_)
+
     def buildAttributes(self, attrs):
         if attrs.get('kind'):
             self.kind = attrs.get('kind').value
+
     def buildChildren(self, child_, nodeName_):
         if child_.nodeType == Node.ELEMENT_NODE and \
-            nodeName_ == 'parameteritem':
+                nodeName_ == 'parameteritem':
             obj_ = docParamListItem.factory()
             obj_.build(child_)
             self.parameteritem.append(obj_)
@@ -7654,12 +8733,14 @@ class docParamListType(GeneratedsSuper):
 class docParamListItem(GeneratedsSuper):
     subclass = None
     superclass = None
+
     def __init__(self, parameternamelist=None, parameterdescription=None):
         if parameternamelist is None:
             self.parameternamelist = []
         else:
             self.parameternamelist = parameternamelist
         self.parameterdescription = parameterdescription
+
     def factory(*args_, **kwargs_):
         if docParamListItem.subclass:
             return docParamListItem.subclass(*args_, **kwargs_)
@@ -7667,15 +8748,25 @@ class docParamListItem(GeneratedsSuper):
             return docParamListItem(*args_, **kwargs_)
     factory = staticmethod(factory)
     def get_parameternamelist(self): return self.parameternamelist
-    def set_parameternamelist(self, parameternamelist): self.parameternamelist = parameternamelist
-    def add_parameternamelist(self, value): self.parameternamelist.append(value)
-    def insert_parameternamelist(self, index, value): self.parameternamelist[index] = value
+
+    def set_parameternamelist(
+        self, parameternamelist): self.parameternamelist = parameternamelist
+
+    def add_parameternamelist(
+        self, value): self.parameternamelist.append(value)
+    def insert_parameternamelist(
+        self, index, value): self.parameternamelist[index] = value
+
     def get_parameterdescription(self): return self.parameterdescription
-    def set_parameterdescription(self, parameterdescription): self.parameterdescription = parameterdescription
+
+    def set_parameterdescription(
+        self, parameterdescription): self.parameterdescription = parameterdescription
+
     def export(self, outfile, level, namespace_='', name_='docParamListItem', namespacedef_=''):
         showIndent(outfile, level)
         outfile.write('<%s%s %s' % (namespace_, name_, namespacedef_, ))
-        self.exportAttributes(outfile, level, namespace_, name_='docParamListItem')
+        self.exportAttributes(outfile, level, namespace_,
+                              name_='docParamListItem')
         if self.hasContent_():
             outfile.write('>\n')
             self.exportChildren(outfile, level + 1, namespace_, name_)
@@ -7683,28 +8774,36 @@ class docParamListItem(GeneratedsSuper):
             outfile.write('</%s%s>\n' % (namespace_, name_))
         else:
             outfile.write(' />\n')
+
     def exportAttributes(self, outfile, level, namespace_='', name_='docParamListItem'):
         pass
+
     def exportChildren(self, outfile, level, namespace_='', name_='docParamListItem'):
         for parameternamelist_ in self.parameternamelist:
-            parameternamelist_.export(outfile, level, namespace_, name_='parameternamelist')
+            parameternamelist_.export(
+                outfile, level, namespace_, name_='parameternamelist')
         if self.parameterdescription:
-            self.parameterdescription.export(outfile, level, namespace_, name_='parameterdescription', )
+            self.parameterdescription.export(
+                outfile, level, namespace_, name_='parameterdescription', )
+
     def hasContent_(self):
         if (
             self.parameternamelist is not None or
             self.parameterdescription is not None
-            ):
+        ):
             return True
         else:
             return False
+
     def exportLiteral(self, outfile, level, name_='docParamListItem'):
         level += 1
         self.exportLiteralAttributes(outfile, level, name_)
         if self.hasContent_():
             self.exportLiteralChildren(outfile, level, name_)
+
     def exportLiteralAttributes(self, outfile, level, name_):
         pass
+
     def exportLiteralChildren(self, outfile, level, name_):
         showIndent(outfile, level)
         outfile.write('parameternamelist=[\n')
@@ -7712,7 +8811,8 @@ class docParamListItem(GeneratedsSuper):
         for parameternamelist in self.parameternamelist:
             showIndent(outfile, level)
             outfile.write('model_.parameternamelist(\n')
-            parameternamelist.exportLiteral(outfile, level, name_='parameternamelist')
+            parameternamelist.exportLiteral(
+                outfile, level, name_='parameternamelist')
             showIndent(outfile, level)
             outfile.write('),\n')
         level -= 1
@@ -7721,25 +8821,29 @@ class docParamListItem(GeneratedsSuper):
         if self.parameterdescription:
             showIndent(outfile, level)
             outfile.write('parameterdescription=model_.descriptionType(\n')
-            self.parameterdescription.exportLiteral(outfile, level, name_='parameterdescription')
+            self.parameterdescription.exportLiteral(
+                outfile, level, name_='parameterdescription')
             showIndent(outfile, level)
             outfile.write('),\n')
+
     def build(self, node_):
         attrs = node_.attributes
         self.buildAttributes(attrs)
         for child_ in node_.childNodes:
             nodeName_ = child_.nodeName.split(':')[-1]
             self.buildChildren(child_, nodeName_)
+
     def buildAttributes(self, attrs):
         pass
+
     def buildChildren(self, child_, nodeName_):
         if child_.nodeType == Node.ELEMENT_NODE and \
-            nodeName_ == 'parameternamelist':
+                nodeName_ == 'parameternamelist':
             obj_ = docParamNameList.factory()
             obj_.build(child_)
             self.parameternamelist.append(obj_)
         elif child_.nodeType == Node.ELEMENT_NODE and \
-            nodeName_ == 'parameterdescription':
+                nodeName_ == 'parameterdescription':
             obj_ = descriptionType.factory()
             obj_.build(child_)
             self.set_parameterdescription(obj_)
@@ -7749,11 +8853,13 @@ class docParamListItem(GeneratedsSuper):
 class docParamNameList(GeneratedsSuper):
     subclass = None
     superclass = None
+
     def __init__(self, parametername=None):
         if parametername is None:
             self.parametername = []
         else:
             self.parametername = parametername
+
     def factory(*args_, **kwargs_):
         if docParamNameList.subclass:
             return docParamNameList.subclass(*args_, **kwargs_)
@@ -7761,13 +8867,19 @@ class docParamNameList(GeneratedsSuper):
             return docParamNameList(*args_, **kwargs_)
     factory = staticmethod(factory)
     def get_parametername(self): return self.parametername
-    def set_parametername(self, parametername): self.parametername = parametername
+    def set_parametername(
+        self, parametername): self.parametername = parametername
+
     def add_parametername(self, value): self.parametername.append(value)
-    def insert_parametername(self, index, value): self.parametername[index] = value
+
+    def insert_parametername(
+        self, index, value): self.parametername[index] = value
+
     def export(self, outfile, level, namespace_='', name_='docParamNameList', namespacedef_=''):
         showIndent(outfile, level)
         outfile.write('<%s%s %s' % (namespace_, name_, namespacedef_, ))
-        self.exportAttributes(outfile, level, namespace_, name_='docParamNameList')
+        self.exportAttributes(outfile, level, namespace_,
+                              name_='docParamNameList')
         if self.hasContent_():
             outfile.write('>\n')
             self.exportChildren(outfile, level + 1, namespace_, name_)
@@ -7775,25 +8887,32 @@ class docParamNameList(GeneratedsSuper):
             outfile.write('</%s%s>\n' % (namespace_, name_))
         else:
             outfile.write(' />\n')
+
     def exportAttributes(self, outfile, level, namespace_='', name_='docParamNameList'):
         pass
+
     def exportChildren(self, outfile, level, namespace_='', name_='docParamNameList'):
         for parametername_ in self.parametername:
-            parametername_.export(outfile, level, namespace_, name_='parametername')
+            parametername_.export(
+                outfile, level, namespace_, name_='parametername')
+
     def hasContent_(self):
         if (
             self.parametername is not None
-            ):
+        ):
             return True
         else:
             return False
+
     def exportLiteral(self, outfile, level, name_='docParamNameList'):
         level += 1
         self.exportLiteralAttributes(outfile, level, name_)
         if self.hasContent_():
             self.exportLiteralChildren(outfile, level, name_)
+
     def exportLiteralAttributes(self, outfile, level, name_):
         pass
+
     def exportLiteralChildren(self, outfile, level, name_):
         showIndent(outfile, level)
         outfile.write('parametername=[\n')
@@ -7807,17 +8926,20 @@ class docParamNameList(GeneratedsSuper):
         level -= 1
         showIndent(outfile, level)
         outfile.write('],\n')
+
     def build(self, node_):
         attrs = node_.attributes
         self.buildAttributes(attrs)
         for child_ in node_.childNodes:
             nodeName_ = child_.nodeName.split(':')[-1]
             self.buildChildren(child_, nodeName_)
+
     def buildAttributes(self, attrs):
         pass
+
     def buildChildren(self, child_, nodeName_):
         if child_.nodeType == Node.ELEMENT_NODE and \
-            nodeName_ == 'parametername':
+                nodeName_ == 'parametername':
             obj_ = docParamName.factory()
             obj_.build(child_)
             self.parametername.append(obj_)
@@ -7827,6 +8949,7 @@ class docParamNameList(GeneratedsSuper):
 class docParamName(GeneratedsSuper):
     subclass = None
     superclass = None
+
     def __init__(self, direction=None, ref=None, mixedclass_=None, content_=None):
         self.direction = direction
         if mixedclass_ is None:
@@ -7837,6 +8960,7 @@ class docParamName(GeneratedsSuper):
             self.content_ = []
         else:
             self.content_ = content_
+
     def factory(*args_, **kwargs_):
         if docParamName.subclass:
             return docParamName.subclass(*args_, **kwargs_)
@@ -7847,6 +8971,7 @@ class docParamName(GeneratedsSuper):
     def set_ref(self, ref): self.ref = ref
     def get_direction(self): return self.direction
     def set_direction(self, direction): self.direction = direction
+
     def export(self, outfile, level, namespace_='', name_='docParamName', namespacedef_=''):
         showIndent(outfile, level)
         outfile.write('<%s%s %s' % (namespace_, name_, namespacedef_, ))
@@ -7854,28 +8979,34 @@ class docParamName(GeneratedsSuper):
         outfile.write('>')
         self.exportChildren(outfile, level + 1, namespace_, name_)
         outfile.write('</%s%s>\n' % (namespace_, name_))
+
     def exportAttributes(self, outfile, level, namespace_='', name_='docParamName'):
         if self.direction is not None:
             outfile.write(' direction=%s' % (quote_attrib(self.direction), ))
+
     def exportChildren(self, outfile, level, namespace_='', name_='docParamName'):
         for item_ in self.content_:
             item_.export(outfile, level, item_.name, namespace_)
+
     def hasContent_(self):
         if (
             self.ref is not None
-            ):
+        ):
             return True
         else:
             return False
+
     def exportLiteral(self, outfile, level, name_='docParamName'):
         level += 1
         self.exportLiteralAttributes(outfile, level, name_)
         if self.hasContent_():
             self.exportLiteralChildren(outfile, level, name_)
+
     def exportLiteralAttributes(self, outfile, level, name_):
         if self.direction is not None:
             showIndent(outfile, level)
             outfile.write('direction = "%s",\n' % (self.direction,))
+
     def exportLiteralChildren(self, outfile, level, name_):
         showIndent(outfile, level)
         outfile.write('content_ = [\n')
@@ -7883,26 +9014,29 @@ class docParamName(GeneratedsSuper):
             item_.exportLiteral(outfile, level, name_)
         showIndent(outfile, level)
         outfile.write('],\n')
+
     def build(self, node_):
         attrs = node_.attributes
         self.buildAttributes(attrs)
         for child_ in node_.childNodes:
             nodeName_ = child_.nodeName.split(':')[-1]
             self.buildChildren(child_, nodeName_)
+
     def buildAttributes(self, attrs):
         if attrs.get('direction'):
             self.direction = attrs.get('direction').value
+
     def buildChildren(self, child_, nodeName_):
         if child_.nodeType == Node.ELEMENT_NODE and \
-            nodeName_ == 'ref':
+                nodeName_ == 'ref':
             childobj_ = docRefTextType.factory()
             childobj_.build(child_)
             obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
-                MixedContainer.TypeNone, 'ref', childobj_)
+                                    MixedContainer.TypeNone, 'ref', childobj_)
             self.content_.append(obj_)
         elif child_.nodeType == Node.TEXT_NODE:
             obj_ = self.mixedclass_(MixedContainer.CategoryText,
-                MixedContainer.TypeNone, '', child_.nodeValue)
+                                    MixedContainer.TypeNone, '', child_.nodeValue)
             self.content_.append(obj_)
 # end class docParamName
 
@@ -7910,6 +9044,7 @@ class docParamName(GeneratedsSuper):
 class docXRefSectType(GeneratedsSuper):
     subclass = None
     superclass = None
+
     def __init__(self, id=None, xreftitle=None, xrefdescription=None):
         self.id = id
         if xreftitle is None:
@@ -7917,6 +9052,7 @@ class docXRefSectType(GeneratedsSuper):
         else:
             self.xreftitle = xreftitle
         self.xrefdescription = xrefdescription
+
     def factory(*args_, **kwargs_):
         if docXRefSectType.subclass:
             return docXRefSectType.subclass(*args_, **kwargs_)
@@ -7928,13 +9064,17 @@ class docXRefSectType(GeneratedsSuper):
     def add_xreftitle(self, value): self.xreftitle.append(value)
     def insert_xreftitle(self, index, value): self.xreftitle[index] = value
     def get_xrefdescription(self): return self.xrefdescription
-    def set_xrefdescription(self, xrefdescription): self.xrefdescription = xrefdescription
+    def set_xrefdescription(
+        self, xrefdescription): self.xrefdescription = xrefdescription
+
     def get_id(self): return self.id
     def set_id(self, id): self.id = id
+
     def export(self, outfile, level, namespace_='', name_='docXRefSectType', namespacedef_=''):
         showIndent(outfile, level)
         outfile.write('<%s%s %s' % (namespace_, name_, namespacedef_, ))
-        self.exportAttributes(outfile, level, namespace_, name_='docXRefSectType')
+        self.exportAttributes(outfile, level, namespace_,
+                              name_='docXRefSectType')
         if self.hasContent_():
             outfile.write('>\n')
             self.exportChildren(outfile, level + 1, namespace_, name_)
@@ -7942,66 +9082,80 @@ class docXRefSectType(GeneratedsSuper):
             outfile.write('</%s%s>\n' % (namespace_, name_))
         else:
             outfile.write(' />\n')
+
     def exportAttributes(self, outfile, level, namespace_='', name_='docXRefSectType'):
         if self.id is not None:
-            outfile.write(' id=%s' % (self.format_string(quote_attrib(self.id).encode(ExternalEncoding), input_name='id'), ))
+            outfile.write(' id=%s' % (self.format_string(quote_attrib(
+                self.id).encode(ExternalEncoding), input_name='id'), ))
+
     def exportChildren(self, outfile, level, namespace_='', name_='docXRefSectType'):
         for xreftitle_ in self.xreftitle:
             showIndent(outfile, level)
-            outfile.write('<%sxreftitle>%s</%sxreftitle>\n' % (namespace_, self.format_string(quote_xml(xreftitle_).encode(ExternalEncoding), input_name='xreftitle'), namespace_))
+            outfile.write('<%sxreftitle>%s</%sxreftitle>\n' % (namespace_, self.format_string(
+                quote_xml(xreftitle_).encode(ExternalEncoding), input_name='xreftitle'), namespace_))
         if self.xrefdescription:
-            self.xrefdescription.export(outfile, level, namespace_, name_='xrefdescription', )
+            self.xrefdescription.export(
+                outfile, level, namespace_, name_='xrefdescription', )
+
     def hasContent_(self):
         if (
             self.xreftitle is not None or
             self.xrefdescription is not None
-            ):
+        ):
             return True
         else:
             return False
+
     def exportLiteral(self, outfile, level, name_='docXRefSectType'):
         level += 1
         self.exportLiteralAttributes(outfile, level, name_)
         if self.hasContent_():
             self.exportLiteralChildren(outfile, level, name_)
+
     def exportLiteralAttributes(self, outfile, level, name_):
         if self.id is not None:
             showIndent(outfile, level)
             outfile.write('id = %s,\n' % (self.id,))
+
     def exportLiteralChildren(self, outfile, level, name_):
         showIndent(outfile, level)
         outfile.write('xreftitle=[\n')
         level += 1
         for xreftitle in self.xreftitle:
             showIndent(outfile, level)
-            outfile.write('%s,\n' % quote_python(xreftitle).encode(ExternalEncoding))
+            outfile.write('%s,\n' % quote_python(
+                xreftitle).encode(ExternalEncoding))
         level -= 1
         showIndent(outfile, level)
         outfile.write('],\n')
         if self.xrefdescription:
             showIndent(outfile, level)
             outfile.write('xrefdescription=model_.descriptionType(\n')
-            self.xrefdescription.exportLiteral(outfile, level, name_='xrefdescription')
+            self.xrefdescription.exportLiteral(
+                outfile, level, name_='xrefdescription')
             showIndent(outfile, level)
             outfile.write('),\n')
+
     def build(self, node_):
         attrs = node_.attributes
         self.buildAttributes(attrs)
         for child_ in node_.childNodes:
             nodeName_ = child_.nodeName.split(':')[-1]
             self.buildChildren(child_, nodeName_)
+
     def buildAttributes(self, attrs):
         if attrs.get('id'):
             self.id = attrs.get('id').value
+
     def buildChildren(self, child_, nodeName_):
         if child_.nodeType == Node.ELEMENT_NODE and \
-            nodeName_ == 'xreftitle':
+                nodeName_ == 'xreftitle':
             xreftitle_ = ''
             for text__content_ in child_.childNodes:
                 xreftitle_ += text__content_.nodeValue
             self.xreftitle.append(xreftitle_)
         elif child_.nodeType == Node.ELEMENT_NODE and \
-            nodeName_ == 'xrefdescription':
+                nodeName_ == 'xrefdescription':
             obj_ = descriptionType.factory()
             obj_.build(child_)
             self.set_xrefdescription(obj_)
@@ -8011,6 +9165,7 @@ class docXRefSectType(GeneratedsSuper):
 class docCopyType(GeneratedsSuper):
     subclass = None
     superclass = None
+
     def __init__(self, link=None, para=None, sect1=None, internal=None):
         self.link = link
         if para is None:
@@ -8022,6 +9177,7 @@ class docCopyType(GeneratedsSuper):
         else:
             self.sect1 = sect1
         self.internal = internal
+
     def factory(*args_, **kwargs_):
         if docCopyType.subclass:
             return docCopyType.subclass(*args_, **kwargs_)
@@ -8040,6 +9196,7 @@ class docCopyType(GeneratedsSuper):
     def set_internal(self, internal): self.internal = internal
     def get_link(self): return self.link
     def set_link(self, link): self.link = link
+
     def export(self, outfile, level, namespace_='', name_='docCopyType', namespacedef_=''):
         showIndent(outfile, level)
         outfile.write('<%s%s %s' % (namespace_, name_, namespacedef_, ))
@@ -8051,9 +9208,12 @@ class docCopyType(GeneratedsSuper):
             outfile.write('</%s%s>\n' % (namespace_, name_))
         else:
             outfile.write(' />\n')
+
     def exportAttributes(self, outfile, level, namespace_='', name_='docCopyType'):
         if self.link is not None:
-            outfile.write(' link=%s' % (self.format_string(quote_attrib(self.link).encode(ExternalEncoding), input_name='link'), ))
+            outfile.write(' link=%s' % (self.format_string(quote_attrib(
+                self.link).encode(ExternalEncoding), input_name='link'), ))
+
     def exportChildren(self, outfile, level, namespace_='', name_='docCopyType'):
         for para_ in self.para:
             para_.export(outfile, level, namespace_, name_='para')
@@ -8061,24 +9221,28 @@ class docCopyType(GeneratedsSuper):
             sect1_.export(outfile, level, namespace_, name_='sect1')
         if self.internal:
             self.internal.export(outfile, level, namespace_, name_='internal')
+
     def hasContent_(self):
         if (
             self.para is not None or
             self.sect1 is not None or
             self.internal is not None
-            ):
+        ):
             return True
         else:
             return False
+
     def exportLiteral(self, outfile, level, name_='docCopyType'):
         level += 1
         self.exportLiteralAttributes(outfile, level, name_)
         if self.hasContent_():
             self.exportLiteralChildren(outfile, level, name_)
+
     def exportLiteralAttributes(self, outfile, level, name_):
         if self.link is not None:
             showIndent(outfile, level)
             outfile.write('link = %s,\n' % (self.link,))
+
     def exportLiteralChildren(self, outfile, level, name_):
         showIndent(outfile, level)
         outfile.write('para=[\n')
@@ -8110,28 +9274,31 @@ class docCopyType(GeneratedsSuper):
             self.internal.exportLiteral(outfile, level, name_='internal')
             showIndent(outfile, level)
             outfile.write('),\n')
+
     def build(self, node_):
         attrs = node_.attributes
         self.buildAttributes(attrs)
         for child_ in node_.childNodes:
             nodeName_ = child_.nodeName.split(':')[-1]
             self.buildChildren(child_, nodeName_)
+
     def buildAttributes(self, attrs):
         if attrs.get('link'):
             self.link = attrs.get('link').value
+
     def buildChildren(self, child_, nodeName_):
         if child_.nodeType == Node.ELEMENT_NODE and \
-            nodeName_ == 'para':
+                nodeName_ == 'para':
             obj_ = docParaType.factory()
             obj_.build(child_)
             self.para.append(obj_)
         elif child_.nodeType == Node.ELEMENT_NODE and \
-            nodeName_ == 'sect1':
+                nodeName_ == 'sect1':
             obj_ = docSect1Type.factory()
             obj_.build(child_)
             self.sect1.append(obj_)
         elif child_.nodeType == Node.ELEMENT_NODE and \
-            nodeName_ == 'internal':
+                nodeName_ == 'internal':
             obj_ = docInternalType.factory()
             obj_.build(child_)
             self.set_internal(obj_)
@@ -8141,9 +9308,11 @@ class docCopyType(GeneratedsSuper):
 class docCharType(GeneratedsSuper):
     subclass = None
     superclass = None
+
     def __init__(self, char=None, valueOf_=''):
         self.char = char
         self.valueOf_ = valueOf_
+
     def factory(*args_, **kwargs_):
         if docCharType.subclass:
             return docCharType.subclass(*args_, **kwargs_)
@@ -8154,6 +9323,7 @@ class docCharType(GeneratedsSuper):
     def set_char(self, char): self.char = char
     def getValueOf_(self): return self.valueOf_
     def setValueOf_(self, valueOf_): self.valueOf_ = valueOf_
+
     def export(self, outfile, level, namespace_='', name_='docCharType', namespacedef_=''):
         showIndent(outfile, level)
         outfile.write('<%s%s %s' % (namespace_, name_, namespacedef_, ))
@@ -8165,36 +9335,43 @@ class docCharType(GeneratedsSuper):
             outfile.write('</%s%s>\n' % (namespace_, name_))
         else:
             outfile.write(' />\n')
+
     def exportAttributes(self, outfile, level, namespace_='', name_='docCharType'):
         if self.char is not None:
             outfile.write(' char=%s' % (quote_attrib(self.char), ))
+
     def exportChildren(self, outfile, level, namespace_='', name_='docCharType'):
-        if self.valueOf_.find('![CDATA')>-1:
-            value=quote_xml('%s' % self.valueOf_)
-            value=value.replace('![CDATA','<![CDATA')
-            value=value.replace(']]',']]>')
+        if self.valueOf_.find('![CDATA') > -1:
+            value = quote_xml('%s' % self.valueOf_)
+            value = value.replace('![CDATA', '<![CDATA')
+            value = value.replace(']]', ']]>')
             outfile.write(value)
         else:
             outfile.write(quote_xml('%s' % self.valueOf_))
+
     def hasContent_(self):
         if (
             self.valueOf_ is not None
-            ):
+        ):
             return True
         else:
             return False
+
     def exportLiteral(self, outfile, level, name_='docCharType'):
         level += 1
         self.exportLiteralAttributes(outfile, level, name_)
         if self.hasContent_():
             self.exportLiteralChildren(outfile, level, name_)
+
     def exportLiteralAttributes(self, outfile, level, name_):
         if self.char is not None:
             showIndent(outfile, level)
             outfile.write('char = "%s",\n' % (self.char,))
+
     def exportLiteralChildren(self, outfile, level, name_):
         showIndent(outfile, level)
         outfile.write('valueOf_ = "%s",\n' % (self.valueOf_,))
+
     def build(self, node_):
         attrs = node_.attributes
         self.buildAttributes(attrs)
@@ -8202,22 +9379,26 @@ class docCharType(GeneratedsSuper):
         for child_ in node_.childNodes:
             nodeName_ = child_.nodeName.split(':')[-1]
             self.buildChildren(child_, nodeName_)
+
     def buildAttributes(self, attrs):
         if attrs.get('char'):
             self.char = attrs.get('char').value
+
     def buildChildren(self, child_, nodeName_):
         if child_.nodeType == Node.TEXT_NODE:
             self.valueOf_ += child_.nodeValue
         elif child_.nodeType == Node.CDATA_SECTION_NODE:
-            self.valueOf_ += '![CDATA['+child_.nodeValue+']]'
+            self.valueOf_ += '![CDATA[' + child_.nodeValue + ']]'
 # end class docCharType
 
 
 class docEmptyType(GeneratedsSuper):
     subclass = None
     superclass = None
+
     def __init__(self, valueOf_=''):
         self.valueOf_ = valueOf_
+
     def factory(*args_, **kwargs_):
         if docEmptyType.subclass:
             return docEmptyType.subclass(*args_, **kwargs_)
@@ -8226,6 +9407,7 @@ class docEmptyType(GeneratedsSuper):
     factory = staticmethod(factory)
     def getValueOf_(self): return self.valueOf_
     def setValueOf_(self, valueOf_): self.valueOf_ = valueOf_
+
     def export(self, outfile, level, namespace_='', name_='docEmptyType', namespacedef_=''):
         showIndent(outfile, level)
         outfile.write('<%s%s %s' % (namespace_, name_, namespacedef_, ))
@@ -8237,33 +9419,40 @@ class docEmptyType(GeneratedsSuper):
             outfile.write('</%s%s>\n' % (namespace_, name_))
         else:
             outfile.write(' />\n')
+
     def exportAttributes(self, outfile, level, namespace_='', name_='docEmptyType'):
         pass
+
     def exportChildren(self, outfile, level, namespace_='', name_='docEmptyType'):
-        if self.valueOf_.find('![CDATA')>-1:
-            value=quote_xml('%s' % self.valueOf_)
-            value=value.replace('![CDATA','<![CDATA')
-            value=value.replace(']]',']]>')
+        if self.valueOf_.find('![CDATA') > -1:
+            value = quote_xml('%s' % self.valueOf_)
+            value = value.replace('![CDATA', '<![CDATA')
+            value = value.replace(']]', ']]>')
             outfile.write(value)
         else:
             outfile.write(quote_xml('%s' % self.valueOf_))
+
     def hasContent_(self):
         if (
             self.valueOf_ is not None
-            ):
+        ):
             return True
         else:
             return False
+
     def exportLiteral(self, outfile, level, name_='docEmptyType'):
         level += 1
         self.exportLiteralAttributes(outfile, level, name_)
         if self.hasContent_():
             self.exportLiteralChildren(outfile, level, name_)
+
     def exportLiteralAttributes(self, outfile, level, name_):
         pass
+
     def exportLiteralChildren(self, outfile, level, name_):
         showIndent(outfile, level)
         outfile.write('valueOf_ = "%s",\n' % (self.valueOf_,))
+
     def build(self, node_):
         attrs = node_.attributes
         self.buildAttributes(attrs)
@@ -8271,13 +9460,15 @@ class docEmptyType(GeneratedsSuper):
         for child_ in node_.childNodes:
             nodeName_ = child_.nodeName.split(':')[-1]
             self.buildChildren(child_, nodeName_)
+
     def buildAttributes(self, attrs):
         pass
+
     def buildChildren(self, child_, nodeName_):
         if child_.nodeType == Node.TEXT_NODE:
             self.valueOf_ += child_.nodeValue
         elif child_.nodeType == Node.CDATA_SECTION_NODE:
-            self.valueOf_ += '![CDATA['+child_.nodeValue+']]'
+            self.valueOf_ += '![CDATA[' + child_.nodeValue + ']]'
 # end class docEmptyType
 
 
@@ -8287,6 +9478,7 @@ Options:
     -s        Use the SAX parser, not the minidom parser.
 """
 
+
 def usage():
     print(USAGE_TEXT)
     sys.exit(1)
@@ -8301,7 +9493,7 @@ def parse(inFileName):
     doc = None
     sys.stdout.write('<?xml version="1.0" ?>\n')
     rootObj.export(sys.stdout, 0, name_="doxygen",
-        namespacedef_='')
+                   namespacedef_='')
     return rootObj
 
 
@@ -8314,7 +9506,7 @@ def parseString(inString):
     doc = None
     sys.stdout.write('<?xml version="1.0" ?>\n')
     rootObj.export(sys.stdout, 0, name_="doxygen",
-        namespacedef_='')
+                   namespacedef_='')
     return rootObj
 
 
@@ -8343,4 +9535,4 @@ def main():
 if __name__ == '__main__':
     main()
     #import pdb
-    #pdb.run('main()')
+    # pdb.run('main()')
diff --git a/docs/doxygen/doxyxml/generated/index.py b/docs/doxygen/doxyxml/generated/index.py
index 0c63512..7ffbdf1 100644
--- a/docs/doxygen/doxyxml/generated/index.py
+++ b/docs/doxygen/doxyxml/generated/index.py
@@ -3,8 +3,6 @@
 """
 Generated Mon Feb  9 19:08:05 2009 by generateDS.py.
 """
-from __future__ import absolute_import
-from __future__ import unicode_literals
 
 from xml.dom import minidom
 
@@ -14,6 +12,7 @@ from . import compound
 
 from . import indexsuper as supermod
 
+
 class DoxygenTypeSub(supermod.DoxygenType):
     def __init__(self, version=None, compound=None):
         supermod.DoxygenType.__init__(self, version, compound)
@@ -34,6 +33,7 @@ class DoxygenTypeSub(supermod.DoxygenType):
 
         return results
 
+
 supermod.DoxygenType.subclass = DoxygenTypeSub
 # end class DoxygenTypeSub
 
@@ -55,6 +55,7 @@ class CompoundTypeSub(supermod.CompoundType):
 
         return results
 
+
 supermod.CompoundType.subclass = CompoundTypeSub
 # end class CompoundTypeSub
 
@@ -64,6 +65,7 @@ class MemberTypeSub(supermod.MemberType):
     def __init__(self, kind=None, refid=None, name=''):
         supermod.MemberType.__init__(self, kind, refid, name)
 
+
 supermod.MemberType.subclass = MemberTypeSub
 # end class MemberTypeSub
 
@@ -76,4 +78,3 @@ def parse(inFilename):
     rootObj.build(rootNode)
 
     return rootObj
-
diff --git a/docs/doxygen/doxyxml/generated/indexsuper.py b/docs/doxygen/doxyxml/generated/indexsuper.py
index 11312db..b30e062 100644
--- a/docs/doxygen/doxyxml/generated/indexsuper.py
+++ b/docs/doxygen/doxyxml/generated/indexsuper.py
@@ -4,16 +4,12 @@
 # Generated Thu Jun 11 18:43:54 2009 by generateDS.py.
 #
 
-from __future__ import print_function
-from __future__ import unicode_literals
 
 import sys
 
 from xml.dom import minidom
 from xml.dom import Node
 
-import six
-
 #
 # User methods
 #
@@ -28,12 +24,16 @@ except ImportError as exp:
     class GeneratedsSuper(object):
         def format_string(self, input_data, input_name=''):
             return input_data
+
         def format_integer(self, input_data, input_name=''):
             return '%d' % input_data
+
         def format_float(self, input_data, input_name=''):
             return '%f' % input_data
+
         def format_double(self, input_data, input_name=''):
             return '%e' % input_data
+
         def format_boolean(self, input_data, input_name=''):
             return '%s' % input_data
 
@@ -45,9 +45,9 @@ except ImportError as exp:
 
 ## from IPython.Shell import IPShellEmbed
 ## args = ''
-## ipshell = IPShellEmbed(args,
+# ipshell = IPShellEmbed(args,
 ##     banner = 'Dropping into IPython',
-##     exit_msg = 'Leaving Interpreter, back to program.')
+# exit_msg = 'Leaving Interpreter, back to program.')
 
 # Then use the following line where and when you want to drop into the
 # IPython shell:
@@ -63,20 +63,23 @@ ExternalEncoding = 'ascii'
 # Support/utility functions.
 #
 
+
 def showIndent(outfile, level):
     for idx in range(level):
         outfile.write('    ')
 
+
 def quote_xml(inStr):
-    s1 = (isinstance(inStr, six.string_types) and inStr or
+    s1 = (isinstance(inStr, str) and inStr or
           '%s' % inStr)
     s1 = s1.replace('&', '&amp;')
     s1 = s1.replace('<', '&lt;')
     s1 = s1.replace('>', '&gt;')
     return s1
 
+
 def quote_attrib(inStr):
-    s1 = (isinstance(inStr, six.string_types) and inStr or
+    s1 = (isinstance(inStr, str) and inStr or
           '%s' % inStr)
     s1 = s1.replace('&', '&amp;')
     s1 = s1.replace('<', '&lt;')
@@ -90,6 +93,7 @@ def quote_attrib(inStr):
         s1 = '"%s"' % s1
     return s1
 
+
 def quote_python(inStr):
     s1 = inStr
     if s1.find("'") == -1:
@@ -121,26 +125,33 @@ class MixedContainer(object):
     TypeDecimal = 5
     TypeDouble = 6
     TypeBoolean = 7
+
     def __init__(self, category, content_type, name, value):
         self.category = category
         self.content_type = content_type
         self.name = name
         self.value = value
+
     def getCategory(self):
         return self.category
+
     def getContenttype(self, content_type):
         return self.content_type
+
     def getValue(self):
         return self.value
+
     def getName(self):
         return self.name
+
     def export(self, outfile, level, name, namespace):
         if self.category == MixedContainer.CategoryText:
             outfile.write(self.value)
         elif self.category == MixedContainer.CategorySimple:
             self.exportSimple(outfile, level, name)
         else:    # category == MixedContainer.CategoryComplex
-            self.value.export(outfile, level, namespace,name)
+            self.value.export(outfile, level, namespace, name)
+
     def exportSimple(self, outfile, level, name):
         if self.content_type == MixedContainer.TypeString:
             outfile.write('<%s>%s</%s>' % (self.name, self.value, self.name))
@@ -152,19 +163,20 @@ class MixedContainer(object):
             outfile.write('<%s>%f</%s>' % (self.name, self.value, self.name))
         elif self.content_type == MixedContainer.TypeDouble:
             outfile.write('<%s>%g</%s>' % (self.name, self.value, self.name))
+
     def exportLiteral(self, outfile, level, name):
         if self.category == MixedContainer.CategoryText:
             showIndent(outfile, level)
-            outfile.write('MixedContainer(%d, %d, "%s", "%s"),\n' % \
-                (self.category, self.content_type, self.name, self.value))
+            outfile.write('MixedContainer(%d, %d, "%s", "%s"),\n' %
+                          (self.category, self.content_type, self.name, self.value))
         elif self.category == MixedContainer.CategorySimple:
             showIndent(outfile, level)
-            outfile.write('MixedContainer(%d, %d, "%s", "%s"),\n' % \
-                (self.category, self.content_type, self.name, self.value))
+            outfile.write('MixedContainer(%d, %d, "%s", "%s"),\n' %
+                          (self.category, self.content_type, self.name, self.value))
         else:    # category == MixedContainer.CategoryComplex
             showIndent(outfile, level)
-            outfile.write('MixedContainer(%d, %d, "%s",\n' % \
-                (self.category, self.content_type, self.name,))
+            outfile.write('MixedContainer(%d, %d, "%s",\n' %
+                          (self.category, self.content_type, self.name,))
             self.value.exportLiteral(outfile, level + 1)
             showIndent(outfile, level)
             outfile.write(')\n')
@@ -175,6 +187,7 @@ class _MemberSpec(object):
         self.name = name
         self.data_type = data_type
         self.container = container
+
     def set_name(self, name): self.name = name
     def get_name(self): return self.name
     def set_data_type(self, data_type): self.data_type = data_type
@@ -190,12 +203,14 @@ class _MemberSpec(object):
 class DoxygenType(GeneratedsSuper):
     subclass = None
     superclass = None
+
     def __init__(self, version=None, compound=None):
         self.version = version
         if compound is None:
             self.compound = []
         else:
             self.compound = compound
+
     def factory(*args_, **kwargs_):
         if DoxygenType.subclass:
             return DoxygenType.subclass(*args_, **kwargs_)
@@ -208,6 +223,7 @@ class DoxygenType(GeneratedsSuper):
     def insert_compound(self, index, value): self.compound[index] = value
     def get_version(self): return self.version
     def set_version(self, version): self.version = version
+
     def export(self, outfile, level, namespace_='', name_='DoxygenType', namespacedef_=''):
         showIndent(outfile, level)
         outfile.write('<%s%s %s' % (namespace_, name_, namespacedef_, ))
@@ -219,27 +235,34 @@ class DoxygenType(GeneratedsSuper):
             outfile.write('</%s%s>\n' % (namespace_, name_))
         else:
             outfile.write(' />\n')
+
     def exportAttributes(self, outfile, level, namespace_='', name_='DoxygenType'):
-        outfile.write(' version=%s' % (self.format_string(quote_attrib(self.version).encode(ExternalEncoding), input_name='version'), ))
+        outfile.write(' version=%s' % (self.format_string(quote_attrib(
+            self.version).encode(ExternalEncoding), input_name='version'), ))
+
     def exportChildren(self, outfile, level, namespace_='', name_='DoxygenType'):
         for compound_ in self.compound:
             compound_.export(outfile, level, namespace_, name_='compound')
+
     def hasContent_(self):
         if (
             self.compound is not None
-            ):
+        ):
             return True
         else:
             return False
+
     def exportLiteral(self, outfile, level, name_='DoxygenType'):
         level += 1
         self.exportLiteralAttributes(outfile, level, name_)
         if self.hasContent_():
             self.exportLiteralChildren(outfile, level, name_)
+
     def exportLiteralAttributes(self, outfile, level, name_):
         if self.version is not None:
             showIndent(outfile, level)
             outfile.write('version = %s,\n' % (self.version,))
+
     def exportLiteralChildren(self, outfile, level, name_):
         showIndent(outfile, level)
         outfile.write('compound=[\n')
@@ -253,18 +276,21 @@ class DoxygenType(GeneratedsSuper):
         level -= 1
         showIndent(outfile, level)
         outfile.write('],\n')
+
     def build(self, node_):
         attrs = node_.attributes
         self.buildAttributes(attrs)
         for child_ in node_.childNodes:
             nodeName_ = child_.nodeName.split(':')[-1]
             self.buildChildren(child_, nodeName_)
+
     def buildAttributes(self, attrs):
         if attrs.get('version'):
             self.version = attrs.get('version').value
+
     def buildChildren(self, child_, nodeName_):
         if child_.nodeType == Node.ELEMENT_NODE and \
-            nodeName_ == 'compound':
+                nodeName_ == 'compound':
             obj_ = CompoundType.factory()
             obj_.build(child_)
             self.compound.append(obj_)
@@ -274,6 +300,7 @@ class DoxygenType(GeneratedsSuper):
 class CompoundType(GeneratedsSuper):
     subclass = None
     superclass = None
+
     def __init__(self, kind=None, refid=None, name=None, member=None):
         self.kind = kind
         self.refid = refid
@@ -282,6 +309,7 @@ class CompoundType(GeneratedsSuper):
             self.member = []
         else:
             self.member = member
+
     def factory(*args_, **kwargs_):
         if CompoundType.subclass:
             return CompoundType.subclass(*args_, **kwargs_)
@@ -298,6 +326,7 @@ class CompoundType(GeneratedsSuper):
     def set_kind(self, kind): self.kind = kind
     def get_refid(self): return self.refid
     def set_refid(self, refid): self.refid = refid
+
     def export(self, outfile, level, namespace_='', name_='CompoundType', namespacedef_=''):
         showIndent(outfile, level)
         outfile.write('<%s%s %s' % (namespace_, name_, namespacedef_, ))
@@ -309,28 +338,35 @@ class CompoundType(GeneratedsSuper):
             outfile.write('</%s%s>\n' % (namespace_, name_))
         else:
             outfile.write(' />\n')
+
     def exportAttributes(self, outfile, level, namespace_='', name_='CompoundType'):
         outfile.write(' kind=%s' % (quote_attrib(self.kind), ))
-        outfile.write(' refid=%s' % (self.format_string(quote_attrib(self.refid).encode(ExternalEncoding), input_name='refid'), ))
+        outfile.write(' refid=%s' % (self.format_string(quote_attrib(
+            self.refid).encode(ExternalEncoding), input_name='refid'), ))
+
     def exportChildren(self, outfile, level, namespace_='', name_='CompoundType'):
         if self.name is not None:
             showIndent(outfile, level)
-            outfile.write('<%sname>%s</%sname>\n' % (namespace_, self.format_string(quote_xml(self.name).encode(ExternalEncoding), input_name='name'), namespace_))
+            outfile.write('<%sname>%s</%sname>\n' % (namespace_, self.format_string(
+                quote_xml(self.name).encode(ExternalEncoding), input_name='name'), namespace_))
         for member_ in self.member:
             member_.export(outfile, level, namespace_, name_='member')
+
     def hasContent_(self):
         if (
             self.name is not None or
             self.member is not None
-            ):
+        ):
             return True
         else:
             return False
+
     def exportLiteral(self, outfile, level, name_='CompoundType'):
         level += 1
         self.exportLiteralAttributes(outfile, level, name_)
         if self.hasContent_():
             self.exportLiteralChildren(outfile, level, name_)
+
     def exportLiteralAttributes(self, outfile, level, name_):
         if self.kind is not None:
             showIndent(outfile, level)
@@ -338,9 +374,11 @@ class CompoundType(GeneratedsSuper):
         if self.refid is not None:
             showIndent(outfile, level)
             outfile.write('refid = %s,\n' % (self.refid,))
+
     def exportLiteralChildren(self, outfile, level, name_):
         showIndent(outfile, level)
-        outfile.write('name=%s,\n' % quote_python(self.name).encode(ExternalEncoding))
+        outfile.write('name=%s,\n' % quote_python(
+            self.name).encode(ExternalEncoding))
         showIndent(outfile, level)
         outfile.write('member=[\n')
         level += 1
@@ -353,26 +391,29 @@ class CompoundType(GeneratedsSuper):
         level -= 1
         showIndent(outfile, level)
         outfile.write('],\n')
+
     def build(self, node_):
         attrs = node_.attributes
         self.buildAttributes(attrs)
         for child_ in node_.childNodes:
             nodeName_ = child_.nodeName.split(':')[-1]
             self.buildChildren(child_, nodeName_)
+
     def buildAttributes(self, attrs):
         if attrs.get('kind'):
             self.kind = attrs.get('kind').value
         if attrs.get('refid'):
             self.refid = attrs.get('refid').value
+
     def buildChildren(self, child_, nodeName_):
         if child_.nodeType == Node.ELEMENT_NODE and \
-            nodeName_ == 'name':
+                nodeName_ == 'name':
             name_ = ''
             for text__content_ in child_.childNodes:
                 name_ += text__content_.nodeValue
             self.name = name_
         elif child_.nodeType == Node.ELEMENT_NODE and \
-            nodeName_ == 'member':
+                nodeName_ == 'member':
             obj_ = MemberType.factory()
             obj_.build(child_)
             self.member.append(obj_)
@@ -382,10 +423,12 @@ class CompoundType(GeneratedsSuper):
 class MemberType(GeneratedsSuper):
     subclass = None
     superclass = None
+
     def __init__(self, kind=None, refid=None, name=None):
         self.kind = kind
         self.refid = refid
         self.name = name
+
     def factory(*args_, **kwargs_):
         if MemberType.subclass:
             return MemberType.subclass(*args_, **kwargs_)
@@ -398,6 +441,7 @@ class MemberType(GeneratedsSuper):
     def set_kind(self, kind): self.kind = kind
     def get_refid(self): return self.refid
     def set_refid(self, refid): self.refid = refid
+
     def export(self, outfile, level, namespace_='', name_='MemberType', namespacedef_=''):
         showIndent(outfile, level)
         outfile.write('<%s%s %s' % (namespace_, name_, namespacedef_, ))
@@ -409,25 +453,32 @@ class MemberType(GeneratedsSuper):
             outfile.write('</%s%s>\n' % (namespace_, name_))
         else:
             outfile.write(' />\n')
+
     def exportAttributes(self, outfile, level, namespace_='', name_='MemberType'):
         outfile.write(' kind=%s' % (quote_attrib(self.kind), ))
-        outfile.write(' refid=%s' % (self.format_string(quote_attrib(self.refid).encode(ExternalEncoding), input_name='refid'), ))
+        outfile.write(' refid=%s' % (self.format_string(quote_attrib(
+            self.refid).encode(ExternalEncoding), input_name='refid'), ))
+
     def exportChildren(self, outfile, level, namespace_='', name_='MemberType'):
         if self.name is not None:
             showIndent(outfile, level)
-            outfile.write('<%sname>%s</%sname>\n' % (namespace_, self.format_string(quote_xml(self.name).encode(ExternalEncoding), input_name='name'), namespace_))
+            outfile.write('<%sname>%s</%sname>\n' % (namespace_, self.format_string(
+                quote_xml(self.name).encode(ExternalEncoding), input_name='name'), namespace_))
+
     def hasContent_(self):
         if (
             self.name is not None
-            ):
+        ):
             return True
         else:
             return False
+
     def exportLiteral(self, outfile, level, name_='MemberType'):
         level += 1
         self.exportLiteralAttributes(outfile, level, name_)
         if self.hasContent_():
             self.exportLiteralChildren(outfile, level, name_)
+
     def exportLiteralAttributes(self, outfile, level, name_):
         if self.kind is not None:
             showIndent(outfile, level)
@@ -435,23 +486,28 @@ class MemberType(GeneratedsSuper):
         if self.refid is not None:
             showIndent(outfile, level)
             outfile.write('refid = %s,\n' % (self.refid,))
+
     def exportLiteralChildren(self, outfile, level, name_):
         showIndent(outfile, level)
-        outfile.write('name=%s,\n' % quote_python(self.name).encode(ExternalEncoding))
+        outfile.write('name=%s,\n' % quote_python(
+            self.name).encode(ExternalEncoding))
+
     def build(self, node_):
         attrs = node_.attributes
         self.buildAttributes(attrs)
         for child_ in node_.childNodes:
             nodeName_ = child_.nodeName.split(':')[-1]
             self.buildChildren(child_, nodeName_)
+
     def buildAttributes(self, attrs):
         if attrs.get('kind'):
             self.kind = attrs.get('kind').value
         if attrs.get('refid'):
             self.refid = attrs.get('refid').value
+
     def buildChildren(self, child_, nodeName_):
         if child_.nodeType == Node.ELEMENT_NODE and \
-            nodeName_ == 'name':
+                nodeName_ == 'name':
             name_ = ''
             for text__content_ in child_.childNodes:
                 name_ += text__content_.nodeValue
@@ -465,6 +521,7 @@ Options:
     -s        Use the SAX parser, not the minidom parser.
 """
 
+
 def usage():
     print(USAGE_TEXT)
     sys.exit(1)
@@ -479,7 +536,7 @@ def parse(inFileName):
     doc = None
     sys.stdout.write('<?xml version="1.0" ?>\n')
     rootObj.export(sys.stdout, 0, name_="doxygenindex",
-        namespacedef_='')
+                   namespacedef_='')
     return rootObj
 
 
@@ -492,7 +549,7 @@ def parseString(inString):
     doc = None
     sys.stdout.write('<?xml version="1.0" ?>\n')
     rootObj.export(sys.stdout, 0, name_="doxygenindex",
-        namespacedef_='')
+                   namespacedef_='')
     return rootObj
 
 
@@ -518,9 +575,7 @@ def main():
         usage()
 
 
-
-
 if __name__ == '__main__':
     main()
     #import pdb
-    #pdb.run('main()')
+    # pdb.run('main()')
diff --git a/docs/doxygen/doxyxml/text.py b/docs/doxygen/doxyxml/text.py
index 0d00ff8..a766232 100644
--- a/docs/doxygen/doxyxml/text.py
+++ b/docs/doxygen/doxyxml/text.py
@@ -4,25 +4,13 @@
 # This file was generated by gr_modtool, a tool from the GNU Radio framework
 # This file is a part of gr-satellites
 #
-# GNU Radio is free software; you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation; either version 3, or (at your option)
-# any later version.
+# SPDX-License-Identifier: GPL-3.0-or-later
 #
-# GNU Radio is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with GNU Radio; see the file COPYING.  If not, write to
-# the Free Software Foundation, Inc., 51 Franklin Street,
-# Boston, MA 02110-1301, USA.
 #
 """
 Utilities for extracting text from generated classes.
 """
-from __future__ import unicode_literals
+
 
 def is_string(txt):
     if isinstance(txt, str):
@@ -34,11 +22,13 @@ def is_string(txt):
         pass
     return False
 
+
 def description(obj):
     if obj is None:
         return None
     return description_bit(obj).strip()
 
+
 def description_bit(obj):
     if hasattr(obj, 'content'):
         contents = [description_bit(item) for item in obj.content]
@@ -51,7 +41,8 @@ def description_bit(obj):
     elif is_string(obj):
         return obj
     else:
-        raise Exception('Expecting a string or something with content, content_ or value attribute')
+        raise Exception(
+            'Expecting a string or something with content, content_ or value attribute')
     # If this bit is a paragraph then add one some line breaks.
     if hasattr(obj, 'name') and obj.name == 'para':
         result += "\n\n"
diff --git a/docs/doxygen/other/doxypy.py b/docs/doxygen/other/doxypy.py
new file mode 100644
index 0000000..28b1664
--- /dev/null
+++ b/docs/doxygen/other/doxypy.py
@@ -0,0 +1,446 @@
+#!/usr/bin/env python
+
+
+__applicationName__ = "doxypy"
+__blurb__ = """
+doxypy is an input filter for Doxygen. It preprocesses python
+files so that docstrings of classes and functions are reformatted
+into Doxygen-conform documentation blocks.
+"""
+
+__doc__ = __blurb__ + \
+    """
+In order to make Doxygen preprocess files through doxypy, simply
+add the following lines to your Doxyfile:
+    FILTER_SOURCE_FILES = YES
+    INPUT_FILTER = "python /path/to/doxypy.py"
+"""
+
+__version__ = "0.4.2"
+__date__ = "5th December 2008"
+__website__ = "http://code.foosel.org/doxypy"
+
+__author__ = (
+    "Philippe 'demod' Neumann (doxypy at demod dot org)",
+    "Gina 'foosel' Haeussge (gina at foosel dot net)"
+)
+
+__licenseName__ = "GPL v2"
+__license__ = """This program is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 2 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program.  If not, see <http://www.gnu.org/licenses/>.
+"""
+
+import sys
+import re
+
+from argparse import ArgumentParser
+
+
+class FSM(object):
+    """Implements a finite state machine.
+
+    Transitions are given as 4-tuples, consisting of an origin state, a target
+    state, a condition for the transition (given as a reference to a function
+    which gets called with a given piece of input) and a pointer to a function
+    to be called upon the execution of the given transition.
+    """
+
+    """
+    @var transitions holds the transitions
+    @var current_state holds the current state
+    @var current_input holds the current input
+    @var current_transition hold the currently active transition
+    """
+
+    def __init__(self, start_state=None, transitions=[]):
+        self.transitions = transitions
+        self.current_state = start_state
+        self.current_input = None
+        self.current_transition = None
+
+    def setStartState(self, state):
+        self.current_state = state
+
+    def addTransition(self, from_state, to_state, condition, callback):
+        self.transitions.append([from_state, to_state, condition, callback])
+
+    def makeTransition(self, input):
+        """ Makes a transition based on the given input.
+
+        @param    input    input to parse by the FSM
+        """
+        for transition in self.transitions:
+            [from_state, to_state, condition, callback] = transition
+            if from_state == self.current_state:
+                match = condition(input)
+                if match:
+                    self.current_state = to_state
+                    self.current_input = input
+                    self.current_transition = transition
+                    if args.debug:
+                        print("# FSM: executing (%s -> %s) for line '%s'" %
+                              (from_state, to_state, input), file=sys.stderr)
+                    callback(match)
+                    return
+
+
+class Doxypy(object):
+    def __init__(self):
+        string_prefixes = "[uU]?[rR]?"
+
+        self.start_single_comment_re = re.compile(
+            r"^\s*%s(''')" % string_prefixes)
+        self.end_single_comment_re = re.compile(r"(''')\s*$")
+
+        self.start_double_comment_re = re.compile(
+            r'^\s*%s(""")' % string_prefixes)
+        self.end_double_comment_re = re.compile(r'(""")\s*$')
+
+        self.single_comment_re = re.compile(
+            r"^\s*%s(''').*(''')\s*$" % string_prefixes)
+        self.double_comment_re = re.compile(
+            r'^\s*%s(""").*(""")\s*$' % string_prefixes)
+
+        self.defclass_re = re.compile(r"^(\s*)(def .+:|class .+:)")
+        self.empty_re = re.compile(r"^\s*$")
+        self.hashline_re = re.compile(r"^\s*#.*$")
+        self.importline_re = re.compile(r"^\s*(import |from .+ import)")
+
+        self.multiline_defclass_start_re = re.compile(
+            r"^(\s*)(def|class)(\s.*)?$")
+        self.multiline_defclass_end_re = re.compile(r":\s*$")
+
+        # Transition list format
+        #  ["FROM", "TO", condition, action]
+        transitions = [
+            # FILEHEAD
+
+            # single line comments
+            ["FILEHEAD", "FILEHEAD", self.single_comment_re.search,
+                self.appendCommentLine],
+            ["FILEHEAD", "FILEHEAD", self.double_comment_re.search,
+                self.appendCommentLine],
+
+            # multiline comments
+            ["FILEHEAD", "FILEHEAD_COMMENT_SINGLE",
+                self.start_single_comment_re.search, self.appendCommentLine],
+            ["FILEHEAD_COMMENT_SINGLE", "FILEHEAD",
+                self.end_single_comment_re.search, self.appendCommentLine],
+            ["FILEHEAD_COMMENT_SINGLE", "FILEHEAD_COMMENT_SINGLE",
+                self.catchall, self.appendCommentLine],
+            ["FILEHEAD", "FILEHEAD_COMMENT_DOUBLE",
+                self.start_double_comment_re.search, self.appendCommentLine],
+            ["FILEHEAD_COMMENT_DOUBLE", "FILEHEAD",
+                self.end_double_comment_re.search, self.appendCommentLine],
+            ["FILEHEAD_COMMENT_DOUBLE", "FILEHEAD_COMMENT_DOUBLE",
+                self.catchall, self.appendCommentLine],
+
+            # other lines
+            ["FILEHEAD", "FILEHEAD", self.empty_re.search, self.appendFileheadLine],
+            ["FILEHEAD", "FILEHEAD", self.hashline_re.search, self.appendFileheadLine],
+            ["FILEHEAD", "FILEHEAD", self.importline_re.search,
+                self.appendFileheadLine],
+            ["FILEHEAD", "DEFCLASS", self.defclass_re.search, self.resetCommentSearch],
+            ["FILEHEAD", "DEFCLASS_MULTI",
+                self.multiline_defclass_start_re.search, self.resetCommentSearch],
+            ["FILEHEAD", "DEFCLASS_BODY", self.catchall, self.appendFileheadLine],
+
+            # DEFCLASS
+
+            # single line comments
+            ["DEFCLASS", "DEFCLASS_BODY",
+                self.single_comment_re.search, self.appendCommentLine],
+            ["DEFCLASS", "DEFCLASS_BODY",
+                self.double_comment_re.search, self.appendCommentLine],
+
+            # multiline comments
+            ["DEFCLASS", "COMMENT_SINGLE",
+                self.start_single_comment_re.search, self.appendCommentLine],
+            ["COMMENT_SINGLE", "DEFCLASS_BODY",
+                self.end_single_comment_re.search, self.appendCommentLine],
+            ["COMMENT_SINGLE", "COMMENT_SINGLE",
+                self.catchall, self.appendCommentLine],
+            ["DEFCLASS", "COMMENT_DOUBLE",
+                self.start_double_comment_re.search, self.appendCommentLine],
+            ["COMMENT_DOUBLE", "DEFCLASS_BODY",
+                self.end_double_comment_re.search, self.appendCommentLine],
+            ["COMMENT_DOUBLE", "COMMENT_DOUBLE",
+                self.catchall, self.appendCommentLine],
+
+            # other lines
+            ["DEFCLASS", "DEFCLASS", self.empty_re.search, self.appendDefclassLine],
+            ["DEFCLASS", "DEFCLASS", self.defclass_re.search, self.resetCommentSearch],
+            ["DEFCLASS", "DEFCLASS_MULTI",
+                self.multiline_defclass_start_re.search, self.resetCommentSearch],
+            ["DEFCLASS", "DEFCLASS_BODY", self.catchall, self.stopCommentSearch],
+
+            # DEFCLASS_BODY
+
+            ["DEFCLASS_BODY", "DEFCLASS",
+                self.defclass_re.search, self.startCommentSearch],
+            ["DEFCLASS_BODY", "DEFCLASS_MULTI",
+                self.multiline_defclass_start_re.search, self.startCommentSearch],
+            ["DEFCLASS_BODY", "DEFCLASS_BODY", self.catchall, self.appendNormalLine],
+
+            # DEFCLASS_MULTI
+            ["DEFCLASS_MULTI", "DEFCLASS",
+                self.multiline_defclass_end_re.search, self.appendDefclassLine],
+            ["DEFCLASS_MULTI", "DEFCLASS_MULTI",
+                self.catchall, self.appendDefclassLine],
+        ]
+
+        self.fsm = FSM("FILEHEAD", transitions)
+        self.outstream = sys.stdout
+
+        self.output = []
+        self.comment = []
+        self.filehead = []
+        self.defclass = []
+        self.indent = ""
+
+    def __closeComment(self):
+        """Appends any open comment block and triggering block to the output."""
+
+        if args.autobrief:
+            if len(self.comment) == 1 \
+                    or (len(self.comment) > 2 and self.comment[1].strip() == ''):
+                self.comment[0] = self.__docstringSummaryToBrief(
+                    self.comment[0])
+
+        if self.comment:
+            block = self.makeCommentBlock()
+            self.output.extend(block)
+
+        if self.defclass:
+            self.output.extend(self.defclass)
+
+    def __docstringSummaryToBrief(self, line):
+        """Adds \\brief to the docstrings summary line.
+
+        A \\brief is prepended, provided no other doxygen command is at the
+        start of the line.
+        """
+        stripped = line.strip()
+        if stripped and not stripped[0] in ('@', '\\'):
+            return "\\brief " + line
+        else:
+            return line
+
+    def __flushBuffer(self):
+        """Flushes the current outputbuffer to the outstream."""
+        if self.output:
+            try:
+                if args.debug:
+                    print("# OUTPUT: ", self.output, file=sys.stderr)
+                print("\n".join(self.output), file=self.outstream)
+                self.outstream.flush()
+            except IOError:
+                # Fix for FS#33. Catches "broken pipe" when doxygen closes
+                # stdout prematurely upon usage of INPUT_FILTER, INLINE_SOURCES
+                # and FILTER_SOURCE_FILES.
+                pass
+        self.output = []
+
+    def catchall(self, input):
+        """The catchall-condition, always returns true."""
+        return True
+
+    def resetCommentSearch(self, match):
+        """Restarts a new comment search for a different triggering line.
+
+        Closes the current commentblock and starts a new comment search.
+        """
+        if args.debug:
+            print("# CALLBACK: resetCommentSearch", file=sys.stderr)
+        self.__closeComment()
+        self.startCommentSearch(match)
+
+    def startCommentSearch(self, match):
+        """Starts a new comment search.
+
+        Saves the triggering line, resets the current comment and saves
+        the current indentation.
+        """
+        if args.debug:
+            print("# CALLBACK: startCommentSearch", file=sys.stderr)
+        self.defclass = [self.fsm.current_input]
+        self.comment = []
+        self.indent = match.group(1)
+
+    def stopCommentSearch(self, match):
+        """Stops a comment search.
+
+        Closes the current commentblock, resets    the triggering line and
+        appends the current line to the output.
+        """
+        if args.debug:
+            print("# CALLBACK: stopCommentSearch", file=sys.stderr)
+        self.__closeComment()
+
+        self.defclass = []
+        self.output.append(self.fsm.current_input)
+
+    def appendFileheadLine(self, match):
+        """Appends a line in the FILEHEAD state.
+
+        Closes the open comment    block, resets it and appends the current line.
+        """
+        if args.debug:
+            print("# CALLBACK: appendFileheadLine", file=sys.stderr)
+        self.__closeComment()
+        self.comment = []
+        self.output.append(self.fsm.current_input)
+
+    def appendCommentLine(self, match):
+        """Appends a comment line.
+
+        The comment delimiter is removed from multiline start and ends as
+        well as singleline comments.
+        """
+        if args.debug:
+            print("# CALLBACK: appendCommentLine", file=sys.stderr)
+        (from_state, to_state, condition, callback) = self.fsm.current_transition
+
+        # single line comment
+        if (from_state == "DEFCLASS" and to_state == "DEFCLASS_BODY") \
+                or (from_state == "FILEHEAD" and to_state == "FILEHEAD"):
+            # remove comment delimiter from begin and end of the line
+            activeCommentDelim = match.group(1)
+            line = self.fsm.current_input
+            self.comment.append(line[line.find(
+                activeCommentDelim) + len(activeCommentDelim):line.rfind(activeCommentDelim)])
+
+            if (to_state == "DEFCLASS_BODY"):
+                self.__closeComment()
+                self.defclass = []
+        # multiline start
+        elif from_state == "DEFCLASS" or from_state == "FILEHEAD":
+            # remove comment delimiter from begin of the line
+            activeCommentDelim = match.group(1)
+            line = self.fsm.current_input
+            self.comment.append(
+                line[line.find(activeCommentDelim) + len(activeCommentDelim):])
+        # multiline end
+        elif to_state == "DEFCLASS_BODY" or to_state == "FILEHEAD":
+            # remove comment delimiter from end of the line
+            activeCommentDelim = match.group(1)
+            line = self.fsm.current_input
+            self.comment.append(line[0:line.rfind(activeCommentDelim)])
+            if (to_state == "DEFCLASS_BODY"):
+                self.__closeComment()
+                self.defclass = []
+        # in multiline comment
+        else:
+            # just append the comment line
+            self.comment.append(self.fsm.current_input)
+
+    def appendNormalLine(self, match):
+        """Appends a line to the output."""
+        if args.debug:
+            print("# CALLBACK: appendNormalLine", file=sys.stderr)
+        self.output.append(self.fsm.current_input)
+
+    def appendDefclassLine(self, match):
+        """Appends a line to the triggering block."""
+        if args.debug:
+            print("# CALLBACK: appendDefclassLine", file=sys.stderr)
+        self.defclass.append(self.fsm.current_input)
+
+    def makeCommentBlock(self):
+        """Indents the current comment block with respect to the current
+        indentation level.
+
+        @returns a list of indented comment lines
+        """
+        doxyStart = "##"
+        commentLines = self.comment
+
+        commentLines = ["%s# %s" % (self.indent, x) for x in commentLines]
+        l = [self.indent + doxyStart]
+        l.extend(commentLines)
+
+        return l
+
+    def parse(self, input):
+        """Parses a python file given as input string and returns the doxygen-
+        compatible representation.
+
+        @param    input    the python code to parse
+        @returns the modified python code
+        """
+        lines = input.split("\n")
+
+        for line in lines:
+            self.fsm.makeTransition(line)
+
+        if self.fsm.current_state == "DEFCLASS":
+            self.__closeComment()
+
+        return "\n".join(self.output)
+
+    def parseFile(self, filename):
+        """Parses a python file given as input string and returns the doxygen-
+        compatible representation.
+
+        @param    input    the python code to parse
+        @returns the modified python code
+        """
+        f = open(filename, 'r')
+
+        for line in f:
+            self.parseLine(line.rstrip('\r\n'))
+        if self.fsm.current_state == "DEFCLASS":
+            self.__closeComment()
+            self.__flushBuffer()
+        f.close()
+
+    def parseLine(self, line):
+        """Parse one line of python and flush the resulting output to the
+        outstream.
+
+        @param    line    the python code line to parse
+        """
+        self.fsm.makeTransition(line)
+        self.__flushBuffer()
+
+
+def argParse():
+    """Parses commandline args."""
+    parser = ArgumentParser(prog=__applicationName__)
+
+    parser.add_argument("--version", action="version",
+                        version="%(prog)s " + __version__
+                        )
+    parser.add_argument("--autobrief", action="store_true",
+                        help="use the docstring summary line as \\brief description"
+                        )
+    parser.add_argument("--debug", action="store_true",
+                        help="enable debug output on stderr"
+                        )
+    parser.add_argument("filename", metavar="FILENAME")
+
+    return parser.parse_args()
+
+
+def main():
+    """Starts the parser on the file given by the filename as the first
+    argument on the commandline.
+    """
+    global args
+    args = argParse()
+    fsm = Doxypy()
+    fsm.parseFile(args.filename)
+
+
+if __name__ == "__main__":
+    main()
diff --git a/docs/doxygen/other/group_defs.dox b/docs/doxygen/other/group_defs.dox
index 459ca80..d469944 100644
--- a/docs/doxygen/other/group_defs.dox
+++ b/docs/doxygen/other/group_defs.dox
@@ -1,7 +1,6 @@
 /*!
- * \defgroup block GNU Radio SATELLITES C++ Signal Processing Blocks
- * \brief All C++ blocks that can be used from the SATELLITES GNU Radio
+ * \defgroup block GNU Radio HOWTO C++ Signal Processing Blocks
+ * \brief All C++ blocks that can be used from the HOWTO GNU Radio
  *        module are listed here or in the subcategories below.
  *
  */
-
diff --git a/docs/doxygen/other/main_page.dox b/docs/doxygen/other/main_page.dox
index fcf538e..6357044 100644
--- a/docs/doxygen/other/main_page.dox
+++ b/docs/doxygen/other/main_page.dox
@@ -1,8 +1,8 @@
 /*! \mainpage
 
-Welcome to the GNU Radio SATELLITES Block
+Welcome to the GNU Radio HOWTO Block
 
-This is the intro page for the Doxygen manual generated for the SATELLITES
+This is the intro page for the Doxygen manual generated for the HOWTO
 block (docs/doxygen/other/main_page.dox). Edit it to add more detailed
 documentation about the new GNU Radio modules contained in this
 project.
diff --git a/docs/doxygen/pydoc_macros.h b/docs/doxygen/pydoc_macros.h
index 98bf7cd..fb3954b 100644
--- a/docs/doxygen/pydoc_macros.h
+++ b/docs/doxygen/pydoc_macros.h
@@ -16,4 +16,4 @@
     __doc_##n1##_##n2##_##n3##_##n4##_##n5##_##n6##_##n7
 #define DOC(...) __EXPAND(__EXPAND(__CAT2(__DOC, __VA_SIZE(__VA_ARGS__)))(__VA_ARGS__))
 
-#endif // PYDOC_MACROS_H
\ No newline at end of file
+#endif // PYDOC_MACROS_H
diff --git a/docs/doxygen/update_pydoc.py b/docs/doxygen/update_pydoc.py
index e6b4544..b65e168 100644
--- a/docs/doxygen/update_pydoc.py
+++ b/docs/doxygen/update_pydoc.py
@@ -16,16 +16,23 @@ python docstrings.
 
 """
 
-import os, sys, time, glob, re, json
+import os
+import sys
+import time
+import glob
+import re
+import json
 from argparse import ArgumentParser
 
 from doxyxml import DoxyIndex, DoxyClass, DoxyFriend, DoxyFunction, DoxyFile
 from doxyxml import DoxyOther, base
 
+
 def py_name(name):
     bits = name.split('_')
     return '_'.join(bits[1:])
 
+
 def make_name(name):
     bits = name.split('_')
     return bits[0] + '_make_' + '_'.join(bits[1:])
@@ -50,6 +57,7 @@ class Block(object):
             is_a_block = di.has_member(friendname, DoxyFunction)
         return is_a_block
 
+
 class Block2(object):
     """
     Checks if doxyxml produced objects correspond to a new style
@@ -63,7 +71,8 @@ class Block2(object):
         # Check for a parsing error.
         if item.error():
             return False
-        is_a_block2 = item.has_member('make', DoxyFunction) and item.has_member('sptr', DoxyOther)
+        is_a_block2 = item.has_member(
+            'make', DoxyFunction) and item.has_member('sptr', DoxyOther)
         return is_a_block2
 
 
@@ -94,6 +103,7 @@ def combine_descriptions(obj):
         description.append(dd)
     return utoascii('\n\n'.join(description)).strip()
 
+
 def format_params(parameteritems):
     output = ['Args:']
     template = '    {0} : {1}'
@@ -101,7 +111,10 @@ def format_params(parameteritems):
         output.append(template.format(pi.name, pi.description))
     return '\n'.join(output)
 
+
 entry_templ = '%feature("docstring") {name} "{docstring}"'
+
+
 def make_entry(obj, name=None, templ="{description}", description=None, params=[]):
     """
     Create a docstring key/value pair, where the key is the object name.
@@ -114,9 +127,9 @@ def make_entry(obj, name=None, templ="{description}", description=None, params=[
             used as the description instead of extracting it from obj.
     """
     if name is None:
-        name=obj.name()
-        if hasattr(obj,'_parse_data') and hasattr(obj._parse_data,'definition'):
-            name=obj._parse_data.definition.split(' ')[-1]
+        name = obj.name()
+        if hasattr(obj, '_parse_data') and hasattr(obj._parse_data, 'definition'):
+            name = obj._parse_data.definition.split(' ')[-1]
     if "operator " in name:
         return ''
     if description is None:
@@ -174,9 +187,10 @@ def make_block_entry(di, block):
     output = {}
     output.update(make_class_entry(block, description=super_description))
     output.update(make_entry(make_func, description=super_description,
-                                  params=block.params))
+                             params=block.params))
     return output
 
+
 def make_block2_entry(di, block):
     """
     Create class and function docstrings of a new style gnuradio block
@@ -186,19 +200,21 @@ def make_block2_entry(di, block):
     class_description = combine_descriptions(block)
     make_func = block.get_member('make', DoxyFunction)
     make_description = combine_descriptions(make_func)
-    description = class_description + "\n\nConstructor Specific Documentation:\n\n" + make_description
+    description = class_description + \
+        "\n\nConstructor Specific Documentation:\n\n" + make_description
     # Associate the combined description with the class and
     # the make function.
     output = {}
     output.update(make_class_entry(
-            block, description=description,
-            ignored_methods=['make'], params=make_func.params))
+        block, description=description,
+        ignored_methods=['make'], params=make_func.params))
     makename = block.name() + '::make'
     output.update(make_entry(
-            make_func, name=makename, description=description,
-            params=make_func.params))
+        make_func, name=makename, description=description,
+        params=make_func.params))
     return output
 
+
 def get_docstrings_dict(di, custom_output=None):
 
     output = {}
@@ -218,19 +234,21 @@ def get_docstrings_dict(di, custom_output=None):
                 make_funcs.add(make_func.name())
                 output.update(make_block_entry(di, block))
         except block.ParsingError:
-            sys.stderr.write('Parsing error for block {0}\n'.format(block.name()))
+            sys.stderr.write(
+                'Parsing error for block {0}\n'.format(block.name()))
             raise
 
     for block in blocks2:
         try:
             make_func = block.get_member('make', DoxyFunction)
-            make_func_name = block.name() +'::make'
+            make_func_name = block.name() + '::make'
             # Don't want to risk writing to output twice.
             if make_func_name not in make_funcs:
                 make_funcs.add(make_func_name)
                 output.update(make_block2_entry(di, block))
         except block.ParsingError:
-            sys.stderr.write('Parsing error for block {0}\n'.format(block.name()))
+            sys.stderr.write(
+                'Parsing error for block {0}\n'.format(block.name()))
             raise
 
     # Create docstrings for functions
@@ -241,7 +259,8 @@ def get_docstrings_dict(di, custom_output=None):
         try:
             output.update(make_entry(f))
         except f.ParsingError:
-            sys.stderr.write('Parsing error for function {0}\n'.format(f.name()))
+            sys.stderr.write(
+                'Parsing error for function {0}\n'.format(f.name()))
 
     # Create docstrings for classes
     block_names = [block.name() for block in blocks]
@@ -259,64 +278,69 @@ def get_docstrings_dict(di, custom_output=None):
 
     return output
 
+
 def sub_docstring_in_pydoc_h(pydoc_files, docstrings_dict, output_dir, filter_str=None):
     if filter_str:
-        docstrings_dict = {k: v for k, v in docstrings_dict.items() if k.startswith(filter_str)}
+        docstrings_dict = {
+            k: v for k, v in docstrings_dict.items() if k.startswith(filter_str)}
+
+    with open(os.path.join(output_dir, 'docstring_status'), 'w') as status_file:
 
-    with open(os.path.join(output_dir,'docstring_status'),'w') as status_file:
-    
         for pydoc_file in pydoc_files:
             if filter_str:
-                filter_str2 = "::".join((filter_str,os.path.split(pydoc_file)[-1].split('_pydoc_template.h')[0]))
-                docstrings_dict2 = {k: v for k, v in docstrings_dict.items() if k.startswith(filter_str2)}
+                filter_str2 = "::".join((filter_str, os.path.split(
+                    pydoc_file)[-1].split('_pydoc_template.h')[0]))
+                docstrings_dict2 = {
+                    k: v for k, v in docstrings_dict.items() if k.startswith(filter_str2)}
             else:
                 docstrings_dict2 = docstrings_dict
 
-
-
-            file_in = open(pydoc_file,'r').read()
-            for key, value in docstrings_dict2.items(): 
-                file_in_tmp = file_in 
+            file_in = open(pydoc_file, 'r').read()
+            for key, value in docstrings_dict2.items():
+                file_in_tmp = file_in
                 try:
                     doc_key = key.split("::")
                     # if 'gr' in doc_key:
-                    #     doc_key.remove('gr') 
+                    #     doc_key.remove('gr')
                     doc_key = '_'.join(doc_key)
-                    regexp = r'(__doc_{} =\sR\"doc\()[^)]*(\)doc\")'.format(doc_key)
+                    regexp = r'(__doc_{} =\sR\"doc\()[^)]*(\)doc\")'.format(
+                        doc_key)
                     regexp = re.compile(regexp, re.MULTILINE)
-                
-                    (file_in, nsubs) = regexp.subn(r'\1'+value+r'\2', file_in, count=1)
+
+                    (file_in, nsubs) = regexp.subn(
+                        r'\1' + value + r'\2', file_in, count=1)
                     if nsubs == 1:
                         status_file.write("PASS: " + pydoc_file + "\n")
                 except KeyboardInterrupt:
                     raise KeyboardInterrupt
-                except: # be permissive, TODO log, but just leave the docstring blank
+                except:  # be permissive, TODO log, but just leave the docstring blank
                     status_file.write("FAIL: " + pydoc_file + "\n")
                     file_in = file_in_tmp
 
-            output_pathname = os.path.join(output_dir, os.path.basename(pydoc_file).replace('_template.h','.h'))
-            # FIXME: Remove this debug print
-            print('output docstrings to {}'.format(output_pathname))
-            with open(output_pathname,'w') as file_out:
+            output_pathname = os.path.join(output_dir, os.path.basename(
+                pydoc_file).replace('_template.h', '.h'))
+            with open(output_pathname, 'w') as file_out:
                 file_out.write(file_in)
 
+
 def copy_docstring_templates(pydoc_files, output_dir):
-    with open(os.path.join(output_dir,'docstring_status'),'w') as status_file:
+    with open(os.path.join(output_dir, 'docstring_status'), 'w') as status_file:
         for pydoc_file in pydoc_files:
-            file_in = open(pydoc_file,'r').read()
-            output_pathname = os.path.join(output_dir, os.path.basename(pydoc_file).replace('_template.h','.h'))
-            # FIXME: Remove this debug print
-            print('copy docstrings to {}'.format(output_pathname))
-            with open(output_pathname,'w') as file_out:
+            file_in = open(pydoc_file, 'r').read()
+            output_pathname = os.path.join(output_dir, os.path.basename(
+                pydoc_file).replace('_template.h', '.h'))
+            with open(output_pathname, 'w') as file_out:
                 file_out.write(file_in)
         status_file.write("DONE")
 
+
 def argParse():
     """Parses commandline args."""
-    desc='Scrape the doxygen generated xml for docstrings to insert into python bindings'
+    desc = 'Scrape the doxygen generated xml for docstrings to insert into python bindings'
     parser = ArgumentParser(description=desc)
-    
-    parser.add_argument("function", help="Operation to perform on docstrings", choices=["scrape","sub","copy"])
+
+    parser.add_argument("function", help="Operation to perform on docstrings", choices=[
+                        "scrape", "sub", "copy"])
 
     parser.add_argument("--xml_path")
     parser.add_argument("--bindings_dir")
@@ -326,6 +350,7 @@ def argParse():
 
     return parser.parse_args()
 
+
 if __name__ == "__main__":
     # Parse command line options and set up doxyxml.
     args = argParse()
@@ -337,10 +362,11 @@ if __name__ == "__main__":
     elif args.function.lower() == 'sub':
         with open(args.json_path, 'r') as fp:
             docstrings_dict = json.load(fp)
-        pydoc_files = glob.glob(os.path.join(args.bindings_dir,'*_pydoc_template.h'))
-        sub_docstring_in_pydoc_h(pydoc_files, docstrings_dict, args.output_dir, args.filter)
+        pydoc_files = glob.glob(os.path.join(
+            args.bindings_dir, '*_pydoc_template.h'))
+        sub_docstring_in_pydoc_h(
+            pydoc_files, docstrings_dict, args.output_dir, args.filter)
     elif args.function.lower() == 'copy':
-        pydoc_files = glob.glob(os.path.join(args.bindings_dir,'*_pydoc_template.h'))
+        pydoc_files = glob.glob(os.path.join(
+            args.bindings_dir, '*_pydoc_template.h'))
         copy_docstring_templates(pydoc_files, args.output_dir)
-
-            
-- 
2.35.0

